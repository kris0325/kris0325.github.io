[{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* 2024-07-15 18:11:19 Best Time to Buy and Sell Stock Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (53.62%)\t30890\t1149 Tags array | dynamic-programming Companies amazon | bloomberg | facebook | microsoft | uber You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. Example 1: Input: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell. Example 2: Input: prices = [7,6,4,3,1] Output: 0 Explanation: In this case, no transactions are done and the max profit = 0. Constraints: 1 \u0026lt;= prices.length \u0026lt;= 105 0 \u0026lt;= prices[i] \u0026lt;= 104 */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 //leetcode submit region begin(Prohibit modification and deletion) class Solution { //dp: äºŒç¶­æ•¸çµ„ï¼Œ 0ï½œ1è¡¨ç¤ºæŒæœ‰è‚¡ç¥¨ï½œä¸æŒæœ‰è‚¡ç¥¨çš„ç‹€æ…‹ //å®šç¾© dp[i][0]: ç¬¬iå¤©æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§æ”¶ç›Š ï¼Œ è¦ä¹ˆä¿æŒå‰ä¸€å¤©æŒæœ‰è‚¡ç¥¨çš„ç‹€æ…‹ï¼Œè¦ä¹ˆç•¶å¤©ç¬¬ä¸€æ¬¡è²·å…¥è‚¡ç¥¨ï¼ˆé‚£éº¼æ”¶ç›Šéœ€è¦æ¸›å»ç•¶å¤©è‚¡ç¥¨åƒ¹æ ¼ï¼Œæ‰€ä»¥ç‚ºè² æ•¸ï¼š-prices[i]ï¼‰ã€‚ //éæ¨å…¬å¼ï¼šdp[i][0] = Math.max(dp[i-1][0], -prices[i]) // dp[i][1]: ç¬¬iå¤©ä¸æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§æ”¶ç›Šï¼Œè¦ä¹ˆä¿æŒå‰ä¸€å¤©ä¸æŒæœ‰è‚¡ç¥¨çš„ç‹€æ…‹ï¼Œè¦ä¹ˆåœ¨ç•¶å¤©è³£å‡ºè‚¡ç¥¨ã€‚ // éæ¨å…¬å¼ï¼š dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i]) ç¬¬i-1å¤©æœ‰è‚¡ç¥¨ï¼Œåœ¨iå¤©è³£æ‰è‚¡ç¥¨ï½œ ç¬¬i-1å¤©å°±ä¸æ“æœ‰è‚¡ç¥¨ï¼Œé‚£ä¿æŒå’Œi-1ä¸è®Š //åˆå§‹åŒ–ï¼Œ ç¬¬0å¤©ç¾é‡‘ç‚º0ï¼Œ æŒæœ‰è‚¡ç¥¨ï¼Œé‚£éº¼ä¸€å®šå°±æ˜¯è²·å…¥è‚¡ç¥¨ï¼Œæ‰€ä»¥dp[0][0] = 0- prices[0] // ç¬¬0ä¸æŒæœ‰è‚¡ç¥¨å¾Œæœ€å¤šç¾é‡‘ï¼Œ ï¼Œä¸æŒæœ‰è‚¡ç¥¨ï¼Œ é‚£ç¾é‡‘å°±æ˜¯0ï¼Œ æ‰€ä»¥dp[0][1] = 0 public int maxProfit(int[] prices) { int[][] dp = new int[prices.length + 1][2]; //ç¬¬0å¤©æŒæœ‰è‚¡ç¥¨çš„æ”¶ç›Šï¼ˆè² å€¼ï¼‰ dp[0][0] = -prices[0]; //ç¬¬0å¤©ä¸æŒæœ‰è‚¡ç¥¨çš„æ”¶ç›Š dp[0][1] = 0; for (int i = 1; i \u0026lt; prices.length; i++) { //ä¸èƒ½é€™æ¨£å®šç¾© å› ç‚º dp[i-1][1] åŒ…æ¶µäº†æŒæœ‰è‚¡ç¥¨ä¸¦è³£å‡ºè‚¡ç¥¨çš„caseé‚è¼¯, é‚£éº¼ dp[i-1][1] - prices[i] å°±ç›¸ç•¶æ–¼åŒä¸€å¤©å…ˆè³£å‡ºè‚¡ç¥¨ï¼Œå†è²·å…¥è‚¡ç¥¨ï¼Œä¸ç¬¦åˆé¡Œç›®çš„é™åˆ¶ //å› ç‚ºæˆ‘å€‘åœ¨åŒä¸€å¤©åªèƒ½é€²è¡Œä¸€æ¬¡æ“ä½œï¼ˆè¦ä¹ˆè²·å…¥ï¼Œè¦ä¹ˆè³£å‡ºï¼‰æ‰€ä»¥ï¼Œé€™è£¡çš„é‚è¼¯æ˜¯ä¸å°çš„ // bug: dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]-prices[i]); //å¦‚æœå…è¨±åŒä¸€å¤©å¤šæ¬¡è²·è³£å³ï¼Œ122. Best Time to Buy and Sell Stock IIï¼Œé‚£éº¼å°±æ‡‰è©²å¯«ç‚ºï¼šdp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]-prices[i]); dp[i][0] = Math.max(dp[i - 1][0], -prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]); } return dp[prices.length - 1][1]; } } //leetcode submit region end(Prohibit modification and deletion) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution1 { //greedy: éå†pricesï¼Œ ç´€éŒ„ä¸¦å–å·¦æœ€å·¦æœ€å°åƒ¹æ ¼ï¼Œ å–æœ€å³æœ€å¤§å€¼ï¼Œé‚£éº¼å¾—åˆ°å·®å€¼å°±æ˜¯æœ€å¤§åˆ©æ½¤ public int maxProfit(int[] prices) { int lowPrice = Integer.MAX_VALUE; int maxProfit = 0; for (int i = 0; i \u0026lt; prices.length; i++) { lowPrice = Math.min(lowPrice, prices[i]); //ç›¸ç•¶æ–¼ï¼Œç•¶å€é–“åˆ©æ½¤è®Šå¤§æ™‚ï¼Œæ‰æ›´æ–°maxProfit maxProfit = Math.max(maxProfit, prices[i] - lowPrice); } return maxProfit; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution0 { //æš´åŠ›è§£æ³• : ä¸¤å±‚for loop, éå†æ¯å¤©ï¼Œè®¡ç®—ä¹°å½“å‰è‚¡ç¥¨ï¼Œæœªæ¥æŸä¸€å¤©å–å‡ºçš„æœ€å¤§å€¼ï¼Œå¦‚ä½•ç»“æœå–æœ€å¤§å€¼ //time limit exceeded public int maxProfit(int[] prices) { int maxProfit = 0; for (int i = 0; i \u0026lt; prices.length - 1; i++) { for (int j = i + 1; j \u0026lt; prices.length; j++) { maxProfit = Math.max(prices[j] - prices[i], maxProfit); } } return maxProfit; } } ","date":"2024-07-15T00:00:00Z","image":"https://kris0325.github.io/p/121.besttimetobuyandsellstock/121_hue85b2e7bab1f30b7b29041d5fedf799e_6645868_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/121.besttimetobuyandsellstock/","title":"121.BestTimeToBuyAndSellStock"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /** * You are a professional robber planning to rob houses along a street. Each house * has a certain amount of money stashed, the only constraint stopping you from * robbing each of them is that adjacent houses have security systems connected and * it will automatically contact the police if two adjacent houses were broken into * on the same night. * \u0026lt;p\u0026gt; * Given an integer array nums representing the amount of money of each house, * return the maximum amount of money you can rob tonight without alerting the police. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 1: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: nums = [1,2,3,1] * Output: 4 * Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). * Total amount you can rob = 1 + 3 = 4. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 2: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: nums = [2,7,9,3,1] * Output: 12 * Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 ( * money = 1). * Total amount you can rob = 2 + 9 + 1 = 12. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Constraints: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * 1 \u0026lt;= nums.length \u0026lt;= 100 * 0 \u0026lt;= nums[i] \u0026lt;= 400 * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Related Topics Array Dynamic Programming ğŸ‘ 21014 ğŸ‘ 422 */ /* 2024-07-12 15:20:03 */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int rob(int[] nums) { return stealStore(nums); } public int stealStore(int[] stores) { if (stores == null || stores.length == 0) { return 0; } if (stores.length == 1) { return stores[0]; } int[] dp = new int[stores.length]; dp[0] = stores[0]; dp[1] = Math.max(dp[0], stores[1]); for (int i = 2; i \u0026lt; stores.length; i++) { //dp[i] å¯ä»¥åˆ†ç‚º ä¸rob ï½œ rob ç•¶å‰stores[i]ï¼Œå–äºŒè€…ä¸­çš„è¼ƒå¤§å€¼ dp[i] = Math.max(dp[i - 1], dp[i - 2] + stores[i]); System.out.printf(\u0026#34;i:%s, dp[i]:%s \u0026#34;, i, dp[i]); } return dp[stores.length - 1]; } } ","date":"2024-07-15T00:00:00Z","image":"https://kris0325.github.io/p/198.houserobber/198_hubd383456b9673aed2bfe56a6b5423b94_14187007_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/198.houserobber/","title":"198.HouseRobber"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 /** * You are a professional robber planning to rob houses along a street. Each house * has a certain amount of money stashed. All houses at this place are arranged in * a circle. That means the first house is the neighbor of the last one. Meanwhile, * adjacent houses have a security system connected, and it will automatically * contact the police if two adjacent houses were broken into on the same night. * \u0026lt;p\u0026gt; * Given an integer array nums representing the amount of money of each house, * return the maximum amount of money you can rob tonight without alerting the police. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 1: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: nums = [2,3,2] * Output: 3 * Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2) * , because they are adjacent houses. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 2: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: nums = [1,2,3,1] * Output: 4 * Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). * Total amount you can rob = 1 + 3 = 4. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 3: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: nums = [1,2,3] * Output: 3 * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Constraints: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * 1 \u0026lt;= nums.length \u0026lt;= 100 * 0 \u0026lt;= nums[i] \u0026lt;= 1000 * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Related Topics Array Dynamic Programming ğŸ‘ 9805 ğŸ‘ 151 */ /* 2024-07-12 16:35:45 House Robber II Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (41.96%)\t9805\t151 Tags dynamic-programming Companies microsoft */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { //DP: consider circle nums, nums[0], nums[length-1] are adjacent, so we can divide nums into two line new nums such as nums1: nums[0] -num[length-2] , nums2: nums[1] -num[length-1], // and get maximum = Math.max( rob(nums1), rob(nums2)) //å°‡ç’°ç‹€houseï¼Œæ‹†ç‚ºç·šå‹house,è®“é¦–å°¾houseä¸å†ç›¸é€£ï¼Œç°¡åŒ–å•é¡Œï¼Œå³å°†nums æ‹†åˆ†ç‚º2å€‹æ•¸çµ„ï¼Œ å¾è€ŒæŠŠæ‰“å®¶åŠ«èˆrobII è½¬åŒ–ä¸º æ‰“å®¶åŠ«èˆrob public int rob(int[] nums) { if (nums == null || nums.length == 0) { return 0; } if (nums.length == 1) { return nums[0]; } //å¾ç¬¬ä¸€å®¶é–‹å§‹æ‰“åŠ«,ç›´åˆ°nums[nums.length - 2], start to rob from the first house nums[0], so not consider to rob the last house nums[length-1] int robFromFirst = robLinear(nums, 0, nums.length - 2); //å¾ç¬¬äºŒå®¶é–‹å§‹æ‰“åŠ«ï¼Œç›´åˆ°nums[nums.length - 1], start to rob from the second house num[1], so consider to rob the last house nums[length-1] int robFromSecond = robLinear(nums, 1, nums.length - 1); return Math.max(robFromFirst, robFromSecond); } public int robLinear(int[] nums, int start, int end) { if (start == end) { return nums[start]; } int[] dp = new int[nums.length]; dp[start] = nums[start]; dp[start+1] = Math.max(nums[start], nums[start + 1]); for (int i = start + 2; i \u0026lt;= end; i++) { //dp[i] å¯ä»¥åˆ†ç‚º rob ï½œ ä¸rob ç•¶å‰stores[i]ï¼Œå–äºŒè€…ä¸­çš„è¼ƒå¤§å€¼ dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]); } return dp[end]; } private int robLinear2(int[] houses, int start, int end) { if (start == end) { return houses[start]; } int n = end - start + 1; int[] dp = new int[n]; //æ³¨æ„å¤„ç†åˆå§‹åŒ–å€¼ï¼Œä¸dp[n]æ•°ç»„ dp[0] = houses[start]; dp[1] = Math.max(houses[start], houses[start + 1]); for (int i = 2; i \u0026lt; n; i++) { dp[i] = Math.max(dp[i - 1], dp[i - 2] + houses[start + i]); } return dp[n - 1]; } } ","date":"2024-07-12T00:00:00Z","image":"https://kris0325.github.io/p/213.houserobberii/213_hu38db8936e2cc7a120e9a7c60257dabc2_1817286_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/213.houserobberii/","title":"213.HouseRobberII"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 /** * You are given an integer array nums and an integer target. * \u0026lt;p\u0026gt; * You want to build an expression out of nums by adding one of the symbols \u0026#39;+\u0026#39; * and \u0026#39;-\u0026#39; before each integer in nums and then concatenate all the integers. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * For example, if nums = [2, 1], you can add a \u0026#39;+\u0026#39; before 2 and a \u0026#39;-\u0026#39; before 1 * and concatenate them to build the expression \u0026#34;+2-1\u0026#34;. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Return the number of different expressions that you can build, which evaluates * to target. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 1: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: nums = [1,1,1,1,1], target = 3 * Output: 5 * Explanation: There are 5 ways to assign symbols to make the sum of nums be * target 3. * -1 + 1 + 1 + 1 + 1 = 3 * +1 - 1 + 1 + 1 + 1 = 3 * +1 + 1 - 1 + 1 + 1 = 3 * +1 + 1 + 1 - 1 + 1 = 3 * +1 + 1 + 1 + 1 - 1 = 3 * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 2: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: nums = [1], target = 1 * Output: 1 * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Constraints: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * 1 \u0026lt;= nums.length \u0026lt;= 20 * 0 \u0026lt;= nums[i] \u0026lt;= 1000 * 0 \u0026lt;= sum(nums[i]) \u0026lt;= 1000 * -1000 \u0026lt;= target \u0026lt;= 1000 * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Related Topics Array Dynamic Programming Backtracking ğŸ‘ 10847 ğŸ‘ 359 */ /* 2024-07-11 11:48:49 Target Sum Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (46.76%)\t10847\t359 Tags dynamic-programming | depth-first-search Companies facebook | google */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class TargetSum { public static void main(String[] args) { Solution solution = new TargetSum().new Solution(); } //leetcode submit region begin(Prohibit modification and deletion) class Solution { //dp: 01èƒŒåŒ…å•é¡Œ //å¦‚ä½•è½‰ç‚º01èƒŒåŒ…å•é¡Œï¼Ÿ //å¯ä»¥å‡è¨­å°‡nums[i] æ‹†åˆ†ç‚º2å€‹æ•¸çµ„ï¼Œå³æ·»åŠ +çš„æ•¸çµ„addï¼Œ å’Œæ·»åŠ -çš„æ•¸çµ„minusï¼Œ åŠ æ³•ç¸½å’Œç‚ºadd, æ¸›æ³•ç¸½å’Œç‚ºminus é‚£éº¼å¯å¾—åˆ°å…¬å¼ï¼š // add + minus = sum (sumç‚ºnumså…ƒç´ ç¸½å’Œ) // add - minus = target //é‚£éº¼å¯ä»¥æ¨å°å‡º add = (sum + target)/2 , å°±è½‰åŒ–ç‚ºå•é¡Œï¼šæ±‚æ‹†åˆ†ä¸€å€‹æ•¸çµ„addæ»¿è¶³add = (sum + target)/2çš„æ–¹æ¡ˆå³å¤šå°‘ç¨® // ä¾¿å¯è½‰åŒ–ç‚ºæ±‚è£æ»¿å®¹é‡ç‚ºaddçš„01èƒŒåŒ…ï¼Œæœ‰å¤šå°‘ç¨®æ–¹æ³• dp[j], jç‚ºèƒŒåŒ…å®¹é‡ //æ³¨æ„ï¼šç”±æ–¼è¨ˆç®—add ç‚ºå‘ä¸‹å–æ•´ï¼Œé‚£éº¼ (sum + target) %2 ==1ï¼Œæ­¤æ™‚æ²’æœ‰æ–¹æ¡ˆ //é‚£éº¼éæ¨æ•¸çµ„ dp[j] += dp[j - nums[i]], æ³¨æ„å’Œæ±‚èƒŒåŒ…è£æœ€å¤§åƒ¹å€¼ç‰©å“å•é¡Œä¸ä¸€æ¨£ï¼Œé€™è£¡æ˜¯æ±‚å¤šå°‘ç¨®æ–¹æ¡ˆï¼Œæ‰€ä»¥æ˜¯ç´¯åŠ  //åˆå§‹åŒ–ç‚ºdp[0] =1 , ( å› ç‚ºå¦‚æœdp[0] = 0ï¼Œé‚£éº¼dp[j]éƒ½æœƒç‚º0) public int findTargetSumWays(int[] nums, int target) { int sum = 0; for (int i = 0; i \u0026lt; nums.length; i++) { sum += nums[i]; } //ç„¡æ³•åˆ†é…ï¼Œæ²’æœ‰æ–¹æ¡ˆ if ((sum + target) % 2 == 1) { return 0; } //ç„¡æ³•åˆ†é…ï¼Œæ²’æœ‰æ–¹æ¡ˆ if (Math.abs(target) \u0026gt; sum) { return 0; } int addBagSize = (sum + target) / 2; int[] dp = new int[addBagSize + 1]; //å¦‚æœåˆå§‹åŒ–dp[0] = 0 æœƒç™¼ç¾dp[j]å…¨ç‚º0 dp[0] = 1; for (int i = 0; i \u0026lt; nums.length; i++) { for (int j = addBagSize; j \u0026gt;= nums[i]; j--) { //dp[j - nums[i]] è¡¨ç¤º å®¹é‡ç‚ºjçš„èƒŒåŒ…ï¼Œå»æ‰é‡é‡nums[i]çš„ç‰©å“ï¼Œ dp[j] += dp[j - nums[i]]; } } return dp[addBagSize]; } } //leetcode submit region end(Prohibit modification and deletion) } ","date":"2024-07-11T00:00:00Z","image":"https://kris0325.github.io/p/494.-targetsum/494_huf9c9f2cd678c7281d39a5aa5065d5df2_9785122_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/494.-targetsum/","title":"494. TargetSum"},{"content":" ä»£ç¢¼éš¨æƒ³éŒ„.äºŒå‰æ¨¹ç¸½çµ\näºŒå‰æ¨¹é¡Œå‹ äºŒå‰æ ‘çš„ç†è®ºåŸºç¡€ å…³äºäºŒå‰æ ‘ï¼Œä½ è¯¥äº†è§£è¿™äº›ï¼ (opens new window)ï¼šäºŒå‰æ ‘çš„ç§ç±»ã€å­˜å‚¨æ–¹å¼ã€éå†æ–¹å¼ã€å®šä¹‰æ–¹å¼\näºŒå‰æ ‘çš„éå†æ–¹å¼ æ·±åº¦ä¼˜å…ˆéå† äºŒå‰æ¨¹çš„éæ­·\näºŒå‰æ ‘ï¼šå‰ä¸­ååºé€’å½’æ³• (opens new window)ï¼šé€’å½’ä¸‰éƒ¨æ›²åˆæ¬¡äº®ç›¸\näºŒå‰æ ‘ï¼šå‰ä¸­ååºè¿­ä»£æ³•ï¼ˆä¸€ï¼‰ (opens new window)ï¼šé€šè¿‡æ ˆæ¨¡æ‹Ÿé€’å½’\näºŒå‰æ ‘ï¼šå‰ä¸­ååºè¿­ä»£æ³•ï¼ˆäºŒï¼‰ç»Ÿä¸€é£æ ¼(opens new window)\nå¹¿åº¦ä¼˜å…ˆéå†\näºŒå‰æ ‘çš„å±‚åºéå† (opens new window)ï¼šé€šè¿‡é˜Ÿåˆ—æ¨¡æ‹Ÿ\næ±‚äºŒå‰æ ‘çš„å±æ€§ äºŒå‰æ ‘ï¼šæ˜¯å¦å¯¹ç§°(opens new window)\né€’å½’ï¼šååºï¼Œæ¯”è¾ƒçš„æ˜¯æ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘ä¸å³å­æ ‘æ˜¯ä¸æ˜¯ç›¸äº’ç¿»è½¬\nè¿­ä»£ï¼šä½¿ç”¨é˜Ÿåˆ—/æ ˆå°†ä¸¤ä¸ªèŠ‚ç‚¹é¡ºåºæ”¾å…¥å®¹å™¨ä¸­è¿›è¡Œæ¯”è¾ƒ\näºŒå‰æ ‘ï¼šæ±‚æœ€å¤§æ·±åº¦(opens new window)\né€’å½’ï¼šååºï¼Œæ±‚æ ¹èŠ‚ç‚¹æœ€å¤§é«˜åº¦å°±æ˜¯æœ€å¤§æ·±åº¦ï¼Œé€šè¿‡é€’å½’å‡½æ•°çš„è¿”å›å€¼åšè®¡ç®—æ ‘çš„é«˜åº¦\nè¿­ä»£ï¼šå±‚åºéå†\näºŒå‰æ ‘ï¼šæ±‚æœ€å°æ·±åº¦(opens new window)\né€’å½’ï¼šååºï¼Œæ±‚æ ¹èŠ‚ç‚¹æœ€å°é«˜åº¦å°±æ˜¯æœ€å°æ·±åº¦ï¼Œæ³¨æ„æœ€å°æ·±åº¦çš„å®šä¹‰\nè¿­ä»£ï¼šå±‚åºéå†\näºŒå‰æ ‘ï¼šæ±‚æœ‰å¤šå°‘ä¸ªèŠ‚ç‚¹(opens new window)\né€’å½’ï¼šååºï¼Œé€šè¿‡é€’å½’å‡½æ•°çš„è¿”å›å€¼è®¡ç®—èŠ‚ç‚¹æ•°é‡\nè¿­ä»£ï¼šå±‚åºéå†\näºŒå‰æ ‘ï¼šæ˜¯å¦å¹³è¡¡(opens new window)\né€’å½’ï¼šååºï¼Œæ³¨æ„ååºæ±‚é«˜åº¦å’Œå‰åºæ±‚æ·±åº¦ï¼Œé€’å½’è¿‡ç¨‹åˆ¤æ–­é«˜åº¦å·®\nè¿­ä»£ï¼šæ•ˆç‡å¾ˆä½ï¼Œä¸æ¨è\näºŒå‰æ ‘ï¼šæ‰¾æ‰€æœ‰è·¯å¾„(opens new window)\né€’å½’ï¼šå‰åºï¼Œæ–¹ä¾¿è®©çˆ¶èŠ‚ç‚¹æŒ‡å‘å­èŠ‚ç‚¹ï¼Œæ¶‰åŠå›æº¯å¤„ç†æ ¹èŠ‚ç‚¹åˆ°å¶å­çš„æ‰€æœ‰è·¯å¾„\nè¿­ä»£ï¼šä¸€ä¸ªæ ˆæ¨¡æ‹Ÿé€’å½’ï¼Œä¸€ä¸ªæ ˆæ¥å­˜æ”¾å¯¹åº”çš„éå†è·¯å¾„\näºŒå‰æ ‘ï¼šé€’å½’ä¸­å¦‚ä½•éšè—ç€å›æº¯(opens new window)\nè¯¦è§£äºŒå‰æ ‘ï¼šæ‰¾æ‰€æœ‰è·¯å¾„ (opens new window)ä¸­é€’å½’å¦‚ä½•éšè—ç€å›æº¯\näºŒå‰æ ‘ï¼šæ±‚å·¦å¶å­ä¹‹å’Œ(opens new window)\né€’å½’ï¼šååºï¼Œå¿…é¡»ä¸‰å±‚çº¦æŸæ¡ä»¶ï¼Œæ‰èƒ½åˆ¤æ–­æ˜¯å¦æ˜¯å·¦å¶å­ã€‚\nè¿­ä»£ï¼šç›´æ¥æ¨¡æ‹Ÿååºéå†\näºŒå‰æ ‘ï¼šæ±‚å·¦ä¸‹è§’çš„å€¼(opens new window)\né€’å½’ï¼šé¡ºåºæ— æ‰€è°“ï¼Œä¼˜å…ˆå·¦å­©å­æœç´¢ï¼ŒåŒæ—¶æ‰¾æ·±åº¦æœ€å¤§çš„å¶å­èŠ‚ç‚¹ã€‚\nè¿­ä»£ï¼šå±‚åºéå†æ‰¾æœ€åä¸€è¡Œæœ€å·¦è¾¹\näºŒå‰æ ‘ï¼šæ±‚è·¯å¾„æ€»å’Œ(opens new window)\né€’å½’ï¼šé¡ºåºæ— æ‰€è°“ï¼Œé€’å½’å‡½æ•°è¿”å›å€¼ä¸ºboolç±»å‹æ˜¯ä¸ºäº†æœç´¢ä¸€æ¡è¾¹ï¼Œæ²¡æœ‰è¿”å›å€¼æ˜¯æœç´¢æ•´æ£µæ ‘ã€‚\nè¿­ä»£ï¼šæ ˆé‡Œå…ƒç´ ä¸ä»…è¦è®°å½•èŠ‚ç‚¹æŒ‡é’ˆï¼Œè¿˜è¦è®°å½•ä»å¤´ç»“ç‚¹åˆ°è¯¥èŠ‚ç‚¹çš„è·¯å¾„æ•°å€¼æ€»å’Œ\näºŒå‰æ ‘çš„ä¿®æ”¹ä¸æ„é€  ç¿»è½¬äºŒå‰æ ‘(opens new window)\né€’å½’ï¼šå‰åºï¼Œäº¤æ¢å·¦å³å­©å­\nè¿­ä»£ï¼šç›´æ¥æ¨¡æ‹Ÿå‰åºéå†\næ„é€ äºŒå‰æ ‘(opens new window)\né€’å½’ï¼šå‰åºï¼Œé‡ç‚¹åœ¨äºæ‰¾åˆ†å‰²ç‚¹ï¼Œåˆ†å·¦å³åŒºé—´æ„é€ \nè¿­ä»£ï¼šæ¯”è¾ƒå¤æ‚ï¼Œæ„ä¹‰ä¸å¤§\næ„é€ æœ€å¤§çš„äºŒå‰æ ‘(opens new window)\né€’å½’ï¼šå‰åºï¼Œåˆ†å‰²ç‚¹ä¸ºæ•°ç»„æœ€å¤§å€¼ï¼Œåˆ†å·¦å³åŒºé—´æ„é€ \nè¿­ä»£ï¼šæ¯”è¾ƒå¤æ‚ï¼Œæ„ä¹‰ä¸å¤§\nåˆå¹¶ä¸¤ä¸ªäºŒå‰æ ‘(opens new window)\né€’å½’ï¼šå‰åºï¼ŒåŒæ—¶æ“ä½œä¸¤ä¸ªæ ‘çš„èŠ‚ç‚¹ï¼Œæ³¨æ„åˆå¹¶çš„è§„åˆ™\nè¿­ä»£ï¼šä½¿ç”¨é˜Ÿåˆ—ï¼Œç±»ä¼¼å±‚åºéå†\n#æ±‚äºŒå‰æœç´¢æ ‘çš„å±æ€§\näºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢(opens new window)\né€’å½’ï¼šäºŒå‰æœç´¢æ ‘çš„é€’å½’æ˜¯æœ‰æ–¹å‘çš„\nè¿­ä»£ï¼šå› ä¸ºæœ‰æ–¹å‘ï¼Œæ‰€ä»¥è¿­ä»£æ³•å¾ˆç®€å•\næ˜¯ä¸æ˜¯äºŒå‰æœç´¢æ ‘(opens new window)\né€’å½’ï¼šä¸­åºï¼Œç›¸å½“äºå˜æˆäº†åˆ¤æ–­ä¸€ä¸ªåºåˆ—æ˜¯ä¸æ˜¯é€’å¢çš„\nè¿­ä»£ï¼šæ¨¡æ‹Ÿä¸­åºï¼Œé€»è¾‘ç›¸åŒ\næ±‚äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®(opens new window)\né€’å½’ï¼šä¸­åºï¼ŒåŒæŒ‡é’ˆæ“ä½œ\nè¿­ä»£ï¼šæ¨¡æ‹Ÿä¸­åºï¼Œé€»è¾‘ç›¸åŒ\næ±‚äºŒå‰æœç´¢æ ‘çš„ä¼—æ•°(opens new window)\né€’å½’ï¼šä¸­åºï¼Œæ¸…ç©ºç»“æœé›†çš„æŠ€å·§ï¼Œéå†ä¸€éä¾¿å¯æ±‚ä¼—æ•°é›†åˆ\näºŒå‰æœç´¢æ ‘è½¬æˆç´¯åŠ æ ‘(opens new window)\né€’å½’ï¼šä¸­åºï¼ŒåŒæŒ‡é’ˆæ“ä½œç´¯åŠ \nè¿­ä»£ï¼šæ¨¡æ‹Ÿä¸­åºï¼Œé€»è¾‘ç›¸åŒ\näºŒå‰æ ‘å…¬å…±ç¥–å…ˆé—®é¢˜ äºŒå‰æ ‘çš„å…¬å…±ç¥–å…ˆé—®é¢˜(opens new window)\né€’å½’ï¼šååºï¼Œå›æº¯ï¼Œæ‰¾åˆ°å·¦å­æ ‘å‡ºç°ç›®æ ‡å€¼ï¼Œå³å­æ ‘èŠ‚ç‚¹ç›®æ ‡å€¼çš„èŠ‚ç‚¹ã€‚\nè¿­ä»£ï¼šä¸é€‚åˆæ¨¡æ‹Ÿå›æº¯\näºŒå‰æœç´¢æ ‘çš„å…¬å…±ç¥–å…ˆé—®é¢˜(opens new window)\né€’å½’ï¼šé¡ºåºæ— æ‰€è°“ï¼Œå¦‚æœèŠ‚ç‚¹çš„æ•°å€¼åœ¨ç›®æ ‡åŒºé—´å°±æ˜¯æœ€è¿‘å…¬å…±ç¥–å…ˆ\nè¿­ä»£ï¼šæŒ‰åºéå†\näºŒå‰æœç´¢æ ‘çš„ä¿®æ”¹ä¸æ„é€  äºŒå‰æœç´¢æ ‘ä¸­çš„æ’å…¥æ“ä½œ(opens new window)\né€’å½’ï¼šé¡ºåºæ— æ‰€è°“ï¼Œé€šè¿‡é€’å½’å‡½æ•°è¿”å›å€¼æ·»åŠ èŠ‚ç‚¹\nè¿­ä»£ï¼šæŒ‰åºéå†ï¼Œéœ€è¦è®°å½•æ’å…¥çˆ¶èŠ‚ç‚¹ï¼Œè¿™æ ·æ‰èƒ½åšæ’å…¥æ“ä½œ\näºŒå‰æœç´¢æ ‘ä¸­çš„åˆ é™¤æ“ä½œ(opens new window)\né€’å½’ï¼šå‰åºï¼Œæƒ³æ¸…æ¥šåˆ é™¤éå¶å­èŠ‚ç‚¹çš„æƒ…å†µ\nè¿­ä»£ï¼šæœ‰åºéå†ï¼Œè¾ƒå¤æ‚\nä¿®å‰ªäºŒå‰æœç´¢æ ‘(opens new window)\né€’å½’ï¼šå‰åºï¼Œé€šè¿‡é€’å½’å‡½æ•°è¿”å›å€¼åˆ é™¤èŠ‚ç‚¹\nè¿­ä»£ï¼šæœ‰åºéå†ï¼Œè¾ƒå¤æ‚\næ„é€ äºŒå‰æœç´¢æ ‘(opens new window)\né€’å½’ï¼šå‰åºï¼Œæ•°ç»„ä¸­é—´èŠ‚ç‚¹åˆ†å‰²\nè¿­ä»£ï¼šè¾ƒå¤æ‚ï¼Œé€šè¿‡ä¸‰ä¸ªé˜Ÿåˆ—æ¥æ¨¡æ‹Ÿ\né˜¶æ®µæ€»ç»“ å¤§å®¶ä»¥ä¸Šé¢˜ç›®éƒ½åšè¿‡äº†ï¼Œä¹Ÿä¸€å®šè¦çœ‹å¦‚ä¸‹é˜¶æ®µå°ç»“ã€‚\næœ¬å‘¨å°ç»“ï¼ï¼ˆäºŒå‰æ ‘ç³»åˆ—ä¸€ï¼‰(opens new window) æœ¬å‘¨å°ç»“ï¼ï¼ˆäºŒå‰æ ‘ç³»åˆ—äºŒï¼‰(opens new window) æœ¬å‘¨å°ç»“ï¼ï¼ˆäºŒå‰æ ‘ç³»åˆ—ä¸‰ï¼‰(opens new window) æœ¬å‘¨å°ç»“ï¼ï¼ˆäºŒå‰æ ‘ç³»åˆ—å››ï¼‰(opens new window)\næœ€åæ€»ç»“ åœ¨äºŒå‰æ ‘é¢˜ç›®é€‰æ‹©ä»€ä¹ˆéå†é¡ºåºæ˜¯ä¸å°‘åŒå­¦å¤´ç–¼çš„äº‹æƒ…ï¼Œæˆ‘ä»¬åšäº†è¿™ä¹ˆå¤šäºŒå‰æ ‘çš„é¢˜ç›®äº†ï¼ŒCarlç»™å¤§å®¶å¤§ä½“åˆ†åˆ†ç±»ã€‚\næ¶‰åŠåˆ°äºŒå‰æ ‘çš„æ„é€ ï¼Œæ— è®ºæ™®é€šäºŒå‰æ ‘è¿˜æ˜¯äºŒå‰æœç´¢æ ‘ä¸€å®šå‰åºï¼Œéƒ½æ˜¯å…ˆæ„é€ ä¸­èŠ‚ç‚¹ã€‚\næ±‚æ™®é€šäºŒå‰æ ‘çš„å±æ€§ï¼Œä¸€èˆ¬æ˜¯ååºï¼Œä¸€èˆ¬è¦é€šè¿‡é€’å½’å‡½æ•°çš„è¿”å›å€¼åšè®¡ç®—ã€‚\næ±‚äºŒå‰æœç´¢æ ‘çš„å±æ€§ï¼Œä¸€å®šæ˜¯ä¸­åºäº†ï¼Œè¦ä¸ç™½çäº†æœ‰åºæ€§äº†ã€‚\næ³¨æ„åœ¨æ™®é€šäºŒå‰æ ‘çš„å±æ€§ä¸­ï¼Œæˆ‘ç”¨çš„æ˜¯ä¸€èˆ¬ä¸ºååºï¼Œä¾‹å¦‚å•çº¯æ±‚æ·±åº¦å°±ç”¨å‰åºï¼ŒäºŒå‰æ ‘ï¼šæ‰¾æ‰€æœ‰è·¯å¾„ (opens new window)ä¹Ÿç”¨äº†å‰åºï¼Œè¿™æ˜¯ä¸ºäº†æ–¹ä¾¿è®©çˆ¶èŠ‚ç‚¹æŒ‡å‘å­èŠ‚ç‚¹ã€‚\næ‰€ä»¥æ±‚æ™®é€šäºŒå‰æ ‘çš„å±æ€§è¿˜æ˜¯è¦å…·ä½“é—®é¢˜å…·ä½“åˆ†æã€‚\nbinaryTree å•é¡Œ ","date":"2024-07-11T00:00:00Z","image":"https://kris0325.github.io/p/binary-tree/bt_hua99fcc1aaa1faf16ce5e5faccd4635f1_11277059_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/binary-tree/","title":"Binary Tree"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 /** * You are given an array of integers stones where stones[i] is the weight of the * iáµ—Ê° stone. * \u0026lt;p\u0026gt; * We are playing a game with the stones. On each turn, we choose any two stones * and smash them together. Suppose the stones have weights x and y with x \u0026lt;= y. * The result of this smash is: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * If x == y, both stones are destroyed, and * If x != y, the stone of weight x is destroyed, and the stone of weight y has * new weight y - x. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * At the end of the game, there is at most one stone left. * \u0026lt;p\u0026gt; * Return the smallest possible weight of the left stone. If there are no stones * left, return 0. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 1: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: stones = [2,7,4,1,8,1] * Output: 1 * Explanation: * We can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then, * we can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then, * we can combine 2 and 1 to get 1, so the array converts to [1,1,1] then, * we can combine 1 and 1 to get 0, so the array converts to [1], then that\u0026#39;s the * optimal value. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 2: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: stones = [31,26,33,21,40] * Output: 5 * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Constraints: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * 1 \u0026lt;= stones.length \u0026lt;= 30 * 1 \u0026lt;= stones[i] \u0026lt;= 100 * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Related Topics Array Dynamic Programming ğŸ‘ 3100 ğŸ‘ 118 */ /* 2024-07-09 20:34:47 Last Stone Weight II Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (55.26%)\t3100\t118 Tags array | greedy Companies Unknown */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //leetcode submit region begin(Prohibit modification and deletion) class Solution { //dp: ä¸416.åˆ†å‰²ç­‰å’Œå­é›†åŒç±»å‹é¢˜ç›®ï¼ŒåŒå±äº01èƒŒåŒ… //æ€è·¯ï¼šå°½å¯èƒ½åˆ†æˆ2ç»„ç­‰é‡é‡çŸ³å¤´ï¼Œç›¸åŒçŸ³å¤´é‡é‡ä¼šæ’ç¢ï¼Œå‰©ä¸‹éƒ¨åˆ†å³ä¸ºæœ€åçš„é‡é‡ public int lastStoneWeightII(int[] stones) { int sum = 0; for (int i = 0; i \u0026lt; stones.length; i++) { sum += stones[i]; } int target = sum / 2; //dp[i]å®¹é‡ä¸ºiçš„èƒŒåŒ…èƒ½è£…ä¸‹æœ€å¤§ä»·å€¼çš„ç‰©å“ï¼ˆçŸ³å¤´ï¼‰ï¼Œç‰©å“é‡é‡ä¸ºstone[i],ç‰©å“ä»·å€¼value[i]ä¹Ÿä¸ºstone[i] int[] dp = new int[target + 1]; //éå†ç‰©å“ for (int i = 0; i \u0026lt; stones.length; i++) { //éå†èƒŒåŒ… for (int j = target; j \u0026gt;= stones[i]; j--) { dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]); } } //dp[target]å³ä¸ºå®¹é‡ä¸ºtargetçš„èƒŒåŒ…èƒ½è£…ä¸‹çš„æœ€å¤§ä»·å€¼çš„çŸ³å¤´ //å°†çŸ³å¤´åˆ†æˆ2å †ï¼Œä¸€å †çŸ³å¤´çš„æ€»é‡é‡æ˜¯dp[target]ï¼Œå¦ä¸€å †å°±æ˜¯sum - dp[target] //å› ä¸ºåœ¨è®¡ç®—targetæ—¶ï¼Œtarget = sum / 2å‘ä¸‹å–æ•´ï¼Œæ‰€ä»¥sum - dp[target] ä¸€å®šå¤§äºç­‰äºdp[target] //é‚£ä¹ˆç›¸æ’åï¼Œå‰©ä¸‹æœ€å°çŸ³å¤´çš„é‡é‡å°±æ˜¯(sum -dp[target]) - dp[target] return (sum - dp[target]) - dp[target]; } } //leetcode submit region end(Prohibit modification and deletion) ","date":"2024-07-09T00:00:00Z","permalink":"https://kris0325.github.io/p/1049.laststoneweight-ii/","title":"1049.LastStoneWeight II"},{"content":"äºŒå‰æ¨¹çš„éæ­·ï¼Œå¸¸è¦éæ­¸èˆ‡è¿­ä»£å¯¦ç¾ äºŒå‰æ¨¹å‰åºéæ­·\n144.binary-tree-preorder-traversal.java\näºŒå‰æ¨¹ä¸­åºéæ­·\n94.binary-tree-inorder-traversal.java\näºŒå‰æ¨¹å¾Œåºéæ­·\n145.binary-tree-postorder-traversal.java\näºŒå‰æ¨¹å‰åºéæ­· 144.binary-tree-preorder-traversal.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 /* * æ€è·¯ï¼šéæ­¸å¯¦ç¾ * ä¸­-å·¦-å³ */ class Solution1 { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { if (null == root) { return result; } result.add(root.val); preorderTraversal(root.left); preorderTraversal(root.right); return result; } } /* * æ€è·¯ï¼šè¿­ä»£å¯¦ç¾ */ class Solution { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { if (null == root) { return result; } Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); result.add(node.val); if (node.right != null) { stack.push(node.right); } if (node.left != null) { stack.push(node.left); } } return result; } } // @lc code=end äºŒå‰æ¨¹ä¸­åºéæ­· 94.binary-tree-inorder-traversal.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* * æ€è·¯ï¼šéæ­¸å¯¦ç¾ä¸­åºéæ­· * å·¦-å³-ä¸­ * * */ class Solution1 { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { if (null == root) { return result; } if (root.left != null) { inorderTraversal(root.left); } result.add(root.val); if (root.right != null) { inorderTraversal(root.right); } return result; } } /* * æ€è·¯ï¼šè¿­ä»£å¯¦ç¾ä¸­åºéæ­· * * * */ class Solution { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); TreeNode cur = root; while (cur != null || !stack.isEmpty()) { //å·¦ while (cur != null) { stack.push(cur); cur = cur.left; } //ä¸­ cur = stack.pop(); result.add(cur.val); //å³ cur = cur.right; } return result; } } äºŒå‰æ¨¹å¾Œåºéæ­· 145.binary-tree-postorder-traversal.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 /* * æ€è·¯1ï¼šé€’å½’å®ç°ååºéå† * å·¦-å³-ä¸­ */ class Solution1 { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { if (null == root) { return result; } postorderTraversal(root.left); postorderTraversal(root.right); result.add(root.val); return result; } } /* * æ€è·¯2ï¼šstacké€’å½’å®ç°ååºéå†ï¼Œä½¿ç”¨ä¸€ä¸ªé¢å¤–çš„æ ˆåè½¬èŠ‚ç‚¹ */ class Solution2 { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { if (root == null) { return result; } Stack\u0026lt;TreeNode\u0026gt; stack1 = new Stack\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack2 = new Stack\u0026lt;\u0026gt;(); stack1.push(root); while (!stack1.isEmpty()) { TreeNode node = stack1.pop(); stack2.push(node); if (node.left != null) { stack1.push(node.left); } if (node.right != null) { stack1.push(node.right); } } while (!stack2.isEmpty()) { result.add(stack2.pop().val); } return result; } } /* * æ€è·¯3ï¼šstacké€’å½’å®ç°ååºéå†ï¼Œå€Ÿé‰´å‰åºéå†çš„éæ­¸éæ­·ï¼Œç¨å¾®è°ƒæ•´ä¸‹å…¥æ ˆé¡ºåºå³å¯ * å‰åºéæ­·æ˜¯ï¼šä¸­-å·¦-å³ï¼Œå¾Œåºéæ­·æ˜¯å·¦-å³-ä¸­ï¼Œé‚£éº¼èª¿æ•´å‰åºéæ­·çš„ä»£ç¢¼é †åºï¼Œè®Šæˆä¸­-å³-å·¦ï¼Œ * ç„¶å¾Œå†åè½‰resultæ•¸çµ„ï¼Œå³å¯å¾—åˆ°å¾Œåºéæ­·çš„é †åº */ class Solution { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { if (root == null) { return result; } Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); result.add(node.val); if (root.left != null) { stack.push(root.left); } if (root.right != null) { stack.push(root.left); } } result.reversed(); return result; } } æ­¤æ—¶æˆ‘ä»¬ç”¨è¿­ä»£æ³•å†™å‡ºäº†äºŒå‰æ ‘çš„å‰åä¸­åºéå†ï¼Œå¤§å®¶å¯ä»¥çœ‹å‡ºå‰åºå’Œä¸­åºæ˜¯å®Œå…¨ä¸¤ç§ä»£ç é£æ ¼ï¼Œå¹¶ä¸åƒé€’å½’å†™æ³•é‚£æ ·ä»£ç ç¨åšè°ƒæ•´ï¼Œå°±å¯ä»¥å®ç°å‰åä¸­åºã€‚ è¿™æ˜¯å› ä¸ºå‰åºéå†ä¸­è®¿é—®èŠ‚ç‚¹ï¼ˆéå†èŠ‚ç‚¹ï¼‰å’Œå¤„ç†èŠ‚ç‚¹ï¼ˆå°†å…ƒç´ æ”¾è¿›resultæ•°ç»„ä¸­ï¼‰å¯ä»¥åŒæ­¥å¤„ç†ï¼Œä½†æ˜¯ä¸­åºå°±æ— æ³•åšåˆ°åŒæ­¥ï¼\näºŒå‰æ¨¹çš„è¿­ä»£éæ­·çµ±ä¸€å¯«æ³• åœ¨äºŒå‰æ ‘ï¼šå¬è¯´é€’å½’èƒ½åšçš„ï¼Œæ ˆä¹Ÿèƒ½åšï¼ ä¸­æåˆ°è¯´ä½¿ç”¨æ ˆçš„è¯ï¼Œæ— æ³•åŒæ—¶è§£å†³è®¿é—®èŠ‚ç‚¹ï¼ˆéå†èŠ‚ç‚¹ï¼‰å’Œå¤„ç†èŠ‚ç‚¹ï¼ˆå°†å…ƒç´ æ”¾è¿›ç»“æœé›†ï¼‰ä¸ä¸€è‡´çš„æƒ…å†µã€‚\né‚£æˆ‘ä»¬å°±å°†è®¿é—®çš„èŠ‚ç‚¹æ”¾å…¥æ ˆä¸­ï¼ŒæŠŠè¦å¤„ç†çš„èŠ‚ç‚¹ä¹Ÿæ”¾å…¥æ ˆä¸­ä½†æ˜¯è¦åšæ ‡è®°ã€‚\nå¦‚ä½•æ ‡è®°å‘¢ï¼Œå°±æ˜¯è¦å¤„ç†çš„èŠ‚ç‚¹æ”¾å…¥æ ˆä¹‹åï¼Œç´§æ¥ç€æ”¾å…¥ä¸€ä¸ªç©ºæŒ‡é’ˆä½œä¸ºæ ‡è®°ã€‚ è¿™ç§æ–¹æ³•ä¹Ÿå¯ä»¥å«åšæ ‡è®°æ³•ã€‚\nå‰åºéæ­·çš„éæ­¸å¯¦ç¾ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* * å‰åºéæ­· ä¸­-å·¦-å³ï¼ŒåŸºæ–¼æ¨™è¨˜æ³•éæ­¸å¯¦ç¾ */ class Solution { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { if (null == root) { return result; } Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.peek(); if (null != node) { stack.pop(); //å³ if (null != node.right) { stack.push(node.right); } //å·¦ if (null != node.left) { stack.push(node.left); } //ä¸­ stack.push(node); //ä¸­ç¯€é»è¨ªå•éï¼Œä½†é‚„æ²’è™•ç†ï¼ŒåŠ å…¥nullç¯€é»æ¨™è¨˜ã€‚æ¨™è¨˜ä¸Šä¸€å€‹ç¯€é»æ˜¯éœ€è¦è™•ç†çš„ç¯€é» stack.push(null); } else { //ç•¶åˆ¤æ–·pop()çš„ç¯€é»ç‚ºnull ,å‰‡å…ˆpop,å†å–ç¬¬äºŒå€‹ç¯€é»ä¾¿æ˜¯ç‚ºéœ€è¦è™•ç†ç¯€é» stack.pop(); result.add(stack.pop().val); } } return result; } } ä¸­åºéæ­·çš„éæ­¸å¯¦ç¾ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* * ä¸­åºéæ­· å·¦-ä¸­-å³ï¼ŒåŸºæ–¼æ¨™è¨˜æ³•éæ­¸å¯¦ç¾ */ class Solution { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { if (null == root) { return result; } Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.peek(); if (null != node) { stack.pop(); //å³ if (null != node.right) { stack.push(node.right); } //ä¸­ stack.push(node); //ä¸­ç¯€é»è¨ªå•éï¼Œä½†é‚„æ²’è™•ç†ï¼ŒåŠ å…¥nullç¯€é»æ¨™è¨˜ã€‚æ¨™è¨˜ä¸Šä¸€å€‹ç¯€é»æ˜¯éœ€è¦è™•ç†çš„ç¯€é» stack.push(null); //å·¦ if (null != node.left) { stack.push(node.left); } } else { //ç•¶åˆ¤æ–·pop()çš„ç¯€é»ç‚ºnull ,å‰‡å…ˆpop,å†å–ç¬¬äºŒå€‹ç¯€é»ä¾¿æ˜¯ç‚ºéœ€è¦è™•ç†ç¯€é» stack.pop(); result.add(stack.pop().val); } } return result; } } å¾Œåºéæ­·çš„éæ­¸å¯¦ç¾ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* * å¾Œåºéæ­· å·¦-å³-å³ï¼ŒåŸºæ–¼æ¨™è¨˜æ³•éæ­¸å¯¦ç¾ */ class Solution { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { if (null == root) { return result; } Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.peek(); if (null != node) { stack.pop(); //ä¸­ stack.push(node); //ä¸­ç¯€é»è¨ªå•éï¼Œä½†é‚„æ²’è™•ç†ï¼ŒåŠ å…¥nullç¯€é»æ¨™è¨˜ã€‚æ¨™è¨˜ä¸Šä¸€å€‹ç¯€é»æ˜¯éœ€è¦è™•ç†çš„ç¯€é» stack.push(null); //å³ if (null != node.right) { stack.push(node.right); } //å·¦ if (null != node.left) { stack.push(node.left); } } else { //ç•¶åˆ¤æ–·pop()çš„ç¯€é»ç‚ºnull ,å‰‡å…ˆpop,å†å–ç¬¬äºŒå€‹ç¯€é»ä¾¿æ˜¯ç‚ºéœ€è¦è™•ç†ç¯€é» stack.pop(); result.add(stack.pop().val); } } return result; } } ","date":"2024-07-07T00:00:00Z","image":"https://kris0325.github.io/p/%E4%BA%8C%E5%8F%89%E6%A8%B9%E7%9A%84%E9%81%8D%E6%AD%B7%E7%9A%84%E9%81%9E%E6%AD%B8%E5%AF%A6%E7%8F%BE%E8%88%87%E8%BF%AD%E4%BB%A3%E5%AF%A6%E7%8F%BE/BinaryTreeTraversal_hu7cf6e264dbacbb15e58f444182418964_7138799_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/%E4%BA%8C%E5%8F%89%E6%A8%B9%E7%9A%84%E9%81%8D%E6%AD%B7%E7%9A%84%E9%81%9E%E6%AD%B8%E5%AF%A6%E7%8F%BE%E8%88%87%E8%BF%AD%E4%BB%A3%E5%AF%A6%E7%8F%BE/","title":"Binary Tree Traversal"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* 2024-07-04 15:49:59 Partition Equal Subset Sum Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (46.27%)\t12200\t247 Tags dynamic-programming Companies ebay Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise. Example 1: Input: nums = [1,5,11,5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11]. Example 2: Input: nums = [1,2,3,5] Output: false Explanation: The array cannot be partitioned into equal sum subsets. Constraints: 1 \u0026lt;= nums.length \u0026lt;= 200 1 \u0026lt;= nums[i] \u0026lt;= 100 */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class PartitionEqualSubsetSum { public static void main(String[] args) { Solution solution = new PartitionEqualSubsetSum().new Solution(); } //leetcode submit region begin(Prohibit modification and deletion) class Solution { //01dp: å¥—ç”¨01èƒŒåŒ… model //ç¬¬iä¸ªå…ƒç´ ï¼ˆç‰©å“ï¼‰ é‡é‡ä¸ºnums[i] ä»·å€¼ä¹Ÿä¸ºnums[i] //èƒŒåŒ…é‡é‡ä¸º target = sum/2 //é¢˜ç›®è½¬åŒ–ä¸ºä»·å€¼ dp[j] = max(dp[j], dp[i- nums[i]] + nums[i]) public boolean canPartition(int[] nums) { int sum = 0; int n = nums.length; for (int num : nums) { sum += num; } //sumä¸ºå¥‡æ•°æ— æ³•æ‹†åˆ† if(sum %2 != 0){ return false; } int bagWeight = sum / 2; int targetValue = sum / 2; int []dp = new int[bagWeight+1]; dp[0] = 0; for(int i = 0; i \u0026lt; n; i++){ for(int j = bagWeight; j \u0026gt;= nums[i]; j--){ //èƒŒåŒ…å®¹é‡ä¸ºbagWeightï¼Œè£…ç‰©å“i, ç‰©å“içš„é‡é‡æ˜¯nums[i], ä»·å€¼ä¹Ÿæ˜¯nums[i] dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]); } //å‰ªæï¼šæ¯æ¬¡å®Œæˆå†…å±‚loopï¼Œ ç«‹å³æ£€æŸ¥å½“å‰iä¸ªå…ƒç´ å°±æ˜¯å¦å·²æ»¡è¶³æ¡ä»¶ å·²å¯»æ‰¾åˆ°å¯åˆ†å‰²çš„sunsetï¼Œ iæ— éœ€å†éå†è®¡ç®—dpäº† if(dp[bagWeight] == targetValue){ return true; } } return dp[bagWeight] == targetValue; } } //leetcode submit region end(Prohibit modification and deletion) } ","date":"2024-07-04T00:00:00Z","permalink":"https://kris0325.github.io/p/416.partitionequalsubsetsum/","title":"416.PartitionEqualSubsetSum"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 /** * You are given an integer array prices where prices[i] is the price of a given * stock on the iáµ—Ê° day. * \u0026lt;p\u0026gt; * On each day, you may decide to buy and/or sell the stock. You can only hold at * most one share of the stock at any time. However, you can buy it then * immediately sell it on the same day. * \u0026lt;p\u0026gt; * Find and return the maximum profit you can achieve. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 1: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: prices = [7,1,5,3,6,4] * Output: 7 * Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5- * 1 = 4. * Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. * Total profit is 4 + 3 = 7. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 2: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: prices = [1,2,3,4,5] * Output: 4 * Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5- * 1 = 4. * Total profit is 4. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 3: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: prices = [7,6,4,3,1] * Output: 0 * Explanation: There is no way to make a positive profit, so we never buy the * stock to achieve the maximum profit of 0. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Constraints: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * 1 \u0026lt;= prices.length \u0026lt;= 3 * 10â´ * 0 \u0026lt;= prices[i] \u0026lt;= 10â´ * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Related Topics Array Dynamic Programming Greedy ğŸ‘ 13507 ğŸ‘ 2694 */ /* 2024-07-03 17:02:18 Best Time to Buy and Sell Stock II Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (66.40%)\t13507\t2694 Tags array | greedy Companies bloomberg */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 //leetcode submit region begin(Prohibit modification and deletion) class Solution1 { //greedy algorithmï¼š åƒ¹æ ¼ä½æ™‚è²·å…¥ï¼Œåƒ¹æ ¼é«˜æ™‚è³£å‡ºï¼Œ //è¦æ±‚å±€éƒ¨æœ€å„ªè§£ï¼Œé‚£éº¼å¯ä»¥æ¯å¤©éƒ½äº¤æ˜“ï¼Œç„¶å¾Œç®—å‡ºæ¯å¤©çš„profitï¼Œprice[i] -price[i-1], åªæ”¶é›†æ­£åˆ©æ½¤å³å¯ public int maxProfit(int[] prices) { int maxProfit = 0; for (int i = 1; i \u0026lt; prices.length; i++) { //åªæ”¶é›†æ­£åˆ©æ½¤ maxProfit += Math.max(prices[i] - prices[i - 1], 0); } return maxProfit; } } class Solution { //DP algorithmï¼š åƒ¹æ ¼ä½æ™‚è²·å…¥ï¼Œåƒ¹æ ¼é«˜æ™‚è³£å‡ºï¼Œ public int maxProfit(int[] prices) { int[][] dp = new int[prices.length][2]; //dp[i][0] ç¬¬iå¤©æŒæœ‰è‚¡ç¥¨å¾Œçš„æœ€å¤šç¾é‡‘ //dp[i][1] ç¬¬iå¤©æŒæœ‰çš„æœ€å¤šç¾é‡‘(å‰ä¸€å¤©è³£æ‰è‚¡ç¥¨) //ç¬¬0å¤©è²·å…¥è‚¡ç¥¨ï¼Œé–‹å§‹ç¾é‡‘ç‚º0,é‚£éº¼è²·å…¥è‚¡ç¥¨å¾Œçš„ç¾é‡‘å°±æ˜¯-prices[0]ï¼Œæ‰€ä»¥æ˜¯ä¸€å€‹è² æ•¸ dp[0][0] = -prices[0]; int n = prices.length; for (int i = 1; i \u0026lt; n; i++) { //ç¬¬iå¤©æŒæœ‰è‚¡ç¥¨å¾Œçš„æœ€å¤šç¾é‡‘ = max(ä¿æŒç¬¬i-1å¤©çš„ç‹€æ…‹ä¸è®Š å³ç¬¬i - 1å¤©æŒæœ‰è‚¡ç¥¨å¾Œçš„æœ€å¤šç¾é‡‘, ç¬¬i-1å¤©æŒæœ‰çš„æœ€å¤šç¾é‡‘-è²·ç¬¬iå¤©è‚¡ç¥¨çš„éŒ¢ï¼‰ dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]); //ç¬¬iå¤©æŒæœ‰çš„æœ€å¤šç¾é‡‘ = max(ç¬¬i-1å¤©æŒæœ‰çš„æœ€å¤šç¾é‡‘, ç¬¬i-1å¤©æŒæœ‰è‚¡ç¥¨å¾Œçš„æœ€å¤šç¾é‡‘+è³£ç¬¬iå¤©è‚¡ç¥¨çš„éŒ¢) dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]); } return Math.max(dp[n - 1][0], dp[n - 1][1]); } } //leetcode submit region end(Prohibit modification and deletion) ","date":"2024-07-03T00:00:00Z","image":"https://kris0325.github.io/p/122.besttimetobuyandsellstock-ii/122_hub8798eeb12429cb98d0a0ed6a256661c_7673051_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/122.besttimetobuyandsellstock-ii/","title":"122.BestTimeToBuyAndSellStock II"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /** * Given an integer n, break it into the sum of k positive integers, where k \u0026gt;= 2, * and maximize the product of those integers. * \u0026lt;p\u0026gt; * Return the maximum product you can get. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 1: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: n = 2 * Output: 1 * Explanation: 2 = 1 + 1, 1 Ã— 1 = 1. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 2: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: n = 10 * Output: 36 * Explanation: 10 = 3 + 3 + 4, 3 Ã— 3 Ã— 4 = 36. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Constraints: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * 2 \u0026lt;= n \u0026lt;= 58 * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Related Topics Math Dynamic Programming ğŸ‘ 5093 ğŸ‘ 447 */ /* 2024-07-03 22:19:36 Integer Break Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (60.32%)\t5093\t447 Tags math | dynamic-programming Companies Unknown Given an integer n, break it into the sum of k positive integers, where k \u0026gt;= 2, and maximize the product of those integers. Return the maximum product you can get. */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //leetcode submit region begin(Prohibit modification and deletion) class Solution1 { //dp : æ—¶é—´å¤æ‚åº¦ 0(n2) , ç©ºé—´å¤æ‚åº¦o(n) // æ•°å­¦ç»“è®ºæ˜¯ï¼šä¸€ä¸ªæ•°n,æ‹†æˆmä¸ªæ¥è¿‘ç›¸åŒçš„æ•°ï¼Œå¯ä»¥å¾—åˆ°æœ€å¤§ä¹˜ç§¯å€¼ // å®šä¹‰dp[i]æ•°ç»„ä¸º æ•´æ•°iå¯æ‹†ä¸ºçš„æœ€å¤§çš„ä¹˜ç§¯ //ç”¨æœ€å°æ•°jå»è¯•ç€éå†i, é‚£ä¹ˆiæ‹†æˆ j * (i-j),å³å¯ä»¥ç†è§£ä¸ºæ‹†æˆ2ä¸ªæ•°j å’Œ i-j, // åŒæ—¶ä¹Ÿå¯ä»¥ç”¨dpæ•°ç»„è¡¨ç¤ºä¸º j*dp[i-j]ï¼Œ å³æœ€å°å°è¯•å•å…ƒæ•°j(æ— éœ€å†æ‹†åˆ†) å’Œå¯¹ i-jçš„æ‹†åˆ† dp[i-j] // é‚£ä¹ˆå¯å¾—åˆ°dpæ•°ç»„çš„çš„é€’æ¨å…¬å¼ dp[i] = max(dp[i], max(j * (i-j), j*dp[i-j])); // æ³¨æ„ï¼šéœ€å¯¹ ç”¨jéå†içš„å†…å±‚forå¾ªç¯å¾—åˆ°çš„å¤šä¸ªdp[i] ä¹Ÿè¿›è¡Œmaxæ¯”è¾ƒï¼Œä»è€Œæ±‚æœ€å¤§å€¼ public int integerBreak(int n) { int[] dp = new int[n + 1]; dp[2] = 1; for (int i = 3; i \u0026lt;= n; i++) { //ç”±é¢˜ç›®æ¡ä»¶å¯æ¨å‡ºï¼Œdp[0],dp[1]æ— æ³•æ‹†åˆ†ï¼Œæ²¡æœ‰å®é™…æ„ä¹‰ //dp[2] =1, é‚£ä¹ˆj = 3 - 2,æ‰€ä»¥jä»1å¼€å§‹ï¼Œç”±å‰é¢æ‹†åˆ†æœ€å¤§ä¹˜ç§¯çš„æ•°å­¦ç»“è®ºï¼Œé‚£ä¹ˆjçš„è¾¹ç•Œæ¡ä»¶å¯ä»¥ä¼˜åŒ–ä¸ºj \u0026lt; i/2 // for (int j = 1; j \u0026lt; i; j++) {} //å¯¹äºiçš„æœ€å¤§å€¼ï¼Œå†…å±‚forå¾ªç¯ä¼šå¾—å‡ºå¤šä¸ªdp[i],æ‰€ä»¥dp[i]ä¹Ÿéœ€è¦å‚ä¸å’ŒMath.max(j, dp[i - j])æ¯”è¾ƒæ¥æ±‚æœ€å€¼ for (int j = 1; j \u0026lt;= i / 2; j++) { dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j])); } } return dp[n]; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class IntegerBreak { public static void main(String[] args) { Solution solution = new IntegerBreak().new Solution(); } class Solution { // æ•°å­¦ç»“è®ºæ˜¯ï¼šä¸€ä¸ªæ•°n,æ‹†æˆmä¸ªæ¥è¿‘ç›¸åŒçš„æ•°ï¼Œå¯ä»¥å¾—åˆ°æœ€å¤§ä¹˜ç§¯å€¼ // greedy algorithm: æ—¶é—´å¤æ‚åº¦ 0(n) , ç©ºé—´å¤æ‚åº¦o(1) // æ ¹æ®ä¸Šé¢æ•°å­¦ç»“è®º å±€éƒ¨ä»¥10ä¸ºä¾‹å­ï¼Œ334ä¸ºæœ€å¤§ï¼Œ // é‚£ä¹ˆå±€éƒ¨æœ€ä¼˜æ¨å¯¼æ•´ä½“æœ€ä¼˜ï¼Œ å¯¹æ•´æ•°n åˆ™æŒ‰ç…§æ¯æ¬¡æ‹†æˆmä¸ª3ï¼Œå¦‚æœå‰©ä¸‹çš„ä¸º4ï¼Œåˆ™ä¿ç•™4ï¼Œç„¶åç›¸ä¹˜ public int integerBreak(int n) { if (n == 2) { return 1; } if (n == 3) { return 2; } int maxProduct = 1; while (n \u0026gt; 4) { maxProduct *= 3; n -= 3; } maxProduct *= n; return maxProduct; } } //leetcode submit region end(Prohibit modification and deletion) } ","date":"2024-07-03T00:00:00Z","permalink":"https://kris0325.github.io/p/343.-integerbreak/","title":"343.IntegerBreak"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /** * Given an integer n, return the number of structurally unique BST\u0026#39;s (binary * search trees) which has exactly n nodes of unique values from 1 to n. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 1: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: n = 3 * Output: 5 * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 2: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: n = 1 * Output: 1 * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Constraints: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * 1 \u0026lt;= n \u0026lt;= 19 * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Related Topics Math Dynamic Programming Tree Binary Search Tree Binary Tree ğŸ‘ * 10311 ğŸ‘ 403 */ /* 2024-07-03 23:45:03 Unique Binary Search Trees Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (61.00%)\t10311\t403 Tags dynamic-programming | tree Companies snapchat Given an integer n, return the number of structurally unique BST\u0026#39;s (binary search trees) which has exactly n nodes of unique values from 1 to n. */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 //leetcode submit region begin(Prohibit modification and deletion) class Solution { // dp : //1.ç¡®å®šdpæ•°ç»„ï¼ˆdp tableï¼‰ä»¥åŠä¸‹æ ‡çš„å«ä¹‰ //dp[i] ï¼š 1åˆ°iä¸ºèŠ‚ç‚¹ç»„æˆçš„äºŒå‰æœç´¢æ ‘çš„ä¸ªæ•°ä¸ºdp[i]ã€‚ //ç”»å›¾åˆ†æä»¥æ¯ä¸ªjä¸ºæ ¹èŠ‚ç‚¹rootï¼Œå¯ä»¥ç”»å‡ºå¤šå°‘ç§BST // ç”»å›¾ n = 1, 2, 3çš„æƒ…å†µï¼Œæ‰¾è§„å¾‹ï¼Œåˆ†æé€’æ¨å…³ç³», //2.ç¡®å®šé€’æ¨å…¬å¼ //åœ¨ä¸Šé¢çš„åˆ†æä¸­ï¼Œå…¶å®å·²ç»çœ‹å‡ºå…¶é€’æ¨å…³ç³»ï¼Œ dp[i] += dp[ä»¥jä¸ºå¤´èŠ‚ç‚¹å·¦å­æ ‘èŠ‚ç‚¹çš„æœç´ æ ‘æ•°é‡] * dp[ä»¥jä¸ºå¤´èŠ‚ç‚¹å³å­æ ‘èŠ‚ç‚¹çš„æœç´ æ ‘æ•°é‡] //æ•´ä¸ªæ ‘ æ˜¯ å·¦å³å­æ ‘çš„ä¸åŒç»„åˆï¼Œæ‰€ä»¥æ˜¯å·¦å­æ ‘çš„ç»„åˆæ•°é‡ * å³å­æ ‘çš„ç»„åˆæ•°é‡ //j ç›¸å½“äºå¤´èŠ‚ç‚¹çš„å…ƒç´ ï¼Œjæ˜¯ä»1éå†åˆ°iä¸ºæ­¢ //i æ˜¯ä»å‰åˆ°åéå†åˆ°n, æ‰€ä»¥æ±‚dp[n] éœ€è¦ç´¯åŠ dp[i] //æ‰€ä»¥é€’æ¨å…¬å¼ï¼šdp[i] += dp[j-1] * dp[i-j] //3.åˆå§‹åŒ– //dp[0]=1 (å‡è®¾ç©ºæ ‘case), dp[1] =1 public int numTrees(int n) { int[] dp = new int[n + 1]; dp[0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= i; j++) { //å¯¹äºç¬¬iä¸ªèŠ‚ç‚¹ï¼Œéœ€è¦è€ƒè™‘1ä½œä¸ºæ ¹èŠ‚ç‚¹ç›´åˆ°iä½œä¸ºæ ¹èŠ‚ç‚¹çš„æƒ…å†µï¼Œæ‰€ä»¥éœ€è¦ç´¯åŠ  dp[i] += dp[j-1] * dp[i - j]; } } return dp[n]; } } //leetcode submit region end(Prohibit modification and deletion) ","date":"2024-07-03T00:00:00Z","permalink":"https://kris0325.github.io/p/96.uniquebinarysearchtrees/","title":"96.UniqueBinarySearchTrees"},{"content":" # ä»€ä¹ˆæ˜¯åŠ¨æ€è§„åˆ’ åŠ¨æ€è§„åˆ’ï¼Œè‹±æ–‡ï¼šDynamic Programmingï¼Œç®€ç§°DPï¼Œå¦‚æœæŸä¸€é—®é¢˜æœ‰å¾ˆå¤šé‡å å­é—®é¢˜ï¼Œä½¿ç”¨åŠ¨æ€è§„åˆ’æ˜¯æœ€æœ‰æ•ˆçš„ã€‚ æ‰€ä»¥åŠ¨æ€è§„åˆ’ä¸­æ¯ä¸€ä¸ªçŠ¶æ€ä¸€å®šæ˜¯ç”±ä¸Šä¸€ä¸ªçŠ¶æ€æ¨å¯¼å‡ºæ¥çš„ï¼Œè¿™ä¸€ç‚¹å°±åŒºåˆ†äºè´ªå¿ƒï¼Œè´ªå¿ƒæ²¡æœ‰çŠ¶æ€æ¨å¯¼ï¼Œè€Œæ˜¯ä»å±€éƒ¨ç›´æ¥é€‰æœ€ä¼˜çš„ï¼Œ\nåŠ¨æ€è§„åˆ’çš„è§£é¢˜æ­¥éª¤ åšåŠ¨è§„é¢˜ç›®çš„æ—¶å€™ï¼Œå¾ˆå¤šåŒå­¦ä¼šé™·å…¥ä¸€ä¸ªè¯¯åŒºï¼Œå°±æ˜¯ä»¥ä¸ºæŠŠçŠ¶æ€è½¬ç§»å…¬å¼èƒŒä¸‹æ¥ï¼Œç…§è‘«èŠ¦ç”»ç“¢æ”¹æ”¹ï¼Œå°±å¼€å§‹å†™ä»£ç ï¼Œç”šè‡³æŠŠé¢˜ç›®ACä¹‹åï¼Œéƒ½ä¸å¤ªæ¸…æ¥šdp[i]è¡¨ç¤ºçš„æ˜¯ä»€ä¹ˆã€‚\nè¿™å°±æ˜¯ä¸€ç§æœ¦èƒ§çš„çŠ¶æ€ï¼Œç„¶åå°±æŠŠé¢˜ç»™è¿‡äº†ï¼Œé‡åˆ°ç¨ç¨éš¾ä¸€ç‚¹çš„ï¼Œå¯èƒ½ç›´æ¥å°±ä¸ä¼šäº†ï¼Œç„¶åçœ‹é¢˜è§£ï¼Œç„¶åç»§ç»­ç…§è‘«èŠ¦ç”»ç“¢é™·å…¥è¿™ç§æ¶æ€§å¾ªç¯ä¸­ã€‚\nçŠ¶æ€è½¬ç§»å…¬å¼ï¼ˆé€’æ¨å…¬å¼ï¼‰æ˜¯å¾ˆé‡è¦ï¼Œä½†åŠ¨è§„ä¸ä»…ä»…åªæœ‰é€’æ¨å…¬å¼ã€‚\nå¯¹äºåŠ¨æ€è§„åˆ’é—®é¢˜ï¼Œæˆ‘å°†æ‹†è§£ä¸ºå¦‚ä¸‹äº”æ­¥æ›²ï¼Œè¿™äº”æ­¥éƒ½ææ¸…æ¥šäº†ï¼Œæ‰èƒ½è¯´æŠŠåŠ¨æ€è§„åˆ’çœŸçš„æŒæ¡äº†ï¼\n1. ç¡®å®šdpæ•°ç»„ï¼ˆdp tableï¼‰ä»¥åŠä¸‹æ ‡çš„å«ä¹‰\n2. ç¡®å®šé€’æ¨å…¬å¼\n3. dpæ•°ç»„å¦‚ä½•åˆå§‹åŒ–\n4. ç¡®å®šéå†é¡ºåº\n5. ä¸¾ä¾‹æ¨å¯¼dpæ•°ç»„\nä¸€äº›åŒå­¦å¯èƒ½æƒ³ä¸ºä»€ä¹ˆè¦å…ˆç¡®å®šé€’æ¨å…¬å¼ï¼Œç„¶ååœ¨è€ƒè™‘åˆå§‹åŒ–å‘¢ï¼Ÿ\nå› ä¸ºä¸€äº›æƒ…å†µæ˜¯é€’æ¨å…¬å¼å†³å®šäº†dpæ•°ç»„è¦å¦‚ä½•åˆå§‹åŒ–ï¼\nåé¢çš„è®²è§£ä¸­æˆ‘éƒ½æ˜¯å›´ç»•ç€è¿™äº”ç‚¹æ¥è¿›è¡Œè®²è§£ã€‚\nå¯èƒ½åˆ·è¿‡åŠ¨æ€è§„åˆ’é¢˜ç›®çš„åŒå­¦å¯èƒ½éƒ½çŸ¥é“é€’æ¨å…¬å¼çš„é‡è¦æ€§ï¼Œæ„Ÿè§‰ç¡®å®šäº†é€’æ¨å…¬å¼è¿™é“é¢˜ç›®å°±è§£å‡ºæ¥äº†ã€‚\nå…¶å® ç¡®å®šé€’æ¨å…¬å¼ ä»…ä»…æ˜¯è§£é¢˜é‡Œçš„ä¸€æ­¥è€Œå·²ï¼\nä¸€äº›åŒå­¦çŸ¥é“é€’æ¨å…¬å¼ï¼Œä½†æä¸æ¸…æ¥šdpæ•°ç»„åº”è¯¥å¦‚ä½•åˆå§‹åŒ–ï¼Œæˆ–è€…æ­£ç¡®çš„éå†é¡ºåºï¼Œä»¥è‡³äºè®°ä¸‹æ¥å…¬å¼ï¼Œä½†å†™çš„ç¨‹åºæ€ä¹ˆæ”¹éƒ½é€šè¿‡ä¸äº†ã€‚\nååºçš„è®²è§£çš„å¤§å®¶å°±ä¼šæ…¢æ…¢æ„Ÿå—åˆ°è¿™äº”æ­¥çš„é‡è¦æ€§äº†ã€‚\nåŠ¨æ€è§„åˆ’åº”è¯¥å¦‚ä½•debug ç›¸ä¿¡åŠ¨è§„çš„é¢˜ç›®ï¼Œå¾ˆå¤§éƒ¨åˆ†åŒå­¦éƒ½æ˜¯è¿™æ ·åšçš„ã€‚\nçœ‹ä¸€ä¸‹é¢˜è§£ï¼Œæ„Ÿè§‰çœ‹æ‡‚äº†ï¼Œç„¶åç…§è‘«èŠ¦ç”»ç“¢ï¼Œå¦‚æœèƒ½æ­£å¥½ç”»å¯¹äº†ï¼Œä¸‡äº‹å¤§å‰ï¼Œä¸€æ—¦è¦æ˜¯æ²¡é€šè¿‡ï¼Œå°±æ€ä¹ˆæ”¹éƒ½é€šè¿‡ä¸äº†ï¼Œå¯¹ dpæ•°ç»„çš„åˆå§‹åŒ–ï¼Œé€’æ¨å…¬å¼ï¼Œéå†é¡ºåºï¼Œå¤„äºä¸€ç§é»‘ç›’çš„ç†è§£çŠ¶æ€ã€‚\nå†™åŠ¨è§„é¢˜ç›®ï¼Œä»£ç å‡ºé—®é¢˜å¾ˆæ­£å¸¸ï¼\næ‰¾é—®é¢˜çš„æœ€å¥½æ–¹å¼å°±æ˜¯æŠŠdpæ•°ç»„æ‰“å°å‡ºæ¥ï¼Œçœ‹çœ‹ç©¶ç«Ÿæ˜¯ä¸æ˜¯æŒ‰ç…§è‡ªå·±æ€è·¯æ¨å¯¼çš„ï¼\nDP Questions List 509.fibonacci-number æ–æ³¢é‚£å¥‘æ•¸åˆ—\n70. Climbing Stairs 70. çˆ¬æ¥¼æ¢¯\n746. Min Cost Climbing Stairs 746.ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯\n62. Unique Paths ä¸åŒè·¯å¾‘ 63. Unique Paths II ä¸åŒè·¯å¾‘II 343.IntegerBreak 343. æ•´æ•°æ‹†åˆ†\n96.UniqueBinarySearchTrees 96.ä¸åŒçš„äºŒå‰æœç´¢æ ‘\n416.PartitionEqualSubsetSum 416. åˆ†å‰²ç­‰å’Œå­é›†\n1049.LastStoneWeight II 1049.æœ€åä¸€å—çŸ³å¤´çš„é‡é‡II\n494. TargetSum 494. ç›®æ ‡å’Œ\n213.HouseRobberII 213.æ‰“å®¶åŠ«èˆII\n198.HouseRobber 198.æ‰“å®¶åŠ«èˆ\n121.BestTimeToBuyAndSellStock 121.è²·è³£è‚¡ç¥¨çš„æœ€ä½³æ™‚æ©Ÿ\n122.BestTimeToBuyAndSellStockII 122.è²·è³£è‚¡ç¥¨çš„æœ€ä½³æ™‚æ©ŸII\n","date":"2024-07-03T00:00:00Z","image":"https://kris0325.github.io/p/dynamic-programming/dynamicProgramming_huef16b088f6663f16aad49f65a4302927_8860844_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/dynamic-programming/","title":"dynamic programming"},{"content":" ä»€ä¹ˆæ˜¯è´ªå¿ƒ è´ªå¿ƒçš„æœ¬è´¨æ˜¯é€‰æ‹©æ¯ä¸€é˜¶æ®µçš„å±€éƒ¨æœ€ä¼˜ï¼Œä»è€Œè¾¾åˆ°å…¨å±€æœ€ä¼˜ã€‚\nè´ªå¿ƒçš„å¥—è·¯ï¼ˆä»€ä¹ˆæ—¶å€™ç”¨è´ªå¿ƒï¼‰ å¾ˆå¤šåŒå­¦åšè´ªå¿ƒçš„é¢˜ç›®çš„æ—¶å€™ï¼Œæƒ³ä¸å‡ºæ¥æ˜¯è´ªå¿ƒï¼Œæƒ³çŸ¥é“æœ‰æ²¡æœ‰ä»€ä¹ˆå¥—è·¯å¯ä»¥ä¸€çœ‹å°±çœ‹å‡ºæ¥æ˜¯è´ªå¿ƒã€‚\nè¯´å®è¯è´ªå¿ƒç®—æ³•å¹¶æ²¡æœ‰å›ºå®šçš„å¥—è·¯ã€‚\næ‰€ä»¥å”¯ä¸€çš„éš¾ç‚¹å°±æ˜¯å¦‚ä½•é€šè¿‡å±€éƒ¨æœ€ä¼˜ï¼Œæ¨å‡ºæ•´ä½“æœ€ä¼˜ã€‚\né‚£ä¹ˆå¦‚ä½•èƒ½çœ‹å‡ºå±€éƒ¨æœ€ä¼˜æ˜¯å¦èƒ½æ¨å‡ºæ•´ä½“æœ€ä¼˜å‘¢ï¼Ÿæœ‰æ²¡æœ‰ä»€ä¹ˆå›ºå®šç­–ç•¥æˆ–è€…å¥—è·¯å‘¢ï¼Ÿ\nä¸å¥½æ„æ€ï¼Œä¹Ÿæ²¡æœ‰ï¼ é è‡ªå·±æ‰‹åŠ¨æ¨¡æ‹Ÿï¼Œå¦‚æœæ¨¡æ‹Ÿå¯è¡Œï¼Œå°±å¯ä»¥è¯•ä¸€è¯•è´ªå¿ƒç­–ç•¥ï¼Œå¦‚æœä¸å¯è¡Œï¼Œå¯èƒ½éœ€è¦åŠ¨æ€è§„åˆ’ã€‚\næœ‰åŒå­¦é—®äº†å¦‚ä½•éªŒè¯å¯ä¸å¯ä»¥ç”¨è´ªå¿ƒç®—æ³•å‘¢ï¼Ÿ\næœ€å¥½ç”¨çš„ç­–ç•¥å°±æ˜¯ä¸¾åä¾‹ï¼Œå¦‚æœæƒ³ä¸åˆ°åä¾‹ï¼Œé‚£ä¹ˆå°±è¯•ä¸€è¯•è´ªå¿ƒå§ã€‚\næ‰‹åŠ¨æ¨¡æ‹Ÿä¸€ä¸‹æ„Ÿè§‰å¯ä»¥å±€éƒ¨æœ€ä¼˜æ¨å‡ºæ•´ä½“æœ€ä¼˜ï¼Œè€Œä¸”æƒ³ä¸åˆ°åä¾‹ï¼Œé‚£ä¹ˆå°±è¯•ä¸€è¯•è´ªå¿ƒã€‚\nè´ªå¿ƒä¸€èˆ¬è§£é¢˜æ­¥éª¤ è´ªå¿ƒç®—æ³•ä¸€èˆ¬åˆ†ä¸ºå¦‚ä¸‹å››æ­¥ï¼š\n1. å°†é—®é¢˜åˆ†è§£ä¸ºè‹¥å¹²ä¸ªå­é—®é¢˜\n2. æ‰¾å‡ºé€‚åˆçš„è´ªå¿ƒç­–ç•¥\n3. æ±‚è§£æ¯ä¸€ä¸ªå­é—®é¢˜çš„æœ€ä¼˜è§£\n4. å°†å±€éƒ¨æœ€ä¼˜è§£å †å æˆå…¨å±€æœ€ä¼˜è§£\nè¿™ä¸ªå››æ­¥å…¶å®è¿‡äºç†è®ºåŒ–äº†ï¼Œæˆ‘ä»¬å¹³æ—¶åœ¨åšè´ªå¿ƒç±»çš„é¢˜ç›® å¾ˆéš¾å»æŒ‰ç…§è¿™å››æ­¥å»æ€è€ƒï¼ŒçœŸæ˜¯æœ‰ç‚¹â€œé¸¡è‚‹â€ã€‚\nåšé¢˜çš„æ—¶å€™ï¼Œåªè¦æƒ³æ¸…æ¥š å±€éƒ¨æœ€ä¼˜ æ˜¯ä»€ä¹ˆï¼Œå¦‚æœæ¨å¯¼å‡ºå…¨å±€æœ€ä¼˜ï¼Œå…¶å®å°±å¤Ÿäº†ã€‚\næ€»ç»“ æœ¬ç¯‡ç»™å‡ºäº†ä»€ä¹ˆæ˜¯è´ªå¿ƒä»¥åŠå¤§å®¶å…³å¿ƒçš„è´ªå¿ƒç®—æ³•å›ºå®šå¥—è·¯ã€‚\nä¸å¥½æ„æ€äº†ï¼Œè´ªå¿ƒæ²¡æœ‰å¥—è·¯ï¼Œè¯´ç™½äº†å°±æ˜¯å¸¸è¯†æ€§æ¨å¯¼åŠ ä¸Šä¸¾åä¾‹ã€‚\næœ€åç»™å‡ºè´ªå¿ƒçš„ä¸€èˆ¬è§£é¢˜æ­¥éª¤ï¼Œå¤§å®¶å¯ä»¥å‘ç°è¿™ä¸ªè§£é¢˜æ­¥éª¤ä¹Ÿæ˜¯æ¯”è¾ƒæŠ½è±¡çš„ï¼Œä¸åƒæ˜¯äºŒå‰æ ‘ï¼Œå›æº¯ç®—æ³•ï¼Œç»™å‡ºäº†é‚£ä¹ˆå…·ä½“çš„è§£é¢˜å¥—è·¯å’Œæ¨¡æ¿ã€‚\n","date":"2024-07-03T00:00:00Z","image":"https://kris0325.github.io/p/greedy-algorithm/greedy_huf17606b724e43b217f3a4ea57cac8886_13293263_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/greedy-algorithm/","title":"greedy algorithm"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 Find Mode in Binary Search Tree Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (56.06%)\t3878\t782 Tags tree Companies google Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it. If the tree has more than one mode, return them in any order. Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than or equal to the node\u0026#39;s key. The right subtree of a node contains only nodes with keys greater than or equal to the node\u0026#39;s key. Both the left and right subtrees must also be binary search trees. Example 1: Input: root = [1,null,2,2] Output: [2] Example 2: Input: root = [0] Output: [0] Constraints: The number of nodes in the tree is in the range [1, 104]. -105 \u0026lt;= Node.val \u0026lt;= 105 Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution1 { //1. tree to Hashmap \u0026lt;node.val, frequent\u0026gt; hashmap //2. sort hashmap by frequent, get max //3.traverse hashmap to collect node.vals by max HashMap\u0026lt;Integer, Integer\u0026gt; val2frequent = new HashMap\u0026lt;\u0026gt;(); public int[] findMode(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); inorderTraverse(root); List\u0026lt;Integer\u0026gt;frequentList = new ArrayList\u0026lt;\u0026gt;(); for(Integer frequent :val2frequent.values()){ frequentList.add(frequent); } Integer max = frequentList.stream().max(Integer::compareTo).get(); for(Map.Entry\u0026lt;Integer, Integer\u0026gt; entry: val2frequent.entrySet()){ if(entry.getValue() == max){ result.add(entry.getKey()); } } return result.stream().mapToInt(Integer::intValue).toArray(); } public void inorderTraverse(TreeNode root){ if(null == root){ return; } inorderTraverse(root.left); val2frequent.put(root.val, val2frequent.getOrDefault(root.val,0)+1); inorderTraverse(root.right); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { // inorder traverse tree, and count frequent TreeNode pre = null; int maxfrequent = 0; int currentfrequent = 0; List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public int[] findMode(TreeNode root) { inorder(root); return result.stream().mapToInt(Integer::intValue).toArray(); } public void inorder(TreeNode root){ if(null == root){ return; } inorder(root.left); //ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ if(pre == null ){ currentfrequent = 1; } else if(pre.val == root.val) { //ä¸å‰ä¸€ä¸ªèŠ‚ç‚¹å€¼ç›¸åŒ currentfrequent++; } else { //ä¸å‰ä¸€ä¸ªèŠ‚ç‚¹å€¼ä¸ç›¸åŒçš„æ–°èŠ‚ç‚¹ currentfrequent = 1; } if(currentfrequent \u0026gt; maxfrequent){ //æ›´æ–° result.clear(); result.add(root.val); maxfrequent = currentfrequent; } else if(currentfrequent == maxfrequent){ //æ·»åŠ  result.add(root.val); } //æ›´æ–°preèŠ‚ç‚¹ pre = root; inorder(root.right); } } ","date":"2024-06-24T00:00:00Z","image":"https://kris0325.github.io/p/501.find-mode-in-binary-search-tree.java/501_hu11dc35441c190efdf181813b27f857eb_5072802_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/501.find-mode-in-binary-search-tree.java/","title":"501.find-mode-in-binary-search-tree.java"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 Construct Binary Tree from Preorder and Inorder Traversal Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (63.84%)\t14871\t503 Tags array | tree | depth-first-search Companies bloomberg Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree. Example 1: Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] Output: [3,9,20,null,null,15,7] Example 2: Input: preorder = [-1], inorder = [-1] Output: [-1] Constraints: 1 \u0026lt;= preorder.length \u0026lt;= 3000 inorder.length == preorder.length -3000 \u0026lt;= preorder[i], inorder[i] \u0026lt;= 3000 preorder and inorder consist of unique values. Each value of inorder also appears in preorder. preorder is guaranteed to be the preorder traversal of the tree. inorder is guaranteed to be the inorder traversal of the tree. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { return buildTreeHelp(preorder, 0, preorder.length , inorder, 0, inorder.length); } public TreeNode buildTreeHelp(int[] preorder, int preorderBegin, int preorderEnd , int[] inorder , int inorderBegin, int inorderEnd){ //edge case if(preorderBegin - preorderEnd == 0){ return null; } //1.rootVal int rootVal = preorder[preorderBegin]; TreeNode root = new TreeNode(rootVal); //edge case if(preorder.length ==1){ return root; } //2.get splitIndex by rootVal int splitIndex; for(splitIndex = inorderBegin; splitIndex\u0026lt; inorderEnd; splitIndex++){ if(inorder[splitIndex] == rootVal){ break; } } //3.split inorder to left and right int inorderLeftBegin = inorderBegin; int inorderLeftEnd = splitIndex; int inorderRightBegin = splitIndex+1; int inorderRightEnd = inorderEnd; //3.split preorder to left and right int preorderLeftBegin = preorderBegin+1; int preorderLeftEnd = preorderLeftBegin + (inorderLeftEnd - inorderLeftBegin); int preorderRightBegin = preorderLeftEnd; int preorderRightEnd = preorderEnd; //4. recursive traverse left and right root.left = buildTreeHelp(preorder, preorderLeftBegin, preorderLeftEnd , inorder, inorderLeftBegin, inorderLeftEnd); root.right = buildTreeHelp(preorder, preorderRightBegin, preorderRightEnd , inorder, inorderRightBegin, inorderRightEnd); //5. return root return root; } } ","date":"2024-06-23T00:00:00Z","permalink":"https://kris0325.github.io/p/105.construct-binary-tree-from-preorder-and-inorder-traversal.java/","title":"105.construct-binary-tree-from-preorder-and-inorder-traversal.java"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 Construct Binary Tree from Inorder and Postorder Traversal Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (62.77%)\t7967\t130 Tags array | tree | depth-first-search Companies microsoft Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree. Example 1: Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3] Output: [3,9,20,null,null,15,7] Example 2: Input: inorder = [-1], postorder = [-1] Output: [-1] Constraints: 1 \u0026lt;= inorder.length \u0026lt;= 3000 postorder.length == inorder.length -3000 \u0026lt;= inorder[i], postorder[i] \u0026lt;= 3000 inorder and postorder consist of unique values. Each value of postorder also appears in inorder. inorder is guaranteed to be the inorder traversal of the tree. postorder is guaranteed to be the postorder traversal of the tree. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Solution1 { // recursive //1.rootval == postorder[postorder.length-1] , constractor Root node //2.splite indorder into left array and right array by rootval //3.splite postorder into left array and right array by indorder left array //4.recursive root.left = buildTree( indorder left and postorder left), //root.left = buildTree( indorder right and postorder right) //5. return root public TreeNode buildTree(int[] inorder, int[] postorder) { //edge case æ³¨æ„å¤„ç†é€’å½’è°ƒç”¨ä¸­çš„è¾¹ç•Œæ¡ä»¶ if(0 == inorder.length || postorder.length == 0){ return null; } //1.rootval int rootVal = postorder[postorder.length-1]; TreeNode root = new TreeNode(rootVal); if(inorder.length == 1){ return root; } //2.splite indorder into left array and right array by rootval int spliteIndex; for(spliteIndex = 0; spliteIndex \u0026lt; inorder.length; spliteIndex++){ if(inorder[spliteIndex] == rootVal){ break; } } int[] indorderLeft = IntStream.range(0, spliteIndex) .map(i -\u0026gt; inorder[i]) .toArray(); int[] indorderRight = IntStream.range(spliteIndex+1, inorder.length) .map(i -\u0026gt; inorder[i]) .toArray(); //3.splite postorder into left array and right array by indorder left array int[] postorderLeft = IntStream.range(0, spliteIndex) .map(i -\u0026gt; postorder[i]) .toArray(); int[] postorderRight = IntStream.range(spliteIndex, postorder.length-1) .map(i -\u0026gt; postorder[i]) .toArray(); //4.recursive root.left = buildTree( indorder left and postorder left), //root.left = buildTree( indorder right and postorder right) root.left = buildTree(indorderLeft, postorderLeft); root.right = buildTree(indorderRight, postorderRight); //5. return root return root; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class Solution { // solution2: ä¼˜åŒ–æ—¶é—´ã€ç©ºé—´å¤æ‚åº¦ï¼Œä¸éœ€è¦new array, ç›´æ¥ä½¿ç”¨æ•°ç»„ä¸‹æ ‡indexæ“ä½œ // recursive //1.rootval == postorder[postorder.length-1] , constractor Root node //2.splite indorder into left array and right array by rootval //3.splite postorder into left array and right array by indorder left array //4.recursive root.left = buildTree( indorder left and postorder left), //root.left = buildTree( indorder right and postorder right) //5. return root public TreeNode buildTree(int[] inorder, int[] postorder) { if(inorder.length ==0 || postorder.length ==0){ return null; } return buildTreeRecursive(inorder, 0, inorder.length , postorder, 0, postorder.length); } public TreeNode buildTreeRecursive(int[] inorder, int inorderBegin,int inorderEnd ,int[] postorder, int postorderBegin,int postorderEnd){ if(inorderEnd - inorderBegin == 0){ return null; } int rootVal = postorder[postorderEnd-1]; TreeNode root = new TreeNode(rootVal); if(inorderEnd - inorderBegin == 1){ return root; } int spliteIndex; for(spliteIndex =inorderBegin; spliteIndex \u0026lt;inorderEnd; spliteIndex++){ if(rootVal == inorder[spliteIndex]){ break; } } //split inorder å·¦å¼€å³é—­ int inorderLeftBegin = inorderBegin; int inorderLeftEnd = spliteIndex; //jump rootVal == inorder[spliteIndex] int inorderRightBegin = spliteIndex+1; int inorderRightEnd = inorderEnd; //split postorder å·¦å¼€å³é—­ int postorderLeftBegin = postorderBegin; //ç»ˆæ­¢ä½ç½®æ˜¯ éœ€è¦ postorderBegin åŠ ä¸Š ä¸­åºåŒºé—´çš„å¤§å°sizeï¼Œå³åŠ ä¸Šå·¦å­æ ‘çš„èŠ‚ç‚¹ä¸ªæ•° int postorderLeftEnd = postorderBegin + (spliteIndex - inorderBegin); //ä¸èƒ½ç”¨ç›´æ¥ä½¿ç”¨spliteIndex, å› ä¸ºspliteIndexæ˜¯inorderçš„ç´¢å¼•ä¸‹æ ‡ï¼Œä¸èƒ½ç›´æ¥ç”¨äºpostorderï¼Œ //å¿…é¡»ä½¿ç”¨å·¦å­æ ‘èŠ‚ç‚¹ä¸ªæ•°ï¼ˆäºŒè€…å·¦å­æ ‘èŠ‚ç‚¹ä¸ªæ•°ç›¸åŒï¼‰ // int postorderLeftEnd = spliteIndex; int postorderRightBegin = postorderLeftEnd; //jump rootVal int postorderRightEnd = postorderEnd-1; root.left = buildTreeRecursive(inorder, inorderLeftBegin, inorderLeftEnd ,postorder, postorderLeftBegin,postorderLeftEnd); root.right = buildTreeRecursive(inorder, inorderRightBegin, inorderRightEnd , postorder, postorderRightBegin, postorderRightEnd); return root; } } ","date":"2024-06-23T00:00:00Z","permalink":"https://kris0325.github.io/p/106.construct-binary-tree-from-inorder-and-postorder-traversal.java/","title":"106.construct-binary-tree-from-inorder-and-postorder-traversal.java"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 Convert Sorted Array to Binary Search Tree Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (71.65%)\t10921\t556 Tags tree | depth-first-search Companies airbnb Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree. Example 1: Input: nums = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5] Explanation: [0,-10,5,null,-3,null,9] is also accepted: Example 2: Input: nums = [1,3] Output: [3,1] Explanation: [1,null,3] and [3,1] are both height-balanced BSTs. Constraints: 1 \u0026lt;= nums.length \u0026lt;= 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums is sorted in a strictly increasing order. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { // äºŒåˆ†æ³•ï¼Œè·å–æœ‰åºæ•°ç»„ä¸­é—´èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹ï¼Œä»¥ä¸­é—´èŠ‚ç‚¹ä½œä¸ºåˆ‡å‰²ç‚¹ï¼Œç„¶åå†é€’å½’å·¦æ•°ç»„ï¼Œå³æ•°ç»„ public TreeNode sortedArrayToBST(int[] nums) { return sortedArrayToBST(nums, 0, nums.length - 1); } public TreeNode sortedArrayToBST(int[] nums, int left, int right) { if (left \u0026gt; right) return null; int mid = left + (right - left) / 2; TreeNode current = new TreeNode(nums[mid]); current.left = sortedArrayToBST(nums, left, mid - 1); current.right = sortedArrayToBST(nums, mid + 1, right); return current; } } ","date":"2024-06-23T00:00:00Z","permalink":"https://kris0325.github.io/p/108.convert-sorted-array-to-binary-search-tree.java/","title":"108.convert-sorted-array-to-binary-search-tree.java"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 Path Sum Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (50.33%)\t9628\t1101 Tags tree | depth-first-search Companies microsoft Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children. Example 1: Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 Output: true Explanation: The root-to-leaf path with the target sum is shown. Example 2: Input: root = [1,2,3], targetSum = 5 Output: false Explanation: There two root-to-leaf paths in the tree: (1 --\u0026gt; 2): The sum is 3. (1 --\u0026gt; 3): The sum is 4. There is no root-to-leaf path with sum = 5. Example 3: Input: root = [], targetSum = 0 Output: false Explanation: Since the tree is empty, there are no root-to-leaf paths. Constraints: The number of nodes in the tree is in the range [0, 5000]. -1000 \u0026lt;= Node.val \u0026lt;= 1000 -1000 \u0026lt;= targetSum \u0026lt;= 1000 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution{ public boolean hasPathSum(TreeNode root, int targetSum) { //Leaf node , current path is not we want , then return if(null == root){ return false; } //assert child node is the need path if(root.left == null \u0026amp;\u0026amp; root.right == null \u0026amp;\u0026amp; targetSum == root.val ){ return true; } return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution1 { //solution1: recursive traverse root Integer pathVal =0; public boolean hasPathSum(TreeNode root, int targetSum) { if(null == root){ return false; } return backtracking(root,0,targetSum); } public boolean backtracking(TreeNode node, int pathVal, int targetSum){ //åœ¨é€’å½’è°ƒç”¨ä¸­ï¼Œé€šè¿‡é€»è¾‘æˆ– (||) æ“ä½œç¬¦ç»„åˆè¿”å›å€¼çš„åŸå› æ˜¯ï¼Œ //é€»è¾‘æˆ–è¿ç®—çš„ç‰¹æ€§ä½¿å¾—åªè¦ä»»æ„ä¸€ä¸ªæ“ä½œæ•°ä¸º trueï¼Œæ•´ä¸ªè¡¨è¾¾å¼çš„å€¼å°±ä¸º trueã€‚å…·ä½“æ¥è¯´ï¼Œ //A || B åªæœ‰åœ¨ A å’Œ B éƒ½ä¸º false æ—¶æ‰è¿”å› falseï¼Œå¦åˆ™è¿”å› trueã€‚ /* *å½“é€’å½’è°ƒç”¨è¿”å› false æ—¶ï¼Œè¿™ä»…æ„å‘³ç€å½“å‰è·¯å¾„ä¸æ»¡è¶³æ¡ä»¶ã€‚ ä½†ç”±äºé€’å½’æ£€æŸ¥äº†æ‰€æœ‰å¯èƒ½çš„è·¯å¾„ï¼Œå¦‚æœæœ‰ä»»æ„ä¸€æ¡è·¯å¾„æ»¡è¶³æ¡ä»¶ï¼Œåˆ™æœ€ç»ˆç»“æœä¼šè¿”å› trueã€‚ é€šè¿‡é€»è¾‘æˆ– (||) æ“ä½œç¬¦ç»„åˆè¿”å›å€¼ï¼Œ ç¡®ä¿åªè¦å­˜åœ¨ä¸€æ¡æ»¡è¶³æ¡ä»¶çš„è·¯å¾„ï¼Œæœ€ç»ˆç»“æœå°±ä¼šæ˜¯ true */ //terminate condition if(null == node){ //è¿™ä»…æ„å‘³ç€å½“å‰è·¯å¾„ä¸æ»¡è¶³æ¡ä»¶ return false; } pathVal += node.val; if(node.left == null \u0026amp;\u0026amp; node.right == null){ if(pathVal == targetSum){ return true; } } return backtracking(node.left,pathVal, targetSum) || backtracking(node.right,pathVal, targetSum); } } ","date":"2024-06-23T00:00:00Z","permalink":"https://kris0325.github.io/p/112.path-sum.java/","title":"112.path-sum.java"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 Path Sum II Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (58.45%)\t7918\t154 Tags tree | depth-first-search Companies bloomberg Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references. A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children. Example 1: Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: [[5,4,11,2],[5,8,4,5]] Explanation: There are two paths whose sum equals targetSum: 5 + 4 + 11 + 2 = 22 5 + 8 + 4 + 5 = 22 Example 2: Input: root = [1,2,3], targetSum = 5 Output: [] Example 3: Input: root = [1,2], targetSum = 0 Output: [] Constraints: The number of nodes in the tree is in the range [0, 5000]. -1000 \u0026lt;= Node.val \u0026lt;= 1000 -1000 \u0026lt;= targetSum \u0026lt;= 1000 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; pathSum(TreeNode root, int targetSum) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; pathList = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); if(null == root){ return pathList; } backtracking(root, targetSum, pathList, path); return pathList; } public void backtracking(TreeNode node , int targetSum, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; pathList , List\u0026lt;Integer\u0026gt; path){ //æ·»åŠ å½“å‰èŠ‚ç‚¹ path.add(node.val); // leaf node if(node.left == null \u0026amp;\u0026amp; node.right == null){ if(path.stream() .mapToInt(Integer::intValue) .sum() == targetSum){ //pathæ˜¯åº”ç”¨å¯¹è±¡ï¼Œæ‰€ä»¥ä¸èƒ½ç›´æ¥pathList.add(path)ï¼Œéœ€è¦æ‹·è´åå†add pathList.add(new ArrayList\u0026lt;\u0026gt;(path)); } //å›æº¯ path.remove(path.size()-1); //è¿”å›ä¸Šä¸€å±‚è°ƒç”¨ return; } /** * éå†å·¦å³2ä¸ªèŠ‚ç‚¹ * for(int i =0ï¼› i\u0026lt;2; i++ ) * éå†å®Œåï¼Œå†å›æº¯ */ //éå†left if(null != node.left){ backtracking(node.left, targetSum, pathList, path); } //éå†right if(null != node.right){ backtracking(node.right, targetSum, pathList, path); } //åœ¨å¤„ç†å®Œå½“å‰èŠ‚ç‚¹çš„å·¦å³å­èŠ‚ç‚¹åè¿›è¡Œå›æº¯ path.remove(path.size()-1); } } ","date":"2024-06-23T00:00:00Z","permalink":"https://kris0325.github.io/p/113.path-sum-ii.java/","title":"113.path-sum-ii.java"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 Lowest Common Ancestor of a Binary Tree Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (62.14%)\t16387\t409 Tags tree Companies amazon | apple | facebook | linkedin | microsoft Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: â€œThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).â€ Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3. Example 2: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Example 3: Input: root = [1,2], p = 1, q = 2 Output: 1 Constraints: The number of nodes in the tree is in the range [2, 105]. -109 \u0026lt;= Node.val \u0026lt;= 109 All Node.val are unique. p != q p and q will exist in the tree. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null || root == p || root == q) { // é€’å½’ç»“æŸæ¡ä»¶ return root; } // ååºéå† TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if(left == null \u0026amp;\u0026amp; right == null) { // è‹¥æœªæ‰¾åˆ°èŠ‚ç‚¹ p æˆ– q return null; }else if(left == null \u0026amp;\u0026amp; right != null) { // è‹¥æ‰¾åˆ°ä¸€ä¸ªèŠ‚ç‚¹ return right; }else if(left != null \u0026amp;\u0026amp; right == null) { // è‹¥æ‰¾åˆ°ä¸€ä¸ªèŠ‚ç‚¹ return left; }else { // è‹¥æ‰¾åˆ°ä¸¤ä¸ªèŠ‚ç‚¹ return root; } } } ","date":"2024-06-23T00:00:00Z","permalink":"https://kris0325.github.io/p/236.lowest-common-ancestor-of-a-binary-tree.java/","title":"236.lowest-common-ancestor-of-a-binary-tree.java"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 Delete Node in a BST Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (51.20%)\t9042\t276 Tags Companies uber Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages: Search for a node to remove. If the node is found, delete the node. Example 1: Input: root = [5,3,6,2,4,null,7], key = 3 Output: [5,4,6,2,null,null,7] Explanation: Given key to delete is 3. So we find the node with value 3 and delete it. One valid answer is [5,4,6,2,null,null,7], shown in the above BST. Please notice that another valid answer is [5,2,6,null,4,null,7] and it\u0026#39;s also accepted. Example 2: Input: root = [5,3,6,2,4,null,7], key = 0 Output: [5,3,6,2,4,null,7] Explanation: The tree does not contain a node with value = 0. Example 3: Input: root = [], key = 0 Output: [] Constraints: The number of nodes in the tree is in the range [0, 104]. -105 \u0026lt;= Node.val \u0026lt;= 105 Each node has a unique value. root is a valid binary search tree. -105 \u0026lt;= key \u0026lt;= 105 Follow up: Could you solve it with time complexity O(height of tree)? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { //solution:.ç®€åŒ–ç‰ˆé€’å½’ //1).ç¡®å®šç»ˆæ­¢æ¡ä»¶ï¼šif(root == null), return root; //2).å•å±‚é€’å½’é€»è¾‘ //case1. æ²¡æ‰¾åˆ°è¦åˆ é™¤çš„ç›®æ ‡èŠ‚ç‚¹ï¼Œéå†åˆ°ç©ºèŠ‚ç‚¹ï¼Œç›´æ¥return null //æ‰¾åˆ°è¦åˆ é™¤çš„ç›®æ ‡èŠ‚ç‚¹,å¤„ç†å½“å‰èŠ‚ç‚¹: //case2. å½“å‰èŠ‚ç‚¹å·¦ï¼Œå³å­©å­éƒ½ä¸ºnull, ç›´æ¥åˆ é™¤å½“å‰èŠ‚ç‚¹ï¼Œreturn null //case3. å½“å‰èŠ‚ç‚¹å·¦å­©å­ä¸ºnull cur.left == null, åˆ™è¿”å›å³å­©å­return cur.right //case4. å½“å‰èŠ‚ç‚¹å³å­©å­ä¸ºnull cur.right == null, åˆ™è¿”å›å·¦å­©å­return cur.left //case5. å½“å‰èŠ‚ç‚¹å·¦ï¼Œå³å­©å­éƒ½ä¸ä¸ºnull, //1 å…ˆéå†å½“å‰èŠ‚ç‚¹çš„å³å­©å­cur.right çš„æœ€å·¦è¾¹çš„â€œæœ€å·¦å¶å­èŠ‚ç‚¹â€ï¼Œå°†å•å‰èŠ‚ç‚¹çš„å·¦å­©å­cur.leftæ”¾åœ¨â€œæœ€å·¦å¶å­èŠ‚ç‚¹â€çš„å·¦å­©å­ä½ç½® //2 å†å°†åˆ™è¿”å›å½“å‰èŠ‚ç‚¹çš„å³å­©å­cur.right //key \u0026lt; root.val,é€’å½’å¤„ç†å·¦è¾¹èŠ‚ç‚¹ï¼ˆå¦‚è¿‡æœ‰å·¦èŠ‚ç‚¹çš„è¯ï¼Œå¤„ç†åç”¨å·¦èŠ‚ç‚¹æ¥ä½è¿”å›çš„ç»“æœ //key \u0026gt; root.val,é€’å½’å¤„ç†å³è¾¹èŠ‚ç‚¹ï¼ˆå¦‚æœæœ‰çš„è¯ï¼Œå¤„ç†åç”¨å·¦èŠ‚ç‚¹æ¥ä½è¿”å›çš„ç»“æœ //return root public TreeNode deleteNode(TreeNode root, int key) { if (root == null) { return null; } if (root.val == key) { // case1. å’Œcase5. å¯ä»¥åˆå¹¶ä¸º else æ¥å¤„ç† // if (root.left == null \u0026amp;\u0026amp; root.right == null) { // return null; // } else if (root.left == null) { return root.right; } else if (root.right == null) { return root.left; } else { TreeNode cur = root.right; while (cur.left != null) { cur = cur.left; } cur.left = root.left; root = root.right; return root; } } if (key \u0026lt; root.val) { root.left = deleteNode(root.left, key); } if (key \u0026gt; root.val) { root.right = deleteNode(root.right, key); } return root; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class Solution2 { //solution:2.é€’å½’ public TreeNode deleteNode(TreeNode root, int key) { if (root == null) { return null; } TreeNode parrent = null; TreeNode current = root; while (current != null) { if (current.val \u0026lt; key){ // right tree parrent = current; current = current.right; } else if (current.val \u0026gt; key) { //left tree parrent = current; current = current.left; }else { //find the key node break; } //ä»¥ä¸‹ä»£ç æœ‰BUG: å…¨éƒ¨æƒ…å†µåªæœ‰==ï¼Œ\u0026gt;, \u0026lt;3ç§caseï¼Œ æ¯ç§æƒ…å†µæ˜¯äº’æ–¥çš„ï¼Œä½†æ˜¯æ¯ä¸ªifä¹‹é—´å°‘äº†elseï¼Œæ‰§è¡Œå®Œä¸€ç§caseåˆ¤æ–­åï¼Œåº”è¯¥ç›´æ¥è·³åˆ°whileï¼ˆcurrent != nullï¼‰å¼€å¤´è¿›è¡Œåˆ¤æ–­ï¼Œ // ä½†å°‘äº†elseï¼Œ // å°±ç»§ç»­å¾€ä¸‹æ‰§è¡Œäº†ï¼Œæ‰€ä»¥æ˜¯æœ‰é—®é¢˜çš„ï¼Œè€Œä¸” parrentæ²¡æœ‰åŠæ—¶æ›´æ–°ï¼Œè€Œä¸”å¯èƒ½å‡ºç° nullç©ºæŒ‡é’ˆå¼‚å¸¸ï¼Œ // test case [5,3,8,nullï¼Œnull,6,10], key == 7çš„æƒ…å†µï¼Œæ˜¯ä¼šæŠ¥nullç©ºæŒ‡é’ˆå¼‚å¸¸çš„ // if (current.val == key) { // // find the key node // break; // } // parrent = current; // if (current.val \u0026lt; key) { // current = current.right; // } // if (current.val \u0026gt; key) { // current = current.left; // } } //BSFåªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ if (parrent == null) { return deletOneNode(current); } // key åœ¨ left if (parrent.left != null \u0026amp;\u0026amp; key == parrent.left.val) { parrent.left = deletOneNode(current); } //key åœ¨ right if (parrent.right != null \u0026amp;\u0026amp; key == parrent.right.val) { parrent.right = deletOneNode(current); } //return root ä¹ŸåŒ…å«äº† æ²¡æ‰¾BSF does not contain key,æ­¤æ—¶ ,current == null jump out while loop // if (current == null) { // return root; // } return root; } //delete node current //åˆ é™¤ç›®æ ‡æ ¹èŠ‚ç‚¹ï¼ˆè¦åˆ é™¤çš„èŠ‚ç‚¹ï¼‰ï¼Œå¦‚æœç›®æ ‡æ ¹èŠ‚ç‚¹çš„å·¦ï¼Œå³å­æ ‘éƒ½ä¸ä¸ºnullæ™‚ï¼Œæ ¹æ®BSFçš„ç‰¹æ€§ // 1. å°†ç›®æ ‡èŠ‚ç‚¹çš„å·¦å­æ ‘ï¼Œæ”¾åœ¨å³å­æ ‘çš„å·¦å­æ ‘çš„æœ€å·¦è¾¹çš„å¶å­èŠ‚ç‚¹çš„å·¦å­©å­ä½ç½®ä¸Š // 2. å°†ç›®æ ‡èŠ‚ç‚¹çš„å³å­©å­ä½œä¸ºæ–°çš„æ ¹èŠ‚ç‚¹è¿”å› public TreeNode deletOneNode(TreeNode target) { if (target == null) { return null; } // if (target.left == null) { // return target.right; // } if (target.right == null) { return target.left; } //å·¦ï¼Œå³èŠ‚ç‚¹éƒ½ä¸ä¸ºç©º TreeNode cur = target.right; while (cur.left != null) { cur = cur.left; } cur.left = target.left; return target.right; } } ","date":"2024-06-23T00:00:00Z","permalink":"https://kris0325.github.io/p/450.delete-node-in-a-bst.java/","title":"450.delete-node-in-a-bst.java"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 Unique Paths Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (64.26%)\t16533\t440 Tags array | dynamic-programming Companies bloomberg There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. The test cases are generated so that the answer will be less than or equal to 2 * 109. Example 1: Input: m = 3, n = 7 Output: 28 Example 2: Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -\u0026gt; Down -\u0026gt; Down 2. Down -\u0026gt; Down -\u0026gt; Right 3. Down -\u0026gt; Right -\u0026gt; Down Constraints: 1 \u0026lt;= m, n \u0026lt;= 100 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { //1.define dp[i][j]æ•°ç»„ ä¸ºåˆ°æ¯ä¸ªåæ ‡çš„å¯èƒ½çš„è·¯å¾„ //2.æ¨å¯¼ recursion formula, dp[m][n] = dpå·¦è¾¹+dpä¸Šè¾¹ //3.initial dp[i][j]ï¼Œç¬¬ä¸€è¡Œï¼Œç¬¬ä¸€åˆ—åˆå§‹åŒ–ï¼šdp[i][0] = 1;dp[0][j] = 1; //4.traverse orderéå†é¡ºåº //5.æ¨å¯¼ç»“æœresult public int uniquePaths(int m, int n) { int[][]dp = new int[m][n]; //ç¬¬ä¸€åˆ—ï¼Œé¦–å…ˆdp[i][0]ä¸€å®šéƒ½æ˜¯1ï¼Œå› ä¸ºä»(0, 0)çš„ä½ç½®åˆ°(i, 0)çš„è·¯å¾„åªæœ‰ä¸€æ¡ï¼Œ //åŒç†ï¼Œç¬¬ä¸€è¡Œï¼Œdp[0][j]ä¸€å®šéƒ½æ˜¯1ï¼Œå› ä¸ºä»(0, 0)çš„ä½ç½®åˆ°(0, j)çš„è·¯å¾„åªæœ‰ä¸€æ¡ for(int i= 0; i\u0026lt;m; i++){dp[i][0] = 1;} for(int j= 0; j\u0026lt;n;j++){dp[0][j] = 1;} for(int i= 1; i\u0026lt;m; i++){ for(int j= 1; j\u0026lt;n;j++){ dp[i][j] = dp[i-1][j] +dp[i][j-1]; } } return dp[m-1][n-1]; } } ","date":"2024-06-22T00:00:00Z","image":"https://kris0325.github.io/p/62.-unique-paths/62_hu217c66c1c10e19fd24d7a426241716ed_6307148_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/62.-unique-paths/","title":"62. Unique Paths"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 /* * @lc app=leetcode id=63 lang=java * * [63] Unique Paths II * * https://leetcode.com/problems/unique-paths-ii/description/ * * algorithms * Medium (41.53%) * Likes: 8687 * Dislikes: 508 * Total Accepted: 953.9K * Total Submissions: 2.3M * Testcase Example: \u0026#39;[[0,0,0],[0,1,0],[0,0,0]]\u0026#39; * * You are given an m x n integer array grid. There is a robot initially * located at the top-left corner (i.e., grid[0][0]). The robot tries to move * to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only * move either down or right at any point in time. * * An obstacle and space are marked as 1 or 0 respectively in grid. A path that * the robot takes cannot include any square that is an obstacle. * * Return the number of possible unique paths that the robot can take to reach * the bottom-right corner. * * The testcases are generated so that the answer will be less than or equal to * 2 * 10^9. * * * Example 1: * * * Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] * Output: 2 * Explanation: There is one obstacle in the middle of the 3x3 grid above. * There are two ways to reach the bottom-right corner: * 1. Right -\u0026gt; Right -\u0026gt; Down -\u0026gt; Down * 2. Down -\u0026gt; Down -\u0026gt; Right -\u0026gt; Right * * * Example 2: * * * Input: obstacleGrid = [[0,1],[0,0]] * Output: 1 * * * * Constraints: * * * m == obstacleGrid.length * n == obstacleGrid[i].length * 1 \u0026lt;= m, n \u0026lt;= 100 * obstacleGrid[i][j] is 0 or 1. * * */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // @lc code=start class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { //1.dp[i][j] è¾¾åˆ°db[i][j]åæ ‡çš„è·¯å¾„æ•° //2. recursive math dp[i][j] = dp[i-1][j] +dp[i][j-1] //3. itnitial if(obstacleGrid[] != 1) dp[0][j] = 1 dp[i][0] = 1 //4. print //5. return ç»“æœ int m = obstacleGrid.length; int n = obstacleGrid[0].length; if(obstacleGrid[0][0] ==1 \u0026amp;\u0026amp; obstacleGrid[m-1][n-1] ==1){ return 0; } int[][] dp = new int[m][n]; for(int i=0; i\u0026lt; m \u0026amp;\u0026amp; obstacleGrid[i][0] == 0;i++ ){ dp[i][0]=1; } for(int j=0; j\u0026lt; n \u0026amp;\u0026amp; obstacleGrid[0][j] == 0;j++ ){ dp[0][j]=1; } for(int i= 1; i\u0026lt; m;i++ ){ for(int j=1; j\u0026lt; n;j++ ){ //å¦‚æœå½“å‰åæ ‡obstacleGrid[i][j]ä¸Šæœ‰éšœç¢ç‰©ï¼Œåˆ™æ‰€æœ‰è·¯å¾„éƒ½æ— æ³•è¾¾åˆ°å•å‰åæ ‡ï¼Œæ‰€ä»¥dp[i][j] =0 dp[i][j] = obstacleGrid[i][j] == 1? 0 : dp[i-1][j] + dp[i][j-1]; } } return dp[m-1][n-1]; } } // @lc code=end ","date":"2024-06-22T00:00:00Z","permalink":"https://kris0325.github.io/p/63.-unique-paths-ii/","title":"63. Unique Paths II"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 /* * @lc app=leetcode id=93 lang=java * * [93] Restore IP Addresses * * https://leetcode.com/problems/restore-ip-addresses/description/ * * algorithms * Medium (49.82%) * Likes: 5190 * Dislikes: 789 * Total Accepted: 464.3K * Total Submissions: 923.5K * Testcase Example: \u0026#39;\u0026#34;25525511135\u0026#34;\u0026#39; * * A valid IP address consists of exactly four integers separated by single * dots. Each integer is between 0 and 255 (inclusive) and cannot have leading * zeros. * * * For example, \u0026#34;0.1.2.201\u0026#34; and \u0026#34;192.168.1.1\u0026#34; are valid IP addresses, but * \u0026#34;0.011.255.245\u0026#34;, \u0026#34;192.168.1.312\u0026#34; and \u0026#34;192.168@1.1\u0026#34; are invalid IP * addresses. * * * Given a string s containing only digits, return all possible valid IP * addresses that can be formed by inserting dots into s. You are not allowed * to reorder or remove any digits in s. You may return the valid IP addresses * in any order. * * * Example 1: * * * Input: s = \u0026#34;25525511135\u0026#34; * Output: [\u0026#34;255.255.11.135\u0026#34;,\u0026#34;255.255.111.35\u0026#34;] * * * Example 2: * * * Input: s = \u0026#34;0000\u0026#34; * Output: [\u0026#34;0.0.0.0\u0026#34;] * * * Example 3: * * * Input: s = \u0026#34;101023\u0026#34; * Output: [\u0026#34;1.0.10.23\u0026#34;,\u0026#34;1.0.102.3\u0026#34;,\u0026#34;10.1.0.23\u0026#34;,\u0026#34;10.10.2.3\u0026#34;,\u0026#34;101.0.2.3\u0026#34;] * * * * Constraints: * * * 1 \u0026lt;= s.length \u0026lt;= 20 * s consists of digits only. * * */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 import java.util.List; class Solution { public List\u0026lt;String\u0026gt; restoreIpAddresses(String s) { //backtrack to solve it // collect valid ip List\u0026lt;String\u0026gt; validIps = new ArrayList\u0026lt;\u0026gt;(); //1. not valid string if( s.length()\u0026lt; 4 || s.length()\u0026gt; 12 ){ return validIps; } int segament = 0; String currentIPString = \u0026#34;\u0026#34;; int startIndex = 0; backtrack(s, validIps, 0, currentIPString, segament); return validIps; } // backtrack public void backtrack(String s,List\u0026lt;String\u0026gt; validIps, int startIndex, String currentIPString, int segament ){ // return condition if(segament == 4 \u0026amp;\u0026amp; startIndex == s.length()){ validIps.add(currentIPString); return; } //trm if(segament ==4 || startIndex == s.length()){ return; } // iterative current string from 1 to 3 for(int len = 1; len\u0026lt;=3; len++){ if(startIndex + len \u0026gt;s.length()){ break; } String segamentIP = s.substring(startIndex, startIndex+len); if(validSegamentIP(segamentIP, len)){ String newcurrentIPString = segament == 0 ? segamentIP : currentIPString + \u0026#34;.\u0026#34; + segamentIP; backtrack(s,validIps,startIndex+len, newcurrentIPString, segament+1); } } } //validSegamentIP public boolean validSegamentIP(String segamentIP, int len){ // invalid SegamentIP 01 || 256 etc. if((segamentIP.startsWith(\u0026#34;0\u0026#34;) \u0026amp;\u0026amp; len \u0026gt; 1) || (!segamentIP.startsWith(\u0026#34;0\u0026#34;) \u0026amp;\u0026amp; Integer.valueOf(segamentIP) \u0026gt; 255)){ return false; } return true; } } ","date":"2024-06-21T00:00:00Z","image":"https://kris0325.github.io/p/93.-restore-ip-addresses/93_hucd08571b687ba28d79d57df2cab6e02d_13845230_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/93.-restore-ip-addresses/","title":"93. Restore IP Addresses"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 Binary Tree Level Order Traversal Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (67.15%)\t15149\t309 Tags tree | breadth-first-search Companies amazon | apple | bloomberg | facebook | linkedin | microsoft Given the root of a binary tree, return the level order traversal of its nodes\u0026#39; values. (i.e., from left to right, level by level). Example 1: Input: root = [3,9,20,null,null,15,7] Output: [[3],[9,20],[15,7]] Example 2: Input: root = [1] Output: [[1]] Example 3: Input: root = [] Output: [] Constraints: The number of nodes in the tree is in the range [0, 2000]. -1000 \u0026lt;= Node.val \u0026lt;= 1000 https://leetcode.com/problems/binary-tree-level-order-traversal/description/ * /* * æ€è·¯ï¼šäºŒå‰æ ‘å±‚åºéå†ï¼Œå€ŸåŠ©queueè¾…åŠ©æ•°æ®ç»“æ„æ¥å®ç° * */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { if(null == root) { return result; } Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.add(root); while (!queue.isEmpty()) { //æ”¶é›†å½“å‰levelçš„èŠ‚ç‚¹å…ƒç´  List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); //è®°å½•å½“å‰èŠ‚ç‚¹æ•°é‡ int len = queue.size(); //éå†å½“å‰level for(int i = 0; i \u0026lt; len;i++){ TreeNode node = queue.poll(); list.add(node.val); if(node.left != null){ queue.offer(node.left); } if(node.right != null){ queue.offer(node.right); } } result.add(list); } return result; } } ","date":"2024-06-09T00:00:00Z","image":"https://kris0325.github.io/p/102.-binary-tree-level-order-traversal/102_hu9bf809a008d6edb44fb307c7b2936237_7785777_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/102.-binary-tree-level-order-traversal/","title":"102. Binary Tree Level Order Traversal"},{"content":"https://leetcode.com/problems/binary-tree-postorder-traversal/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 /* * @lc app=leetcode id=144 lang=java * * [144] Binary Tree Preorder Traversal * * https://leetcode.com/problems/binary-tree-preorder-traversal/description/ * * algorithms * Easy (69.46%) * Likes: 7911 * Dislikes: 209 * Total Accepted: 1.6M * Total Submissions: 2.3M * Testcase Example: \u0026#39;[1,null,2,3]\u0026#39; * * Given the root of a binary tree, return the preorder traversal of its nodes\u0026#39; * values. * * * Example 1: * * * Input: root = [1,null,2,3] * Output: [1,2,3] * * * Example 2: * * * Input: root = [] * Output: [] * * * Example 3: * * * Input: root = [1] * Output: [1] * * * * Constraints: * * * The number of nodes in the tree is in the range [0, 100]. * -100 \u0026lt;= Node.val \u0026lt;= 100 * * * * Follow up: Recursive solution is trivial, could you do it iteratively? * */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /* * æ€è·¯ï¼šéæ­¸å¯¦ç¾ */ class Solution1 { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { if(null == root){ return result; } result.add(root.val); preorderTraversal(root.left); preorderTraversal(root.right); return result; } } /* * æ€è·¯ï¼šè¿­ä»£å¯¦ç¾ */ class Solution { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { if (null == root) { return result; } Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); result.add(node.val); if (node.right != null) { stack.push(node.right); } if (node.left != null) { stack.push(node.left); } } return result; } } // @lc code=end ","date":"2024-06-08T00:00:00Z","image":"https://kris0325.github.io/p/144.binary-tree-preorder-traversal.java/144_hub3d0262241a7411e47a00bfd6996676e_5504694_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/144.binary-tree-preorder-traversal.java/","title":"144.binary-tree-preorder-traversal.java"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 /* * @lc app=leetcode id=145 lang=java * * [145] Binary Tree Postorder Traversal * * https://leetcode.com/problems/binary-tree-postorder-traversal/description/ * * algorithms * Easy (70.88%) * Likes: 6835 * Dislikes: 189 * Total Accepted: 1.2M * Total Submissions: 1.7M * Testcase Example: \u0026#39;[1,null,2,3]\u0026#39; * * Given the root of aÂ binary tree, return the postorder traversal of its * nodes\u0026#39; values. * * * Example 1: * * * Input: root = [1,null,2,3] * Output: [3,2,1] * * * Example 2: * * * Input: root = [] * Output: [] * * * Example 3: * * * Input: root = [1] * Output: [1] * * * * Constraints: * * * The number of the nodes in the tree is in the range [0, 100]. * -100 \u0026lt;= Node.val \u0026lt;= 100 * * * * Follow up: Recursive solution is trivial, could you do it iteratively? */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 /* * æ€è·¯1ï¼šé€’å½’å®ç°ååºéå† */ // class Solution1 { // List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); // public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { // if(null == root){ // return result; // } // postorderTraversal(root.left); // postorderTraversal(root.right); // result.add(root.val); // return result; // } // } /* * æ€è·¯2ï¼šstacké€’å½’å®ç°ååºéå†ï¼Œä½¿ç”¨ä¸€ä¸ªé¢å¤–çš„æ ˆåè½¬èŠ‚ç‚¹ */ class Solution2 { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { if(root == null){ return result; } Stack\u0026lt;TreeNode\u0026gt; stack1 = new Stack\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack2 = new Stack\u0026lt;\u0026gt;(); stack1.push(root); while (!stack1.isEmpty()) { TreeNode node = stack1.pop(); stack2.push(node); if(node.left != null){ stack1.push(node.left); } if(node.right != null){ stack1.push(node.right); } } while (!stack2.isEmpty()) { result.add(stack2.pop().val); } return result; } } /* * æ€è·¯3ï¼šstacké€’å½’å®ç°ååºéå†ï¼Œå€Ÿé‰´è°¦è™šéå†ï¼Œç¨å¾®è°ƒæ•´ä¸‹å…¥æ ˆé¡ºåºå³å¯ */ class Solution { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { if(root == null){ return result; } Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); result.add(node.val); if(root.left != null){ stack.push(root.left); } if(root.right != null){ stack.push(root.left); } } result.reversed(); return result; } } ","date":"2024-06-08T00:00:00Z","image":"https://kris0325.github.io/p/145.binary-tree-postorder-traversal.java/145_hu119d3ec452b8ab1a47872fc0a598407f_11674299_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/145.binary-tree-postorder-traversal.java/","title":"145.binary-tree-postorder-traversal.java"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 /* * @lc app=leetcode id=94 lang=java * * [94] Binary Tree Inorder Traversal * * https://leetcode.com/problems/binary-tree-inorder-traversal/description/ * * algorithms * Easy (76.08%) * Likes: 13350 * Dislikes: 776 * Total Accepted: 2.5M * Total Submissions: 3.3M * Testcase Example: \u0026#39;[1,null,2,3]\u0026#39; * * Given the root of a binary tree, return the inorder traversal of its nodes\u0026#39; * values. * * * Example 1: * * * Input: root = [1,null,2,3] * Output: [1,3,2] * * * Example 2: * * * Input: root = [] * Output: [] * * * Example 3: * * * Input: root = [1] * Output: [1] * * * * Constraints: * * * The number of nodes in the tree is in the range [0, 100]. * -100 \u0026lt;= Node.val \u0026lt;= 100 * * * * Follow up: Recursive solution is trivial, could you do it iteratively? */ // @lc code=start import java.util.ArrayList; /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /* * æ€è·¯ï¼šéæ­¸å¯¦ç¾ä¸­åºéæ­· * */ class Solution1 { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { if (null == root) { return result; } if(root.left != null){ inorderTraversal(root.left); } result.add(root.val); if(root.right != null){ inorderTraversal(root.right); } return result; } } /* * æ€è·¯ï¼šè¿­ä»£å¯¦ç¾ä¸­åºéæ­· * */ class Solution { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); TreeNode cur = root; while(cur != null || !stack.isEmpty()){ while(cur!= null){ stack.push(cur); cur = cur.left; } cur = stack.pop(); result.add(cur.val); cur = cur.right; } return result; } } ","date":"2024-06-08T00:00:00Z","image":"https://kris0325.github.io/p/94.binary-tree-inorder-traversal.java/94_hu02245ee8d9a8c4ec85434334539ca1da_2844357_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/94.binary-tree-inorder-traversal.java/","title":"94.binary-tree-inorder-traversal.java"},{"content":"https://leetcode.com/problems/top-k-frequent-elements/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 Top K Frequent Elements Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (62.76%)\t17113\t647 Tags hash-table | heap Companies pocketgems | yelp Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] Constraints: 1 \u0026lt;= nums.length \u0026lt;= 105 -104 \u0026lt;= nums[i] \u0026lt;= 104 k is in the range [1, the number of unique elements in the array]. It is guaranteed that the answer is unique. Follow up: Your algorithm\u0026#39;s time complexity must be better than O(n log n), where n is the array\u0026#39;s size. 1 2 3 4 5 6 7 8 /* * æ€è·¯ï¼šæœ€å°å †ï¼ˆå°é¡¶å †ï¼‰ * 1.haspmap å­˜æ¯ä¸ªå…ƒç´ çš„å€¼ä¸å¯¹åº”é¢‘ç‡ï¼› * 2.PriorityQueueå®ç°æ„å»ºä¸€ä¸ªæœ€å°å †ï¼Œç„¶åéå†hashmapï¼Œå°†æ‰€æœ‰\u0026lt;å…ƒç´ ï¼Œé¢‘ç‡\u0026gt; pair éƒ½æ¨å…¥åˆ°å †ä¸­ï¼Œ * åŒæ—¶ç»´æŠ¤å †çš„å¤§å°ä¸ºk,å³å¦‚æœå †å¤§å°è¶…è¿‡kæ—¶ï¼Œå°±å°†å †é¡¶å…ƒç´ å¼¹å‡ºï¼Œå¹¶æ¨å…¥å½“å‰å…ƒç´  * 3.éå†å®Œåï¼ŒPriorityQueueçš„å…ƒç´ å³ä¸ºæ‰€æ±‚ * * */i 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import java.util.HashMap; import java.util.Map; import java.util.PriorityQueue; class Solution { public int[] topKFrequent(int[] nums, int k) { Map\u0026lt;Integer, Integer\u0026gt; num2Frequent = new HashMap\u0026lt;\u0026gt;(); for(int num : nums){ num2Frequent.put(num, num2Frequent.getOrDefault(num, 0)+1); } //æ„å»ºæœ€å°å †çš„ä¼˜å…ˆçº§é˜Ÿåˆ— //ä¼˜å…ˆé˜Ÿåˆ—çš„å­˜å‚¨çš„å…ƒç´ ä¸ºä¸€ä¸ªint[2], å³ä¸€ä¸ªpair\u0026lt;num, cnt\u0026gt; numä¸ºæ•°å­—ï¼Œcntä¸ºå¯¹åº”é¢‘ç‡ PriorityQueue\u0026lt;int[]\u0026gt; priorityQueue = new java.util.PriorityQueue\u0026lt;\u0026gt;((pair1,pair2) -\u0026gt; pair1[1]-pair2[1]); for(Map.Entry\u0026lt;Integer, Integer\u0026gt; entry : num2Frequent.entrySet() ){ if(priorityQueue.size()\u0026lt;k){ priorityQueue.add(new int[]{entry.getKey(), entry.getValue()}); } else { //å½“å‰å…ƒç´ å‡ºç°é¢‘ç‡å¤§äºæœ€å°å †å †é¡¶å…ƒç´ å¯¹åº”çš„é¢‘ç‡ if(entry.getValue() \u0026gt; priorityQueue.peek()[1]){ //å¼¹å‡ºæœ€å°å †å †é¡¶å…ƒç´  priorityQueue.poll(); //å°†å½“å‰å…ƒç´ æ¨å…¥é˜Ÿåˆ— priorityQueue.add(new int[]{entry.getKey(), entry.getValue()}); } } } int[] result = new int[k]; for(int i = 0; i\u0026lt;k ; i++){ result[i] = priorityQueue.poll()[0]; } return result; } } ","date":"2024-05-27T00:00:00Z","image":"https://kris0325.github.io/p/347.-top-k-frequent-elements/347_hu2a8b01894b50d3180429ee23f2799d90_10071556_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/347.-top-k-frequent-elements/","title":"347. Top K Frequent Elements"},{"content":"https://leetcode.com/problems/sliding-window-maximum/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 Sliding Window Maximum Category\tDifficulty\tLikes\tDislikes algorithms\tHard (46.57%)\t17988\t666 Tags heap | sliding-window Companies amazon | google | zenefits You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example 1: Input: nums = [1,3,-1,-3,5,3,6,7], k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Example 2: Input: nums = [1], k = 1 Output: [1] Constraints: 1 \u0026lt;= nums.length \u0026lt;= 105 -104 \u0026lt;= nums[i] \u0026lt;= 104 1 \u0026lt;= k \u0026lt;= nums.length 1 2 3 4 5 6 /** * æ€è·¯ï¼šé˜Ÿåˆ—å®ç° 1.ç”¨ä¸€ä¸ªå•è°ƒé€’å¢é˜Ÿåˆ—ç»´æŠ¤æ»‘åŠ¨çª—å£ï¼Œé˜Ÿåˆ—æœ€å‰é¢ä¸€ä¸ªå…ƒç´ å³ä¸ºå½“å‰çª—å£çš„æœ€å¤§å€¼ï¼Œæ”¶é›†åˆ°æ•°ç»„ï¼› 2.æ¯æ¬¡ç§»åŠ¨çª—å£ï¼Œåˆ™æ·»åŠ å½“å‰å…ƒç´ å…¥é˜Ÿåˆ—ï¼Œé‚£ä¹ˆé˜Ÿåˆ—æœ€å‰é¢ä¸€ä¸ªå…ƒç´ å³ä¸ºå½“å‰æœ€å¤§å€¼ï¼Œæ”¶é›†åˆ°æ•°ç»„ï¼› 3.ç›´åˆ°ç§»åŠ¨åˆ°ç›®æ ‡æ•°ç»„çš„æœ«å°¾ï¼Œreturnæ”¶é›†æœ€å¤§å€¼çš„æ•°ç»„ **/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class MyQueue{ Deque\u0026lt;Integer\u0026gt; myDeque = new LinkedList\u0026lt;\u0026gt;(); //å°†å½“å‰å€¼æ¨å…¥é˜Ÿåˆ—ï¼ˆé˜Ÿå°¾ï¼‰ï¼Œå¹¶ç§»é™¤æ‰€æœ‰æ¯”å½“å‰å€¼å°çš„å…ƒç´  public void push (int value){ while(!myDeque.isEmpty() \u0026amp;\u0026amp; value \u0026gt; myDeque.getLast()){ myDeque.removeLast(); } /* é”™è¯¯å…¥é˜Ÿåˆ—ï¼Œè¿™ä¸ªæ–¹æ³•æ˜¯stackå®ç°çš„é˜Ÿåˆ—ï¼Œç›¸å½“äºå°†å½“å‰å€¼æ¨å…¥é˜Ÿåˆ—ï¼ˆé˜Ÿé¦–ï¼‰äº† myDeque.push(value); **/ myDeque.addLast(value); } //å¦‚æœé˜Ÿåˆ—é¦–éƒ¨å…ƒç´ ç­‰äºç»™å®šå€¼ï¼Œåˆ™ç§»é™¤å®ƒ public void pop(int value){ if(!myDeque.isEmpty() \u0026amp;\u0026amp; myDeque.peekFirst() == value){ myDeque.removeFirst(); } } //è¿”å›é˜Ÿåˆ—é¦–éƒ¨å…ƒç´ ï¼Œå³å½“å‰çª—å£çš„æœ€å¤§å€¼ public Integer peek(){ return myDeque.peekFirst(); } } class Solution { public int[] maxSlidingWindow(int[] nums, int k) { MyQueue myDeque = new MyQueue(); int[] result = new int[nums.length-k+1]; int num = 0; //åˆå§‹åŒ–ç¬¬ä¸€ä¸ªæ»‘åŠ¨çª—å£ for(int i = 0; i\u0026lt; k; i++){ //åˆå§‹åŒ–æ»‘åŠ¨çª—å£å…¥é˜Ÿåˆ—ï¼Œå¹¶ä¸”æ„å»ºçš„æ˜¯å•è°ƒé˜Ÿåˆ—ï¼Œé˜Ÿåˆ—å¹¶ä¸éœ€è¦ç»´æŠ¤æ‰€æœ‰æ»‘åŠ¨çª—å£å†…çš„å…ƒç´ ï¼Œ //åªéœ€ç»´æŠ¤å¯èƒ½ä¸ºæœ€å¤§å€¼çš„å…ƒç´ ï¼Œå³ä¿è¯é˜Ÿåˆ—ä»é˜Ÿå°¾åˆ°å¯¹é¦–æ˜¯å•è°ƒé€’å¢å³å¯ myDeque.push(nums[i]); } result[num++] = myDeque.peek(); // å¤„ç†æ»‘åŠ¨çª—å£ for(int i= k; i \u0026lt; nums.length;i++){ myDeque.pop(nums[i-k]); myDeque.push(nums[i]); result[num++] = myDeque.peek(); } return result; } } // @lc code=end ","date":"2024-05-26T00:00:00Z","image":"https://kris0325.github.io/p/239.-sliding-window-maximum/239_hu0f7fa2ed191dbc8425b52f20b76cf327_7206809_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/239.-sliding-window-maximum/","title":"239. Sliding Window Maximum"},{"content":"https://leetcode.com/problems/evaluate-reverse-polish-notation/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 Evaluate Reverse Polish Notation Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (51.37%)\t7556\t1069 Tags stack Companies linkedin You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation. Evaluate the expression. Return an integer that represents the value of the expression. Note that: The valid operators are \u0026#39;+\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;*\u0026#39;, and \u0026#39;/\u0026#39;. Each operand may be an integer or another expression. The division between two integers always truncates toward zero. There will not be any division by zero. The input represents a valid arithmetic expression in a reverse polish notation. The answer and all the intermediate calculations can be represented in a 32-bit integer. Example 1: Input: tokens = [\u0026#34;2\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;+\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;*\u0026#34;] Output: 9 Explanation: ((2 + 1) * 3) = 9 Example 2: Input: tokens = [\u0026#34;4\u0026#34;,\u0026#34;13\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;/\u0026#34;,\u0026#34;+\u0026#34;] Output: 6 Explanation: (4 + (13 / 5)) = 6 Example 3: Input: tokens = [\u0026#34;10\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;+\u0026#34;,\u0026#34;-11\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;/\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;17\u0026#34;,\u0026#34;+\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;+\u0026#34;] Output: 22 Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 Constraints: 1 \u0026lt;= tokens.length \u0026lt;= 104 tokens[i] is either an operator: \u0026#34;+\u0026#34;, \u0026#34;-\u0026#34;, \u0026#34;*\u0026#34;, or \u0026#34;/\u0026#34;, or an integer in the range [-200, 200]. 1 2 3 /** * æ€è·¯ï¼šæ ˆå®ç°ä½ æ³¢å…°è¡¨è¾¾å¼ï¼ˆåç¼€è¡¨ç¤ºæ³•ï¼‰ */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int evalRPN(String[] tokens) { Stack\u0026lt;Integer\u0026gt; stackRPN = new Stack\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; operators = Arrays.asList( \u0026#34;+\u0026#34;,\u0026#34;-\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;/\u0026#34;); for(int i = 0; i\u0026lt; tokens.length; i++){ if(!operators.contains(tokens[i])){ stackRPN.push(Integer.valueOf(tokens[i])); } else{ int right= Integer.valueOf(stackRPN.pop()) ; int left = Integer.valueOf(stackRPN.pop()); if(\u0026#34;+\u0026#34;.equals(tokens[i]))stackRPN.push(left + right); if(\u0026#34;-\u0026#34;.equals(tokens[i]))stackRPN.push(left - right); if(\u0026#34;*\u0026#34;.equals(tokens[i]))stackRPN.push(left * right); if(\u0026#34;/\u0026#34;.equals(tokens[i]))stackRPN.push(left / right); } } return stackRPN.pop(); } } ","date":"2024-05-24T00:00:00Z","image":"https://kris0325.github.io/p/150.-evaluate-reverse-polish-notation/150_hu643fe10fc5d8a8cac53007a5b54442bc_7091430_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/150.-evaluate-reverse-polish-notation/","title":"150. Evaluate Reverse Polish Notation"},{"content":"https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Solved Easy Topics Stack | Queue |String Companies You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them. We repeatedly make duplicate removals on s until we no longer can. Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique. Example 1: Input: s = \u0026#34;abbaca\u0026#34; Output: \u0026#34;ca\u0026#34; Explanation: For example, in \u0026#34;abbaca\u0026#34; we could remove \u0026#34;bb\u0026#34; since the letters are adjacent and equal, and this is the only possible move. The result of this move is that the string is \u0026#34;aaca\u0026#34;, of which only \u0026#34;aa\u0026#34; is possible, so the final string is \u0026#34;ca\u0026#34;. Example 2: Input: s = \u0026#34;azxxzy\u0026#34; Output: \u0026#34;ay\u0026#34; Constraints: 1 \u0026lt;= s.length \u0026lt;= 105 s consists of lowercase English letters. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* * æ€è·¯ï¼š solution1: é˜Ÿåˆ—å®ç° éå†å­—ç¬¦ä¸²ï¼Œå¹¶å­˜å…¥æ ˆï¼Œ å½“å½“å‰å…ƒç´ å’Œé˜Ÿåˆ—ç¬¬ä¸€ä¸ªå…ƒç´ ç›¸åŒæ—¶ï¼Œè·³è¿‡æ­¤æ¬¡å¾ªç¯i++ï¼ŒåŒæ—¶å¼¹å‡ºé˜Ÿåˆ—ç¬¬ä¸€ä¸ªå…ƒç´ ï¼› å¦åˆ™å°†å½“å‰å…ƒç´ å­˜å…¥é˜Ÿåˆ—ï¼› éå†å®Œåï¼Œéå†å¼¹å‡ºé˜Ÿåˆ—å…ƒç´ ç»„æˆæ–°å­—ç¬¦ä¸²å³å¯ solution2: in-place å°†å­—ç¬¦ä¸²å½“æ ˆä½¿ç”¨ solution3: åŒæŒ‡é’ˆå®ç° solution4: æ ˆå®ç° éå†å­—ç¬¦ä¸²ï¼Œå¹¶å­˜å…¥æ ˆï¼Œ å½“å½“å‰å…ƒç´ å’Œæ ˆé¡¶å…ƒç´ ç›¸åŒæ—¶ï¼Œè·³è¿‡æ­¤æ¬¡å¾ªç¯i++ï¼ŒåŒæ—¶å¼¹å‡ºæ ˆé¡¶å…ƒç´ ï¼› å¦åˆ™å°†å½“å‰å…ƒç´ å­˜å…¥æ ˆï¼› éå†å®Œåï¼Œéå†å¼¹å‡ºæ ˆå†…å…ƒç´ ç»„æˆæ–°å­—ç¬¦ä¸²ï¼Œå¹¶åè½¬å­—ç¬¦ä¸²å³å¯ */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import java.sql.Array; import java.util.ArrayDeque; class Solution1 { public String removeDuplicates(String s) { ArrayDeque deque = new ArrayDeque\u0026lt;\u0026gt;(); for(int i =0;i\u0026lt;s.length();i++){ if(deque.isEmpty() || (char) deque.peek() != s.charAt(i)){ deque.push(s.charAt(i)); } else{ deque.pop(); } } String newS = \u0026#34;\u0026#34;; while (!deque.isEmpty()) { newS = deque.pop()+ newS; } return newS; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public String removeDuplicates(String s) { char[] charS = s.toCharArray(); int fast = 0; int slow = 0; while (fast \u0026lt; charS.length) { // Use the fast pointer to overwrite the value at the slow pointer // When encountering the same value before and after, the slow pointer retreats, // and the same value will be overwritten by the fast pointer in the next loop if(slow \u0026gt; 0 \u0026amp;\u0026amp; charS[slow-1] == charS[fast]){ slow--; } else{ charS[slow++] = charS[fast]; } //æ¯æ¬¡å¾ªç¯éƒ½éœ€è¦ç§»åŠ¨fast fast++; } return new String(charS,0,slow); } } ","date":"2024-05-19T00:00:00Z","image":"https://kris0325.github.io/p/1047.-remove-all-adjacent-duplicates-in-string/1047_hua62bcbcf9a79dfe26d0875c8d67438b3_11777398_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/1047.-remove-all-adjacent-duplicates-in-string/","title":"1047. Remove All Adjacent Duplicates In String"},{"content":"https://leetcode.com/problems/valid-parentheses/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 Valid Parentheses Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (40.56%)\t23735\t1719 Tags string | stack Companies airbnb | amazon | bloomberg | facebook | google | microsoft | twitter | zenefits Given a string s containing just the characters \u0026#39;(\u0026#39;, \u0026#39;)\u0026#39;, \u0026#39;{\u0026#39;, \u0026#39;}\u0026#39;, \u0026#39;[\u0026#39; and \u0026#39;]\u0026#39;, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type. Example 1: Input: s = \u0026#34;()\u0026#34; Output: true Example 2: Input: s = \u0026#34;()[]{}\u0026#34; Output: true Example 3: Input: s = \u0026#34;(]\u0026#34; Output: false Constraints: 1 \u0026lt;= s.length \u0026lt;= 104 s consists of parentheses only \u0026#39;()[]{}\u0026#39;. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 æ€è·¯ï¼šç”¨æ ˆå®ç° å…ˆæ¥åˆ†æä¸€ä¸‹ è¿™é‡Œæœ‰ä¸‰ç§ä¸åŒ¹é…çš„æƒ…å†µï¼Œ ç¬¬ä¸€ç§æƒ…å†µï¼Œå­—ç¬¦ä¸²é‡Œå·¦æ–¹å‘çš„æ‹¬å·å¤šä½™äº† ï¼Œæ‰€ä»¥ä¸åŒ¹é…ã€‚ ç¬¬äºŒç§æƒ…å†µï¼Œæ‹¬å·æ²¡æœ‰å¤šä½™ï¼Œä½†æ˜¯ æ‹¬å·çš„ç±»å‹æ²¡æœ‰åŒ¹é…ä¸Šã€‚ ç¬¬ä¸‰ç§æƒ…å†µï¼Œå­—ç¬¦ä¸²é‡Œå³æ–¹å‘çš„æ‹¬å·å¤šä½™äº†ï¼Œæ‰€ä»¥ä¸åŒ¹é…ã€‚ ç¬¬ä¸€ç§æƒ…å†µï¼šå·²ç»éå†å®Œäº†å­—ç¬¦ä¸²ï¼Œä½†æ˜¯æ ˆä¸ä¸ºç©ºï¼Œè¯´æ˜æœ‰ç›¸åº”çš„å·¦æ‹¬å·æ²¡æœ‰å³æ‹¬å·æ¥åŒ¹é…ï¼Œæ‰€ä»¥return false ç¬¬äºŒç§æƒ…å†µï¼šéå†å­—ç¬¦ä¸²åŒ¹é…çš„è¿‡ç¨‹ä¸­ï¼Œå‘ç°æ ˆé‡Œæ²¡æœ‰è¦åŒ¹é…çš„å­—ç¬¦ã€‚æ‰€ä»¥return false ç¬¬ä¸‰ç§æƒ…å†µï¼šéå†å­—ç¬¦ä¸²åŒ¹é…çš„è¿‡ç¨‹ä¸­ï¼Œæ ˆå·²ç»ä¸ºç©ºäº†ï¼Œæ²¡æœ‰åŒ¹é…çš„å­—ç¬¦äº†ï¼Œè¯´æ˜å³æ‹¬å·æ²¡æœ‰æ‰¾åˆ°å¯¹åº”çš„å·¦æ‹¬å·return false é‚£ä¹ˆä»€ä¹ˆæ—¶å€™è¯´æ˜å·¦æ‹¬å·å’Œå³æ‹¬å·å…¨éƒ½åŒ¹é…äº†å‘¢ï¼Œå°±æ˜¯å­—ç¬¦ä¸²éå†å®Œä¹‹åï¼Œæ ˆæ˜¯ç©ºçš„ï¼Œå°±è¯´æ˜å…¨éƒ½åŒ¹é…äº†ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // @lc code=start import java.util.Stack; class Solution { public boolean isValid(String s) { Stack\u0026lt;Character\u0026gt; stackS = new Stack\u0026lt;\u0026gt;(); for(int i=0; i\u0026lt; s.length(); i++){ if(\u0026#39;(\u0026#39; == s.charAt(i)){ stackS.push(\u0026#39;)\u0026#39;); } else if(\u0026#39;{\u0026#39; == s.charAt(i)){ stackS.push(\u0026#39;}\u0026#39;); } else if(\u0026#39;[\u0026#39; == s.charAt(i)){ stackS.push(\u0026#39;]\u0026#39;); } //ç¬¬ä¸‰ç§æƒ…å†µï¼šéå†å­—ç¬¦ä¸²åŒ¹é…çš„è¿‡ç¨‹ä¸­ï¼Œæ ˆå·²ç»ç©ºäº†ï¼Œå³è¾¹è¿˜æœ‰æ²¡åŒ¹é…çš„å­—ç¬¦ï¼Œè¯´æ˜å³æ‹¬å·æ²¡æœ‰æ‰¾åˆ°å¯¹åº”çš„å·¦æ‹¬å·ï¼Œreturn false; //ç¬¬äºŒç§æƒ…å†µï¼šéå†å­—ç¬¦ä¸²åŒ¹é…çš„è¿‡ç¨‹ä¸­ï¼Œå‘ç°æ ˆé‡Œæ²¡æœ‰åŒ¹é…çš„å­—ç¬¦ï¼Œè¯´æ˜æ‹¬å·ç±»å‹æ²¡åŒ¹é…ä¸Šï¼Œreturn false; else if(stackS.isEmpty() || stackS.peek() != s.charAt(i) ){ return false; } //å³æ‹¬å·ä¸æ ˆé¡¶å…ƒç´ åŒ¹é…ï¼Œåˆ™pop(), è¿›è¡Œä¸‹ä¸€æ¬¡æ“ä½œ else { stackS.pop(); } } //ç¬¬ä¸€ç§æƒ…å†µï¼šæ­¤æ—¶å·²éå†å®Œå­—ç¬¦ä¸²ï¼Œæ ˆä¸ä¸ºç©ºï¼Œè¯´æ˜å·¦æ‹¬å·å¤šäº†ï¼Œæ²¡æœ‰å¯¹åº”çš„å³æ‹¬å·æ¥åŒ¹é…ï¼Œreturn false, å¦åˆ™return true; return stackS.isEmpty(); } } // @lc code=end ","date":"2024-05-18T00:00:00Z","image":"https://kris0325.github.io/p/20.-valid-parentheses/20_hue3151d51445e528ddb008b90055ab5f3_4973423_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/20.-valid-parentheses/","title":"20. Valid Parentheses"},{"content":"https://leetcode.com/problems/implement-stack-using-queues/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 Implement Stack using Queues Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (63.63%)\t5965\t1199 Tags stack | design Companies bloomberg Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty). Implement the MyStack class: void push(int x) Pushes element x to the top of the stack. int pop() Removes the element on the top of the stack and returns it. int top() Returns the element on the top of the stack. boolean empty() Returns true if the stack is empty, false otherwise. Notes: You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid. Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue\u0026#39;s standard operations. Example 1: Input [\u0026#34;MyStack\u0026#34;, \u0026#34;push\u0026#34;, \u0026#34;push\u0026#34;, \u0026#34;top\u0026#34;, \u0026#34;pop\u0026#34;, \u0026#34;empty\u0026#34;] [[], [1], [2], [], [], []] Output [null, null, null, 2, 2, false] Explanation MyStack myStack = new MyStack(); myStack.push(1); myStack.push(2); myStack.top(); // return 2 myStack.pop(); // return 2 myStack.empty(); // return False Constraints: 1 \u0026lt;= x \u0026lt;= 9 At most 100 calls will be made to push, pop, top, and empty. All the calls to pop and top are valid. Follow-up: Can you implement the stack using only one queue? 1 2 3 4 5 6 /* * æ€è·¯ï¼š2ä¸ªé˜Ÿåˆ—å®ç°æ ˆï¼Œä¸€ä¸ªæ ˆpushæ—¶æ¨¡æ‹Ÿstackçš„å­˜å‚¨é¡ºåºï¼Œå¦ä¸€ä¸€ä¸ªé˜Ÿåˆ—å®Œå…¨å½“ä½œå¤‡ä»½ç”¨ * * * * ***/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import java.util.LinkedList; import java.util.Queue; class MyStack { Queue\u0026lt;Integer\u0026gt; queue; Queue\u0026lt;Integer\u0026gt; queueBackup; public MyStack() { queue = new LinkedList\u0026lt;\u0026gt;(); queueBackup = new LinkedList\u0026lt;\u0026gt;(); } //åŠ å…¥å…ƒç´ æ—¶ï¼Œå³ç”¨queueæ¨¡æ‹Ÿæ ˆstackçš„å­˜å‚¨é¡ºåºï¼Œå°† queueä¾æ¬¡å‹å…¥queueBackupï¼Œ //å†å°†queueBackupçš„å…ƒç´ ä¾æ¬¡å‹å…¥queueï¼Œè¿™æ ·ä¿è¯xä½äºqueueçš„ç¬¬ä¸€ä¸ªä½ç½®ï¼Œå³ç±»ä¼¼æ ˆé¡¶ public void push(int x) { while (queue.size()\u0026gt;0) { queueBackup.add(queue.poll()); } queue.add(x); while (queueBackup.size()\u0026gt;0) { queue.add(queueBackup.poll()); } } public int pop() { return queue.poll(); } public int top() { return queue.peek(); } public boolean empty() { return queue.isEmpty(); } } ","date":"2024-05-18T00:00:00Z","image":"https://kris0325.github.io/p/225.-implement-stack-using-queues/225_hu134691ec6495076548774a62268f84fa_12731442_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/225.-implement-stack-using-queues/","title":"225. Implement Stack using Queues"},{"content":"\u0026lt; https://leetcode.com/problems/implement-queue-using-stacks/description/\u003e\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 Implement Queue using Stacks Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (66.20%)\t7520\t423 Tags stack | design Companies bloomberg | microsoft Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class: void push(int x) Pushes element x to the back of the queue. int pop() Removes the element from the front of the queue and returns it. int peek() Returns the element at the front of the queue. boolean empty() Returns true if the queue is empty, false otherwise. Notes: You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack\u0026#39;s standard operations. Example 1: Input [\u0026#34;MyQueue\u0026#34;, \u0026#34;push\u0026#34;, \u0026#34;push\u0026#34;, \u0026#34;peek\u0026#34;, \u0026#34;pop\u0026#34;, \u0026#34;empty\u0026#34;] [[], [1], [2], [], [], []] Output [null, null, null, 1, 1, false] Explanation MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false Constraints: 1 \u0026lt;= x \u0026lt;= 9 At most 100 calls will be made to push, pop, peek, and empty. All the calls to pop and peek are valid. Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity? In other words, performing n operations will take overall O(n) time even if one of those operations may take longer. 1 2 3 4 /* ** æ€è·¯ï¼šä¸¤ä¸ªstackå®ç°FIFO queue * * * */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import java.util.Stack; class MyQueue { Stack\u0026lt;Integer\u0026gt; stackIn; Stack\u0026lt;Integer\u0026gt; stackOut; public MyQueue() { stackIn = new Stack\u0026lt;\u0026gt;(); stackOut = new Stack\u0026lt;\u0026gt;(); } public void push(int x) { stackIn.push(x); } public int pop() { dumpStackIn(); return stackOut.pop(); } public int peek() { dumpStackIn(); return stackOut.peek(); } public boolean empty() { return stackIn.isEmpty() \u0026amp;\u0026amp; stackOut.isEmpty(); } public void dumpStackIn(){ if(!stackOut.isEmpty()) return; while (!stackIn.isEmpty()) { stackOut.push(stackIn.pop()); } } } ","date":"2024-05-18T00:00:00Z","image":"https://kris0325.github.io/p/232.-implement-queue-using-stacks/232_hu3f630662af572599871cfc0a7997cf15_15449336_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/232.-implement-queue-using-stacks/","title":"232. Implement Queue using Stacks"},{"content":"https://leetcode.com/problems/reverse-words-in-a-string/description/\nç›¸åŒé¡å‹ï¼š 344. Reverse String https://leetcode.com/problems/reverse-string/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 Reverse Words in a String Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (42.13%)\t8216\t5116 Tags string Companies apple | bloomberg | microsoft | snapchat | yelp Given an input string s, reverse the order of the words. A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space. Return a string of the words in reverse order concatenated by a single space. Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces. Example 1: Input: s = \u0026#34;the sky is blue\u0026#34; Output: \u0026#34;blue is sky the\u0026#34; Example 2: Input: s = \u0026#34; hello world \u0026#34; Output: \u0026#34;world hello\u0026#34; Explanation: Your reversed string should not contain leading or trailing spaces. Example 3: Input: s = \u0026#34;a good example\u0026#34; Output: \u0026#34;example good a\u0026#34; Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string. Constraints: 1 \u0026lt;= s.length \u0026lt;= 104 s contains English letters (upper-case and lower-case), digits, and spaces \u0026#39; \u0026#39;. There is at least one word in s. Follow-up: If the string data type is mutable in your language, can you solve it in-place with O(1) extra space? 1 2 3 4 5 6 7 /* * æ€è·¯: solution1: stackå¯¦ç¾reverse * 1ï¼Œå…ˆéæ­·å­—ç¬¦ä¸²æ•¸çµ„ï¼Œå‰ªåˆ‡æ‰spaceï¼Œå–å‡ºwordæŒ‰é †åºå­˜å…¥stackï¼› * 2ï¼Œstack popå‡ºworldï¼ŒåŠ ä¸Šspaceæ‹¼æ¥æˆå­—ç¬¦ä¸² * */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // @lc code=start import java.util.ArrayList; import java.util.List; import java.util.Stack; class Solution { public String reverseWords(String s) { //é€šè¿‡åœ¨åˆ†å‰²å­—ç¬¦ä¸²ä¹‹å‰ä½¿ç”¨trim()å»é™¤é¦–å°¾ç©ºæ ¼ //ï¼Œå¹¶ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼\u0026#34;\\\\s+\u0026#34;åŒ¹é…å¤šä¸ªç©ºæ ¼ï¼Œå¯ä»¥é¿å…ç©ºå­—ç¬¦ä¸²çš„é—®é¢˜ String [] spStrings = s.trim().split(\u0026#34;\\\\s+\u0026#34;); Stack\u0026lt;String\u0026gt; stackString = new Stack(); for(int i =0; i\u0026lt; spStrings.length; i++){ stackString.push(spStrings[i]); } List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); while (!stackString.empty()) { list.add(stackString.pop()); } return String.join(\u0026#34; \u0026#34;, list); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* * Follow-up:Â If the string data type is mutable in your language, canÂ you * solve itÂ in-placeÂ withÂ O(1)Â extra space? * * æ€è·¯ï¼šé›™æŒ‡é‡æ³• * èˆ‡344. Reverse Stringæ€è·¯ä¸€è‡´ï¼Œ * 1.å…ˆå‰ªåˆ‡é¦–å°¾ç©ºæ ¼èˆ‡ä¸­é–“å¤šé¤˜ç©ºæ ¼ 2.å…ˆåè½‰å­—ç¬¦ä¸²ï¼Œé€™æ™‚å–®è©ä¹Ÿè¢«åè½‰äº† 3.å†åè½‰å–®è© æ³¨æ„ï¼šè™•ç†// åè½¬æœ€åä¸€ä¸ªå•è¯ * * * * * * */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Solution { public String reverseWords(String s) { // å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºå­—ç¬¦æ•°ç»„ char[] schar = s.toCharArray(); // å­—ç¬¦æ•°ç»„çš„é•¿åº¦ int length = schar.length; // å»é™¤é¦–å°¾å’Œä¸­é—´å¤šä½™çš„ç©ºæ ¼ int slow = 0; // æ…¢æŒ‡é’ˆï¼Œè®°å½•æ–°å­—ç¬¦ä¸²çš„é•¿åº¦ int fast = 0; // å¿«æŒ‡é’ˆï¼Œéå†åŸå§‹å­—ç¬¦ä¸² while (fast \u0026lt; length) { // è·³è¿‡å‰å¯¼ç©ºæ ¼ while (fast \u0026lt; length \u0026amp;\u0026amp; schar[fast] == \u0026#39; \u0026#39;) fast++; // å°†éç©ºå­—ç¬¦ç§»åˆ°æ…¢æŒ‡é’ˆä½ç½® if (slow \u0026gt; 0 \u0026amp;\u0026amp; fast \u0026lt; length) { schar[slow++] = \u0026#39; \u0026#39;; } // å°†å•è¯å¤åˆ¶åˆ°æ–°å­—ç¬¦ä¸² while (fast \u0026lt; length \u0026amp;\u0026amp; schar[fast] != \u0026#39; \u0026#39;) { schar[slow++] = schar[fast++]; } } // åè½¬æ•´ä¸ªå­—ç¬¦ä¸² reverseString(schar, 0, slow - 1); // åè½¬å„ä¸ªå•è¯ int start = 0; // å•è¯èµ·å§‹ä½ç½® for (int i = 0; i \u0026lt; slow; i++) { if (schar[i] == \u0026#39; \u0026#39;) { // åè½¬å•è¯ reverseString(schar, start, i - 1); // æ›´æ–°å•è¯èµ·å§‹ä½ç½® start = i + 1; } } // åè½¬æœ€åä¸€ä¸ªå•è¯ reverseString(schar, start, slow - 1); // å°†å­—ç¬¦æ•°ç»„è½¬æ¢ä¸ºå­—ç¬¦ä¸² return new String(schar, 0, slow); } // åè½¬å­—ç¬¦æ•°ç»„çš„æŒ‡å®šåŒºé—´ public void reverseString(char[] schar, int start, int end) { while (start \u0026lt; end) { char tmp = schar[start]; schar[start] = schar[end]; schar[end] = tmp; start++; end--; } } } // @lc code=end ","date":"2024-05-15T00:00:00Z","image":"https://kris0325.github.io/p/151.-reverse-words-in-a-string/151_hua62bcbcf9a79dfe26d0875c8d67438b3_8789011_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/151.-reverse-words-in-a-string/","title":"151. Reverse Words in a String"},{"content":"https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 Find the Index of the First Occurrence in a String Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (42.25%)\t5645\t390 Tags two-pointers | string Companies apple | facebook | microsoft | pocketgems Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = \u0026#34;sadbutsad\u0026#34;, needle = \u0026#34;sad\u0026#34; Output: 0 Explanation: \u0026#34;sad\u0026#34; occurs at index 0 and 6. The first occurrence is at index 0, so we return 0. Example 2: Input: haystack = \u0026#34;leetcode\u0026#34;, needle = \u0026#34;leeto\u0026#34; Output: -1 Explanation: \u0026#34;leeto\u0026#34; did not occur in \u0026#34;leetcode\u0026#34;, so we return -1. Constraints: 1 \u0026lt;= haystack.length, needle.length \u0026lt;= 104 haystack and needle consist of only lowercase English characters. 1 2 3 4 5 6 7 8 9 /** * æ€è·¯ï¼šæ»‘å‹•çª—å£ / é›™æŒ‡é‡æ³•ï¼Œ åªæ˜¯å·¦å³æŒ‡é‡åŒæ­¥ç§»å‹•ï¼Œhaystack.substring(i, i+needle.length()) 1.needle.length \u0026gt; haystack,ç›´æ¥return -1; 2.å¾haystackçš„èµ·å§‹ä½ç½®i=0é–‹å§‹,å–needle.lengthé•·åº¦å­å­—ç¬¦ä¸²èˆ‡needleæ¯”è¼ƒï¼Œ å­—ç¬¦ä¸²ä¸ç›¸åŒï¼Œå‰‡æ»‘å‹•needle.lengthé•·åº¦ç¹¼çºŒæ¯”è¼ƒï¼Œç›´åˆ°iåˆ°é”haystack.length-needle.lengthä½ç½®ï¼Œ å­—ç¬¦ä¸²ç›¸åŒï¼Œå‰‡return ä½ç½®i; **/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // @lc code=start class Solution { public int strStr(String haystack, String needle) { if(haystack.length()\u0026lt;needle.length()){ return -1; } for(int i = 0; i \u0026lt;= haystack.length()-needle.length();i++ ){ if(needle.equals(haystack.substring(i, i+needle.length()))){ return i; } } return -1; } } // @lc code=end ","date":"2024-05-15T00:00:00Z","image":"https://kris0325.github.io/p/28.-find-the-index-of-the-first-occurrence-in-a-string/28_hud97b491a9f638fe86f3a609aa163e872_18321669_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/28.-find-the-index-of-the-first-occurrence-in-a-string/","title":"28. Find the Index of the First Occurrence in a String"},{"content":"https://leetcode.com/problems/reverse-string/description/\n1 2 3 4 5 6 7 8 9 /** * æ€è·¯ï¼šåŒæŒ‡é’ˆç®—æ³• æœ¬é¢˜è¦æ±‚ä½¿ç”¨åŸåœ°ç®—æ³• in-placeç®—æ³• with O(1) extra memoryï¼Œä¸èƒ½ä½¿ç”¨é¢å¤–å†…å­˜ï¼Œæ‰€ä»¥è€ƒè™‘ä½¿ç”¨åŒæŒ‡é’ˆç®—æ³•ï¼Œ left,rightæŒ‡é’ˆåˆ†åˆ«æŒ‡å‘æ•°ç»„é¦–å°¾ï¼Œ ä½¿ç”¨ä¸´æ—¶å˜é‡tmpæš‚å­˜ s[left]ï¼Œç„¶åäº¤æ¢é¦–å°¾å…ƒç´ ï¼Œ ç„¶åå·¦å³æŒ‡é’ˆæ”¶ç¼©ã€‚ æ‰©å±•ï¼šæœ¬é¢˜å¦‚æœä¸è¦æ±‚ä½¿ç”¨in-placeç®—æ³•ï¼Œå¯ä»¥é€šè¿‡stackå…ˆè¿›åå‡ºçš„æ•°æ®ç»“æ„å®ç°æ±‚è§£ */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // @lc code=start class Solution { public void reverseString(char[] s) { int left = 0; int right = s.length-1; while (left \u0026lt; right) { char tmp = s[left]; s[left] = s[right]; s[right] = tmp; left++; right--; } } } // @lc code=end ","date":"2024-05-14T00:00:00Z","image":"https://kris0325.github.io/p/344.-reverse-string/344_hua62bcbcf9a79dfe26d0875c8d67438b3_6409887_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/344.-reverse-string/","title":"344. Reverse String"},{"content":"https://leetcode.com/problems/4sum/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 4Sum Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (36.24%)\t11135\t1367 Tags array | hash-table | two-pointers Companies linkedin Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that: 0 \u0026lt;= a, b, c, d \u0026lt; n a, b, c, and d are distinct. nums[a] + nums[b] + nums[c] + nums[d] == target You may return the answer in any order. Example 1: Input: nums = [1,0,-1,0,-2,2], target = 0 Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] Example 2: Input: nums = [2,2,2,2,2], target = 8 Output: [[2,2,2,2]] Constraints: 1 \u0026lt;= nums.length \u0026lt;= 200 -109 \u0026lt;= nums[i] \u0026lt;= 109 -109 \u0026lt;= target \u0026lt;= 109 æ€è·¯ï¼š ä¸15.3sum å¾ˆåƒï¼Œä¹Ÿæ˜¯ä½¿ç”¨åŒæŒ‡é’ˆï¼Œåªéœ€å†åŠ ä¸€æˆforå¾ªç¯å³å¯. å¦å¤–ï¼Œéœ€è¦æ³¨æ„å‰ªæï¼Œä¸å»é‡ https://leetcode.com/problems/3sum/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // @lc code=start import java.util.ArrayList; import java.util.Arrays; class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; fourSum(int[] nums, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); for(int i = 0; i\u0026lt; nums.length; i++){ //å‰ªæ if(nums[i]\u0026gt;target \u0026amp;\u0026amp; nums[i]\u0026gt;=0 ) { break; } //nums[i]å»é‡ if(i\u0026gt;0 \u0026amp;\u0026amp; nums[i] == nums[i-1]){ continue; } for(int j = i+1; j \u0026lt; nums.length; j++){ //å‰ªæ if(nums[i] + nums[j]\u0026gt;target \u0026amp;\u0026amp; nums[j]\u0026gt;=0 ) { break; } //nums[i]å»é‡ if(j\u0026gt;i+1 \u0026amp;\u0026amp; nums[j]==nums[j-1]){ continue; } int left = j+1; int right = nums.length-1; while (left \u0026lt; right) { int sum = nums[i]+nums[j]+nums[left]+nums[right]; int longTarget = target; //åœ¨Javaä¸­ï¼Œintç±»å‹çš„æœ€å¤§å€¼å¯ä»¥é€šè¿‡Integer.MAX_VALUEå¸¸é‡æ¥è¡¨ç¤ºï¼Œå…·ä½“æ•°å€¼ä¸º2147483647ï¼Œå³$2^{31}-1ï¼Œ // æ‰€ä»¥ nums[i]+nums[j]+nums[left]+nums[right]ä¸ä¼šæº¢å‡º // Long sum = Long.valueOf(nums[i]+nums[j]+nums[left]+nums[right]) ; // Long longTarget = Long.valueOf(target) ; if (sum \u0026lt; longTarget) { left++; } else if (sum \u0026gt; longTarget) { right--; } else { //æ”¶é›†ç­”æ¡ˆ result.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right])); //å¯¹nums[left]å»é‡ while(right \u0026gt; left \u0026amp;\u0026amp; nums[left] == nums[left+1]){ left++; } //nums[right]å»é‡ while (right \u0026gt; left \u0026amp;\u0026amp; nums[right] == nums[right-1]) { right--; } //åŒæŒ‡é’ˆåŒæ—¶æ”¶ç¼© right--; left++; } } } } return result; } } // @lc code=end ","date":"2024-05-13T00:00:00Z","image":"https://kris0325.github.io/p/18.-4sum/18_hua62bcbcf9a79dfe26d0875c8d67438b3_5204973_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/18.-4sum/","title":"18. 4Sum"},{"content":"https://leetcode.com/problems/reverse-string-ii/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 Reverse String II Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (50.66%)\t1944\t3753 Tags string Companies google Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string. If there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and leave the other as original. Example 1: Input: s = \u0026#34;abcdefg\u0026#34;, k = 2 Output: \u0026#34;bacdfeg\u0026#34; Example 2: Input: s = \u0026#34;abcd\u0026#34;, k = 2 Output: \u0026#34;bacd\u0026#34; Constraints: 1 \u0026lt;= s.length \u0026lt;= 104 s consists of only lowercase English letters. 1 \u0026lt;= k \u0026lt;= 104 æ€è·¯ï¼šåŒæŒ‡é’ˆæ³• æœ¬é¢˜ä¸344.Reverse Stringè§£æ³•æ€è·¯ç›¸åŒï¼Œéƒ½æ˜¯ç”¨åŒæŒ‡é’ˆæ³•ï¼Œ æŒ‰ç…§è§„å¾‹ï¼Œ 1.å¯ä»¥å°†å­—ç¬¦ä¸²s æ¯2ké—´æ®µè¿›è¡Œåˆ‡åˆ†ï¼Œæ¯æ®µéƒ½æ˜¯reverseå‰kä¸ªå­—ç¬¦ï¼Œ 2.ç„¶åè€ƒè™‘è¾¹ç•Œæ¡ä»¶ï¼Œå³æœ«å°¾åˆ†æƒ…å†µè®¨è®ºï¼š 2.1 æœ«å°¾å‰©ä½™é•¿åº¦lenthæ»¡è¶³ k \u0026lt;lenth \u0026lt; 2k, å³ pos+k \u0026lt; s.length, åˆ™åè½¬å‰kä¸ªå­—ç¬¦ï¼Œå…¶å®æ“ä½œå’Œç¬¬1.æ­¥ä¸€æ ·, å³ reverse(ch, pos, pos+k-1)ï¼› 2.2 æœ«å°¾å‰©ä½™é•¿åº¦lenthæ»¡è¶³ lenth \u0026lt; k, å³pos+k \u0026gt; s.length, åˆ™åè½¬æ‰€æœ‰å‰©ä½™å­—ç¬¦ï¼Œå³ reverse(ch, pos, ch.length-1); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public String reverseStr(String s, int k) { char[]s2char = s.toCharArray(); for(int pos = 0; pos \u0026lt; s.length(); pos += 2*k){ if(pos+k \u0026lt; s.length()){ reverse(s2char, pos, pos+k-1); } else { reverse(s2char, pos, s2char.length-1); } } return new String(s2char); } public void reverse(char[] str, int leftPos, int rightPos){ while(leftPos \u0026lt; rightPos){ char tmp = str[leftPos]; str[leftPos] = str[rightPos]; str[rightPos] = tmp; leftPos++; rightPos--; } } } ","date":"2024-05-13T00:00:00Z","image":"https://kris0325.github.io/p/541.-reverse-string-ii/541_hua62bcbcf9a79dfe26d0875c8d67438b3_5193231_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/541.-reverse-string-ii/","title":"541. Reverse String II"},{"content":"https://leetcode.com/problems/3sum/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 3Sum Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (34.46%)\t30399\t2815 Tags array | two-pointers Companies adobe | amazon | bloomberg | facebook | microsoft Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets. Example 1: Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0. nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0. The distinct triplets are [-1,0,1] and [-1,-1,2]. Notice that the order of the output and the order of the triplets does not matter. Example 2: Input: nums = [0,1,1] Output: [] Explanation: The only possible triplet does not sum up to 0. Example 3: Input: nums = [0,0,0] Output: [[0,0,0]] Explanation: The only possible triplet sums up to 0. Constraints: 3 \u0026lt;= nums.length \u0026lt;= 3000 -105 \u0026lt;= nums[i] \u0026lt;= 105 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* æ€è·¯ï¼šsolution1é›™æŒ‡é‡æ³• Notice that the solution set must not contain duplicate triplets.éœ€è¦å»é‡è¤‡,é›™æŒ‡é‡æ³•æ¯”å“ˆå¸Œè¡¨ç®—æ³•æ›´ç°¡å–® 1.æ’åº 2.iå»é‡è¤‡ i\u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1],(ä¸‰å…ƒæ•¸çµ„å…§éƒ¨å…ƒç´ å¯ä»¥é‡è¤‡ï¼Œæ‰€ä»¥éœ€è¦ç”¨å¾Œä¸€å€‹æ•¸èˆ‡å‰ä¸€å€‹æ•¸é€²è¡Œæ¯”è¼ƒï¼Œ ä¸¦ä¸”å¾ç¬¬äºŒå€‹æ•¸i=1é–‹å§‹ï¼Œæ¯”å¦‚case[-1,-1,0], æ‰€ä»¥ä¸èƒ½ä½¿ç”¨æ¢ä»¶nums[i] == nums[i+1]åˆ¤æ–·ï¼Œæˆ–æ¼æ‰ï¼Œ ä¹Ÿå°±æ˜¯èªªä¸‰å…ƒæ•¸çµ„ä¸èƒ½é‡è¤‡ï¼Œä½†ä¸‰å…ƒæ•¸çµ„å…§éƒ¨å…ƒç´ å¯ä»¥é‡è¤‡) 3. iéæ­·æ•¸çµ„ï¼Œ æ¯æ¬¡å¾ªç’°left= i+1; right = nums.length()-1, 4. when( left \u0026lt; right), nums[i] + nums[j] + nums[k] \u0026lt; 0 , å°‡leftæŒ‡é‡å³ç§»ï¼Œ nums[i] + nums[j] + nums[k] \u0026gt; 0 , å°‡rightæŒ‡é‡å·¦ç§»ï¼Œ 5. ç›´åˆ°æ‰¾åˆ°ä¸‰å…ƒæ•¸çµ„ï¼Œæ»¿è¶³ nums[i] + nums[j] + nums[k] == 0ï¼Œ 6. ç„¶å¾Œleft | right å»é‡è¤‡ nums[left] == nums[left+1], left++; nums[right] == nums[right-1], right--; solution2 å“ˆå¸Œè¡¨æ³• **/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 import java.util.ArrayList; import java.util.List; class Solution1 { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); for (int i = 0; i \u0026lt; nums.length; i++) { //å‰ªæï¼Œ æ’åºå¾Œï¼Œç¬¬ä¸€å€‹æ•¸å¤§æ–¼é›¶ï¼Œå‰‡ç„¡æ³•æ»¿è¶³æ¢ä»¶ï¼Œå¯ä»¥ç›´æ¥return if (nums[i] \u0026gt; 0) { return result; } // nums[i]å»é‡ if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } int left = i + 1; int right = nums.length - 1; while (right \u0026gt; left) { if (nums[i] + nums[left] + nums[right] \u0026lt; 0) { left++; } else if (nums[i] + nums[left] + nums[right] \u0026gt; 0) { right--; } else if (nums[i] + nums[left] + nums[right] == 0) { //æ”¶é›†æ»¿è¶³æ¢ä»¶çš„ä¸‰å…ƒæ•¸çµ„ result.add(Arrays.asList(nums[i], nums[left], nums[right])); // leftæŒ‡é‡å»é‡è¤‡ while (right \u0026gt; left \u0026amp;\u0026amp; nums[left] == nums[left + 1]) { left++; } // rightå³æŒ‡é‡å»é‡è¤‡ while (right \u0026gt; left \u0026amp;\u0026amp; nums[right] == nums[right - 1]) { right--; } left++; right--; } } } return result; } } class Solution2 { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); for (int i = 0; i \u0026lt; nums.length; i++) { // å¦‚æœç¬¬ä¸€ä¸ªå…ƒç´ å¤§äºé›¶ï¼Œä¸å¯èƒ½å‡‘æˆä¸‰å…ƒç»„ if (nums[i] \u0026gt; 0) { return result; } // ä¸‰å…ƒç»„å…ƒç´ aå»é‡ if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } HashSet\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (int j = i + 1; j \u0026lt; nums.length; j++) { // ä¸‰å…ƒç»„å…ƒç´ bå»é‡ /** æ³¨æ„:å…ƒç´ bå–å»é‡æ™‚ï¼Œéœ€è¦è€ƒæ…®åªæœ‰ç•¶ç•¶å‰å…ƒç´ nums[j]ï¼Œ èˆ‡ä¹‹å‰ç¬¬ä¸€å€‹å…ƒç´ nums[j-1]ï¼Œä¹‹å‰ç¬¬2å€‹å…ƒç´ éƒ½ç›¸åŒæ™‚ï¼Œ ä¹Ÿå°±æ˜¯å‰ä¸‰å€‹å…ƒç´ éƒ½ç›¸åŒæ™‚ï¼Œæ‰éœ€è¦è€ƒæ…®å»é‡è·³éã€‚ å¦å‰‡ï¼Œåªè€ƒæ…® nums[j] == nums[j - 1]ï¼Œæœƒå‡ºç¾éåº¦å»é‡ï¼Œæ¼æ‰æ­£ç¢ºç­”æ¡ˆã€‚ æ ¹æœ¬åŸå› åœ¨æ–¼,ä¸‰å…ƒçµ„æ•¸çµ„ä¹‹é–“ä¸èƒ½é‡è¤‡ï¼Œä½†æ™‚å–®å€‹ä¸‰å…ƒçµ„å…§éƒ¨å…ƒç´ å¯ä»¥é‡è¤‡ã€‚ ä¾‹å¦‚ï¼š /** * if (j \u0026gt; i + 2 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) { continue; } * * Wrong Answer: Input nums = [-2,0,1,1,2] Output [[-2,2,0]] Expected [[-2,0,2],[-2,1,1]] */ if (j \u0026gt; i + 2 \u0026amp;\u0026amp; nums[j] == nums[j - 1]\u0026amp;\u0026amp; nums[j - 1] == nums[j - 2] ) { continue; } int c = -nums[i] - nums[j]; if (set.contains(c)) { result.add(Arrays.asList(nums[i], nums[j], c)); set.remove(c); // ä¸‰å…ƒç»„å…ƒç´ cå»é‡ } else { set.add(nums[j]); } } } return result; } } // @lc code=end ","date":"2024-05-12T00:00:00Z","image":"https://kris0325.github.io/p/15.-3sum/15_hua62bcbcf9a79dfe26d0875c8d67438b3_12225185_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/15.-3sum/","title":"15. 3Sum"},{"content":"https://leetcode.com/problems/ransom-note/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 Ransom Note Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (61.30%)\t4905\t496 Tags string Companies apple Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise. Each letter in magazine can only be used once in ransomNote. Example 1: Input: ransomNote = \u0026#34;a\u0026#34;, magazine = \u0026#34;b\u0026#34; Output: false Example 2: Input: ransomNote = \u0026#34;aa\u0026#34;, magazine = \u0026#34;ab\u0026#34; Output: false Example 3: Input: ransomNote = \u0026#34;aa\u0026#34;, magazine = \u0026#34;aab\u0026#34; Output: true Constraints: 1 \u0026lt;= ransomNote.length, magazine.length \u0026lt;= 105 ransomNote and magazine consist of lowercase English letters. 1 2 3 4 5 6 7 8 9 10 /* * æ€è·¯ï¼šå“ˆå¸Œè¡¨ Solution1ï¼š åˆ†åˆ«ä½¿ç”¨hashMapæ”¶é›†ransomNote, magazineçš„letteræ•°é‡ï¼Œ key-\u0026gt; letter, value-\u0026gt;nums, å†éæ­·hashmapï¼Œç•¶Each letter in magazineå°æ‡‰çš„valueå¿…é ˆå¤§æ–¼ç­‰æ–¼ransomNoteå°æ‡‰çš„hashmapï¼Œ return true, å¦å‰‡false Solution2ï¼š æœ¬é¢˜ä¸ 242. Valid Anagram 242.æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯å¾ˆåƒ, å¯ä»¥ä½¿ç”¨å“ˆå¸Œæ•°ç»„ */i 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // @lc code=start import java.util.HashMap; import java.util.Map; class Solution1 { public boolean canConstruct(String ransomNote, String magazine) { HashMap\u0026lt;Character, Integer\u0026gt; ransomNoteMap = new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;Character, Integer\u0026gt; magazineMap = new HashMap\u0026lt;\u0026gt;(); for(int i = 0; i\u0026lt; ransomNote.length(); i++){ Character letter = ransomNote.charAt(i); ransomNoteMap.put(letter, ransomNoteMap.getOrDefault(letter,0)+1); } for(int i = 0; i\u0026lt; magazine.length(); i++ ){ Character letter = magazine.charAt(i); magazineMap.put(letter, magazineMap.getOrDefault(letter,0)+1); } for(Map.Entry\u0026lt;Character, Integer\u0026gt; entry : ransomNoteMap.entrySet()){ if(!magazineMap.containsKey(entry.getKey()) || (magazineMap.containsKey(entry.getKey()) \u0026amp;\u0026amp; magazineMap.get(entry.getKey()) \u0026lt; entry.getValue())){ return false; } } return true; } } class Solution2 { public boolean canConstruct(String ransomNote, String magazine) { // shortcut if (ransomNote.length() \u0026gt; magazine.length()) { return false; } // å®šä¹‰ä¸€ä¸ªå“ˆå¸Œæ˜ å°„æ•°ç»„ int[] record = new int[26]; // éå† for(char c : magazine.toCharArray()){ record[c - \u0026#39;a\u0026#39;] += 1; } for(char c : ransomNote.toCharArray()){ record[c - \u0026#39;a\u0026#39;] -= 1; } // å¦‚æœæ•°ç»„ä¸­å­˜åœ¨è´Ÿæ•°ï¼Œè¯´æ˜ransomNoteå­—ç¬¦ä¸²æ€»å­˜åœ¨magazineä¸­æ²¡æœ‰çš„å­—ç¬¦ for(int i : record){ if(i \u0026lt; 0){ return false; } } return true; } } // @lc code=end 1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* * æ—¶é—´å¤æ‚åº¦, ç©ºé—´å¤æ‚åº¦åˆ†æ Solution1çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(m + n)ï¼Œå…¶ä¸­mä¸ºransomNoteå­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œnä¸ºmagazineå­—ç¬¦ä¸²çš„é•¿åº¦ã€‚åœ¨è¯¥è§£å†³æ–¹æ¡ˆä¸­ï¼Œé¦–å…ˆéœ€è¦éå†ransomNoteå’Œmagazineå­—ç¬¦ä¸²å„ä¸€æ¬¡ï¼Œç„¶åéœ€è¦éå†ransomNoteMapä¸­çš„é”®å€¼å¯¹ï¼Œå› æ­¤æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(m + n)ã€‚ Solution2çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿä¸ºO(m + n)ï¼Œå…¶ä¸­mä¸ºransomNoteå­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œnä¸ºmagazineå­—ç¬¦ä¸²çš„é•¿åº¦ã€‚åœ¨è¯¥è§£å†³æ–¹æ¡ˆä¸­ï¼Œé¦–å…ˆéœ€è¦éå†magazineå­—ç¬¦ä¸²å’ŒransomNoteå­—ç¬¦ä¸²å„ä¸€æ¬¡ï¼Œç„¶åéå†recordæ•°ç»„ï¼Œå› æ­¤æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(m + n)ã€‚ å¯¹äºç©ºé—´å¤æ‚åº¦ï¼ŒSolution1ä½¿ç”¨äº†ä¸¤ä¸ªHashMapæ¥å­˜å‚¨ransomNoteå’Œmagazineå­—ç¬¦ä¸²ä¸­å­—ç¬¦å‡ºç°çš„æ¬¡æ•°ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ä¸ºO(m + n)ï¼Œå…¶ä¸­må’Œnåˆ†åˆ«ä¸ºransomNoteå’Œmagazineå­—ç¬¦ä¸²çš„é•¿åº¦ã€‚ è€ŒSolution2ä½¿ç”¨äº†ä¸€ä¸ªé•¿åº¦ä¸º26çš„æ•°ç»„recordæ¥è®°å½•magazineå­—ç¬¦ä¸²ä¸­å„ä¸ªå­—ç¬¦å‡ºç°çš„æ¬¡æ•°ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ä¸ºO(1)ï¼Œä¸å­—ç¬¦ä¸²çš„é•¿åº¦æ— å…³ã€‚ åœ¨é¢è¯•ä¸­ï¼ŒSolution2æ›´å¥½ä¸€äº›ã€‚å› ä¸ºå®ƒä¸éœ€è¦é¢å¤–çš„HashMapæ•°æ®ç»“æ„ï¼Œåªéœ€è¦ä¸€ä¸ªå›ºå®šå¤§å°çš„æ•°ç»„å³å¯å®Œæˆä»»åŠ¡ï¼ŒèŠ‚çœäº†ç©ºé—´ï¼Œå¹¶ä¸”æ—¶é—´å¤æ‚åº¦ä¹Ÿç›¸åŒã€‚æ­¤å¤–ï¼ŒSolution2çš„å®ç°æ›´åŠ ç®€æ´æ˜äº†ï¼Œæ˜“äºç†è§£å’Œç»´æŠ¤ã€‚ * * */ ","date":"2024-05-12T00:00:00Z","image":"https://kris0325.github.io/p/383.-ransom-note/383_hua62bcbcf9a79dfe26d0875c8d67438b3_6347894_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/383.-ransom-note/","title":"383. Ransom Note"},{"content":"https://leetcode.com/problems/two-sum/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 1. Two Sum Easy Topics Companies Hint Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Example 1: Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]. Example 2: Input: nums = [3,2,4], target = 6 Output: [1,2] Example 3: Input: nums = [3,3], target = 6 Output: [0,1] Constraints: 2 \u0026lt;= nums.length \u0026lt;= 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 -109 \u0026lt;= target \u0026lt;= 109 Only one valid answer exists. Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int[] twoSum(int[] nums, int target) { int[] result = new int[2]; //åˆ©ç”¨HashMap ä¼˜åŒ–æ—¶é—´å¤æ‚åº¦åˆ°o(n) Map\u0026lt;Integer, Integer\u0026gt; tmpMap = new HashMap\u0026lt;\u0026gt;(); for(int i =0; i \u0026lt; nums.length ; i ++ ){ if(tmpMap.containsKey(target - nums[i])){ result[0] = tmpMap.get(target - nums[i]); result[1] = i; return result; } tmpMap.put(nums[i],i); } return result; } } ","date":"2024-05-11T00:00:00Z","image":"https://kris0325.github.io/p/1.-two-sum/1_hua62bcbcf9a79dfe26d0875c8d67438b3_9401146_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/1.-two-sum/","title":"1. Two Sum"},{"content":"https://leetcode.com/problems/4sum-ii/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 4Sum II Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (57.24%)\t4879\t140 Tags hash-table | binary-search Companies Unknown Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that: 0 \u0026lt;= i, j, k, l \u0026lt; n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 Example 1: Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2] Output: 2 Explanation: The two tuples are: 1. (0, 0, 0, 1) -\u0026gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -\u0026gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0 Example 2: Input: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0] Output: 1 Constraints: n == nums1.length n == nums2.length n == nums3.length n == nums4.length 1 \u0026lt;= n \u0026lt;= 200 -228 \u0026lt;= nums1[i], nums2[i], nums3[i], nums4[i] \u0026lt;= 228 1 2 3 4 5 6 /** * æ€è·¯ï¼šå“ˆå¸Œè¡¨ æ¢ä»¶ nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0ï¼Œ å¯ä»¥æ‹†åˆ†ç‚º (nums1[i] + nums2[j] )+ (nums2[j] + nums3[k]) == 0, è¿˜æ˜¯ 1. Two Sumï¼ˆ1.ä¸¤æ•°ä¹‹å’Œé—®é¢˜) */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // @lc code=start class Solution { public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) { HashMap\u0026lt;Integer, Integer\u0026gt; fourSum = new HashMap\u0026lt;\u0026gt;(); int count = 0; for(int i : nums1){ for(int j : nums2){ int sum = i +j; fourSum.put(sum, fourSum.getOrDefault(sum,0)+1); } } for(int k : nums3){ for(int l : nums4){ count += fourSum.getOrDefault((0-(k+l)), 0); } } return count; } } // @lc code=end ","date":"2024-05-11T00:00:00Z","image":"https://kris0325.github.io/p/454.-4sum-ii/454_hua62bcbcf9a79dfe26d0875c8d67438b3_7993144_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/454.-4sum-ii/","title":"454. 4Sum II"},{"content":"https://leetcode.com/problems/happy-number/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 Happy Number Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (56.07%)\t10182\t1411 Tags hash-table | math Companies airbnb | twitter | uber Write an algorithm to determine if a number n is happy. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy. Return true if n is a happy number, and false if not. Example 1: Input: n = 19 Output: true Explanation: 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 Example 2: Input: n = 2 Output: false 1 2 3 4 5 6 7 /* * æ€è·¯ï¼šå“ˆå¸Œè¡¨ or it loops endlessly in a cycle which does not include 1, å³è¡¨æ˜n is happyæ—¶, ç„¡é™å¾ªç’°ï¼Œé‚£éº¼å¯ä»¥æ¨æ–·ï¼Œåªè¦ç´€éŒ„æ¯æ¬¡å¾ªç’°çš„sumï¼Œç¸½æœ‰sumæœƒç™¼ç”Ÿé‡è¤‡ï¼Œ å› æ­¤å¯ä»¥ä½¿ç”¨hashsetæ”¶é›†æ¯æ¬¡å¾ªç’°çš„sumï¼Œç„¶å¾Œåˆ¤æ–·æ˜¯å¦å­˜åœ¨é‡è¤‡çš„å€¼ * */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // @lc code=start import java.util.HashSet; class Solution { public boolean isHappy(int n) { HashSet\u0026lt;Integer\u0026gt; sumsSet = new HashSet\u0026lt;\u0026gt;(); // ishappy n == 1 , is not happy, sumæœƒé‡è¤‡å³ sumsSet.contains(n)ï¼Œè·³å‡º while (n != 1 \u0026amp;\u0026amp; !sumsSet.contains(n)) { sumsSet.add(n); n = getSum(n); } return n == 1; } int getSum(int n){ int sum = 0; while (n \u0026gt; 0) { //å…ˆç²å–æœ€å·¦é‚Šä½ä½æ•¸å€¼ int low = n % 10; sum += low *low; //å»æ‰æœ€å·¦é‚Šä½ä½æ•¸å€¼ n = n / 10; } return sum; } } // @lc code=end ","date":"2024-05-10T00:00:00Z","image":"https://kris0325.github.io/p/202.-happy-number/202_hua62bcbcf9a79dfe26d0875c8d67438b3_9400923_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/202.-happy-number/","title":"202. Happy Number"},{"content":" https://leetcode.com/problems/intersection-of-two-arrays/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Intersection of Two Arrays Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (74.44%)\t5958\t2289 Tags hash-table | two-pointers | binary-search | sort Companies twosigma Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2] Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4] Explanation: [4,9] is also accepted. Constraints: 1 \u0026lt;= nums1.length, nums2.length \u0026lt;= 1000 0 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 1000 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* æ€è·¯ï¼šå“ˆå¸Œè¡¨ ä½¿ç”¨hashsetå­˜nums1çš„å…ƒç´ , å†éå†nums2æ”¶é›†intersection * */ // @lc code=start import java.util.ArrayList; import java.util.HashSet; class Solution { public int[] intersection(int[] nums1, int[] nums2) { HashSet\u0026lt;Integer\u0026gt; setNums1 = new HashSet\u0026lt;\u0026gt;(); HashSet\u0026lt;Integer\u0026gt; setNums = new HashSet\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt; nums1.length ; i++){ setNums1.add(nums1[i]); } for(int i = 0; i \u0026lt; nums2.length; i++){ if (setNums1.contains(nums2[i])) { setNums.add(nums2[i]); } } // int [] nums = new int[setNums.size()]; // int index = 0; // for (int num : setNums) { // nums[index++] = num; // } // return nums; return setNums.stream().mapToInt(i -\u0026gt; i).toArray(); } } // @lc code=end ","date":"2024-05-10T00:00:00Z","image":"https://kris0325.github.io/p/349.-intersection-of-two-arrays/349_hu8e35c18113cfb820c0efc87111a50e50_9589620_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/349.-intersection-of-two-arrays/","title":"349. Intersection of Two Arrays"},{"content":"https://leetcode.com/problems/valid-anagram/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (64.48%)\t11937\t394 Tags hash-table | sort Companies amazon | uber | yelp Given two strings s and t, return true if t is an anagram of s, and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Example 1: Input: s = \u0026#34;anagram\u0026#34;, t = \u0026#34;nagaram\u0026#34; Output: true Example 2: Input: s = \u0026#34;rat\u0026#34;, t = \u0026#34;car\u0026#34; Output: false Constraints: 1 \u0026lt;= s.length, t.length \u0026lt;= 5 * 104 s and t consist of lowercase English letters. Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case? /* æ€è·¯ï¼šå“ˆå¸Œè¡¨ * å¼‚ä½è¯ï¼Œå³ä¸¤ä¸ªå•è¯/çŸ­è¯­s1, s2äº’ä¸ºé‡æ’ï¼Œå…¶å……è¦æ¡ä»¶æ˜¯ * 1å­—ç¬¦ä¸²çš„å­—ç¬¦æ€»æ•°é‡ï¼Œ * 2ä»¥åŠæ¯ä¸ªå­—ç¬¦å¯¹åº”çš„æ•°é‡ç›¸åŒã€‚ * å› æ­¤å¯ä»¥ä½¿ç”¨å“ˆå¸Œè¡¨åˆ†åˆ«ç»Ÿè®¡å­—ç¬¦ä¸²ä¸­å„ä¸ªå­—ç¬¦æ•°é‡ key:å­—ç¬¦ï¼Œvalue:æ•°é‡ï¼Œ * ç»Ÿè®¡s1æ—¶ï¼Œvalue+1ï¼Œ ç»Ÿè®¡s2æ—¶value-1ï¼Œ * å½“æœ€ç»ˆå“ˆå¸Œè¡¨ä¸­æ‰€æœ‰å­—ç¬¦å¯¹åº”çš„ç»Ÿè®¡æ•°å€¼ä¸º0ï¼Œåˆ™äº’ä¸ºé‡æ’ã€‚ */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // @lc code=start import java.util.HashMap; class Solution { public boolean isAnagram(String s, String t) { HashMap\u0026lt;Character, Integer\u0026gt; dic = new HashMap\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt;s.length(); i++){ dic.put(s.charAt(i), dic.getOrDefault(s.charAt(i), 0)+1); } for(int i = 0; i \u0026lt; t.length(); i++){ dic.put(t.charAt(i), dic.getOrDefault(t.charAt(i), 0)-1); } for(int val : dic.values()){ if(val !=0){ return false; } } return true; } } // @lc code=end ","date":"2024-05-09T00:00:00Z","image":"https://kris0325.github.io/p/242.-valid-anagram/242_hua62bcbcf9a79dfe26d0875c8d67438b3_3686299_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/242.-valid-anagram/","title":"242. Valid Anagram"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 /* * @lc app=leetcode id=142 lang=java * * [142] Linked List Cycle II * * https://leetcode.com/problems/linked-list-cycle-ii/description/ * * algorithms * Medium (51.25%) * Likes: 13392 * Dislikes: 937 * Total Accepted: 1.3M * Total Submissions: 2.5M * Testcase Example: \u0026#39;[3,2,0,-4]\\n1\u0026#39; * * Given the head of a linked list, return the node where the cycle begins. If * there is no cycle, return null. * * There is a cycle in a linked list if there is some node in the list that can * be reached again by continuously following the next pointer. Internally, pos * is used to denote the index of the node that tail\u0026#39;s next pointer is * connected to (0-indexed). It is -1 if there is no cycle. Note that pos is * not passed as a parameter. * * Do not modify the linked list. * * * Example 1: * * * Input: head = [3,2,0,-4], pos = 1 * Output: tail connects to node index 1 * Explanation: There is a cycle in the linked list, where tail connects to the * second node. * * * Example 2: * * * Input: head = [1,2], pos = 0 * Output: tail connects to node index 0 * Explanation: There is a cycle in the linked list, where tail connects to the * first node. * * * Example 3: * * * Input: head = [1], pos = -1 * Output: no cycle * Explanation: There is no cycle in the linked list. * * * * Constraints: * * * The number of the nodes in the list is in the range [0, 10^4]. * -10^5 \u0026lt;= Node.val \u0026lt;= 10^5 * pos is -1 or a valid index in the linked-list. * * * * Follow up: Can you solve it using O(1) (i.e. constant) memory? * */ // @lc code=start /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } * * æ€è·¯ï¼šä½¿ç”¨å¼—æ´›ä¼Šå¾·åˆ¤åœˆç®—æ³•ï¼Œå³å¿«æ…¢æŒ‡é‡ï¼Œ * ç•«åœ–è¼”åŠ©ï¼Œ * 1è‹¥å¿«æ…¢æŒ‡é‡èƒ½ç›¸é‡ï¼Œå‰‡å­˜åœ¨ç’°ï¼Œ * 2ç„¶å¾Œè¨­ç½®2å€‹æ–°æŒ‡é‡ï¼Œä¸€å€‹å¾é ­ç¯€é»é–‹å§‹ï¼Œå¦ä¸€å€‹æŒ‡é‡å¾ç›¸é‡ç¯€é»é–‹å§‹ï¼Œç•¶å…©æŒ‡é‡ç›¸é‡è™•å³ç‚ºç’°çš„å…¥å£ç¯€é» * å† * * ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆæ£€æµ‹é“¾è¡¨ä¸­å¾ªç¯çš„åŸç†æ˜¯ä¸€ç§å¸¸è§ä¸”é«˜æ•ˆçš„ç®—æ³•ï¼Œä¹Ÿè¢«ç§°ä¸ºFloyd\u0026#39;s Tortoise and Hare Algorithmï¼ˆå¼—æ´›ä¼Šå¾·çš„ä¹Œé¾Ÿå’Œå…”å­ç®—æ³•ï¼‰ã€‚è¿™ç§ç®—æ³•é€šè¿‡ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸€ä¸ªå¿«æŒ‡é’ˆå’Œä¸€ä¸ªæ…¢æŒ‡é’ˆï¼Œæ¥æ£€æµ‹é“¾è¡¨ä¸­æ˜¯å¦å­˜åœ¨å¾ªç¯ï¼Œå¹¶æ‰¾åˆ°å¾ªç¯çš„èµ·å§‹èŠ‚ç‚¹ã€‚ å¿«æ…¢æŒ‡é’ˆçš„åŸç†æ˜¯ï¼Œå¿«æŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨ä¸€æ­¥ã€‚å¦‚æœé“¾è¡¨ä¸­å­˜åœ¨å¾ªç¯ï¼Œå¿«æŒ‡é’ˆæœ€ç»ˆä¼šè¿½ä¸Šæ…¢æŒ‡é’ˆã€‚è¿™æ˜¯å› ä¸ºå¿«æŒ‡é’ˆçš„é€Ÿåº¦æ˜¯æ…¢æŒ‡é’ˆçš„ä¸¤å€ï¼Œæ‰€ä»¥åœ¨å¾ªç¯ä¸­ï¼Œå¿«æŒ‡é’ˆä¼šç»•åœˆè¿½èµ¶æ…¢æŒ‡é’ˆï¼Œæœ€ç»ˆç›¸é‡ã€‚ å½“å¿«æ…¢æŒ‡é’ˆç›¸é‡æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å¾—å‡ºä»¥ä¸‹ç»“è®ºï¼š é“¾è¡¨ä¸­å­˜åœ¨å¾ªç¯ã€‚ é€šè¿‡æ•°å­¦æ¨å¯¼ï¼Œå¯ä»¥ç¡®å®šé“¾è¡¨ä¸­å¾ªç¯çš„èµ·å§‹èŠ‚ç‚¹ã€‚ å…·ä½“æ¥è¯´ï¼Œå‡è®¾é“¾è¡¨å¤´åˆ°å¾ªç¯èµ·å§‹èŠ‚ç‚¹çš„è·ç¦»ä¸ºAï¼Œå¾ªç¯èµ·å§‹èŠ‚ç‚¹åˆ°å¿«æ…¢æŒ‡é’ˆç›¸é‡ç‚¹çš„è·ç¦»ä¸ºBã€‚æ ¹æ®å¿«æ…¢æŒ‡é’ˆçš„ç§»åŠ¨è§„å¾‹ï¼Œå¯ä»¥å¾—å‡ºä»¥ä¸‹ç­‰å¼ï¼šå¿«æŒ‡é’ˆèµ°è¿‡çš„è·ç¦» = 2 * æ…¢æŒ‡é’ˆèµ°è¿‡çš„è·ç¦»ã€‚æ ¹æ®è¿™ä¸ªç­‰å¼ï¼Œå¯ä»¥æ¨å¯¼å‡ºA = Cï¼Œå³é“¾è¡¨å¤´åˆ°å¾ªç¯èµ·å§‹èŠ‚ç‚¹çš„è·ç¦»ç­‰äºç›¸é‡ç‚¹åˆ°å¾ªç¯èµ·å§‹èŠ‚ç‚¹çš„è·ç¦»ã€‚ å› æ­¤ï¼Œå½“å¿«æ…¢æŒ‡é’ˆç›¸é‡åï¼Œæˆ‘ä»¬å¯ä»¥è®¾ç½®ä¸€ä¸ªæ–°çš„æŒ‡é’ˆä»é“¾è¡¨å¤´å¼€å§‹ï¼Œä¸ç›¸é‡ç‚¹çš„æŒ‡é’ˆåŒæ—¶ç§»åŠ¨ï¼Œå®ƒä»¬ç›¸é‡çš„èŠ‚ç‚¹å°±æ˜¯å¾ªç¯çš„èµ·å§‹èŠ‚ç‚¹ã€‚ é€šè¿‡è¿™ç§æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥é«˜æ•ˆåœ°æ£€æµ‹é“¾è¡¨ä¸­çš„å¾ªç¯ï¼Œå¹¶æ‰¾åˆ°å¾ªç¯çš„èµ·å§‹èŠ‚ç‚¹ï¼Œè€Œä¸”ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(N)ï¼Œç©ºé—´å¤æ‚åº¦ä¸ºO(1)ã€‚ */ public class Solution { public ListNode detectCycle(ListNode head) { ListNode fast = head; ListNode slow = head; //éœ€è¦ç¡®ä¿å¿«æŒ‡é’ˆèˆ‡å¿«æŒ‡é‡çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸ä¸ºç©ºï¼Œä»¥é¿å…ç©ºæŒ‡é’ˆå¼‚å¸¸ while (fast != null \u0026amp;\u0026amp; fast.next !=null) { fast = fast.next.next; slow = slow.next; //ç›¸é‡å‰‡å­˜åœ¨ç’° if(slow == fast){ ListNode index1 = fast; //åœ¨æ£€æµ‹åˆ°å¿«æ…¢æŒ‡é’ˆç›¸é‡æ—¶ï¼Œéœ€è¦é‡æ–°è®¾ç½®ä¸€ä¸ªæ–°çš„æŒ‡é’ˆä»å¤´èŠ‚ç‚¹å¼€å§‹ï¼Œä»¥æ‰¾åˆ°å¾ªç¯çš„å…¥å£ç‚¹ ListNode index2 = head; while (index1 != index2) { index1 = index1.next; index2 = index2.next; } //index1èˆ‡index2åœ¨ç’°çš„å…¥å£è™•ç›¸é‡ return index1; } } return null; } } // @lc code=end ","date":"2024-05-07T00:00:00Z","image":"https://kris0325.github.io/p/142.-linked-list-cycle-ii/142_hua62bcbcf9a79dfe26d0875c8d67438b3_10854839_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/142.-linked-list-cycle-ii/","title":"142. Linked List Cycle II"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 /* * @lc app=leetcode id=19 lang=java * * [19] Remove Nth Node From End of List * * https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/ * * algorithms * Medium (45.25%) * Likes: 18583 * Dislikes: 785 * Total Accepted: 2.7M * Total Submissions: 6M * Testcase Example: \u0026#39;[1,2,3,4,5]\\n2\u0026#39; * * Given the head of a linked list, remove the n^th node from the end of the * list and return its head. * * * Example 1: * * * Input: head = [1,2,3,4,5], n = 2 * Output: [1,2,3,5] * * * Example 2: * * * Input: head = [1], n = 1 * Output: [] * * * Example 3: * * * Input: head = [1,2], n = 1 * Output: [1] * * * * Constraints: * * * The number of nodes in the list is sz. * 1 \u0026lt;= sz \u0026lt;= 30 * 0 \u0026lt;= Node.val \u0026lt;= 100 * 1 \u0026lt;= n \u0026lt;= sz * * * * Follow up: Could you do this in one pass? * */ // @lc code=start /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } * * æ€è·¯ï¼šå¿«æ…¢æŒ‡é’ˆ * å¿«æŒ‡é’ˆå…ˆèµ°æ­¥é•¿nï¼Œç„¶åæ…¢æŒ‡é’ˆåèµ°ï¼Œå½“å¿«æŒ‡é’ˆèµ°åˆ°æœ«å°¾ï¼Œ * æ…¢æŒ‡é’ˆå³æŒ‡å‘å€’æ•°ç¬¬nä¸ªèŠ‚ç‚¹the n^th node from the end of the. * æ³¨æ„ï¼šé‚Šç•Œæ¢ä»¶ * * solutionå„ªåŒ–ï¼šä½¿ç”¨è™›æ“¬å¤´ç¯€é»dumyNodeæ›´æ–¹ä¾¿ï¼Œå¯ä»¥è¦†è“‹é‚Šç•Œæ¢ä»¶ï¼Œä¸ç”¨ç‰¹æ®Šè€ƒæ…® * * * * * * * listï¼Œremoveå³å¯ */ class Solution1 { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode fast = head; ListNode slow = head; //specil case: only one node if(slow.next == null){ return null; } for(int i = 0; i \u0026lt;n; i++){ fast = fast.next; } //specil case: when n == size of the list, the fast pointer is null, it means we need remove the head node if(fast == null){ return head.next; } while (fast.next != null) { fast = fast.next; slow = slow.next; } //At this point, the slow pointer is n nodes behind the fast pointer //, which means it\u0026#39;s pointing to the node just before the node we want to remove. //delete the n^th node from the end of the list slow.next = slow.next.next; return head; } } class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { //æ–°å»ºä¸€ä¸ªè™šæ‹Ÿå¤´èŠ‚ç‚¹æŒ‡å‘head ListNode dummyNode = new ListNode(0); dummyNode.next = head; //å¿«æ…¢æŒ‡é’ˆæŒ‡å‘è™šæ‹Ÿå¤´èŠ‚ç‚¹ ListNode fastIndex = dummyNode; ListNode slowIndex = dummyNode; // åªè¦å¿«æ…¢æŒ‡é’ˆç›¸å·® n ä¸ªç»“ç‚¹å³å¯ for (int i = 0; i \u0026lt;= n; i++) { fastIndex = fastIndex.next; } while (fastIndex != null) { fastIndex = fastIndex.next; slowIndex = slowIndex.next; } // æ­¤æ—¶ slowIndex çš„ä½ç½®å°±æ˜¯å¾…åˆ é™¤å…ƒç´ çš„å‰ä¸€ä¸ªä½ç½®ã€‚ // å…·ä½“æƒ…å†µå¯è‡ªå·±ç”»ä¸€ä¸ªé“¾è¡¨é•¿åº¦ä¸º 3 çš„å›¾æ¥æ¨¡æ‹Ÿä»£ç æ¥ç†è§£ // æ£€æŸ¥ slowIndex.next æ˜¯å¦ä¸º nullï¼Œä»¥é¿å…ç©ºæŒ‡é’ˆå¼‚å¸¸ if (slowIndex.next != null) { slowIndex.next = slowIndex.next.next; } return dummyNode.next; } } // @lc code=end ","date":"2024-05-06T00:00:00Z","image":"https://kris0325.github.io/p/19.-remove-nth-node-from-end-of-list/19_hua62bcbcf9a79dfe26d0875c8d67438b3_13769621_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/19.-remove-nth-node-from-end-of-list/","title":"19. Remove Nth Node From End of List"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 /* * @lc app=leetcode id=160 lang=java * * [160] Intersection of Two Linked Lists * * https://leetcode.com/problems/intersection-of-two-linked-lists/description/ * * algorithms * Easy (57.40%) * Likes: 14737 * Dislikes: 1327 * Total Accepted: 1.5M * Total Submissions: 2.7M * Testcase Example: \u0026#39;8\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n2\\n3\u0026#39; * * Given the heads of two singly linked-lists headA and headB, return the node * at which the two lists intersect. If the two linked lists have no * intersection at all, return null. * * For example, the following two linked lists begin to intersect at node c1: * * The test cases are generated such that there are no cycles anywhere in the * entire linked structure. * * Note that the linked lists must retain their original structure after the * function returns. * * Custom Judge: * * The inputs to the judge are given as follows (your program is not given * these inputs): * * * intersectVal - The value of the node where the intersection occurs. This is * 0 if there is no intersected node. * listA - The first linked list. * listB - The second linked list. * skipA - The number of nodes to skip ahead in listA (starting from the head) * to get to the intersected node. * skipB - The number of nodes to skip ahead in listB (starting from the head) * to get to the intersected node. * * * The judge will then create the linked structure based on these inputs and * pass the two heads, headA and headB to your program. If you correctly return * the intersected node, then your solution will be accepted. * * * Example 1: * * * Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = * 2, skipB = 3 * Output: Intersected at \u0026#39;8\u0026#39; * Explanation: The intersected node\u0026#39;s value is 8 (note that this must not be 0 * if the two lists intersect). * From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as * [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are * 3 nodes before the intersected node in B. * - Note that the intersected node\u0026#39;s value is not 1 because the nodes with * value 1 in A and B (2^nd node in A and 3^rd node in B) are different node * references. In other words, they point to two different locations in memory, * while the nodes with value 8 in A and B (3^rd node in A and 4^th node in B) * point to the same location in memory. * * * Example 2: * * * Input: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, * skipB = 1 * Output: Intersected at \u0026#39;2\u0026#39; * Explanation: The intersected node\u0026#39;s value is 2 (note that this must not be 0 * if the two lists intersect). * From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as * [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 * node before the intersected node in B. * * * Example 3: * * * Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = * 2 * Output: No intersection * Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it * reads as [1,5]. Since the two lists do not intersect, intersectVal must be * 0, while skipA and skipB can be arbitrary values. * Explanation: The two lists do not intersect, so return null. * * * * Constraints: * * * The number of nodes of listA is in the m. * The number of nodes of listB is in the n. * 1 \u0026lt;= m, n \u0026lt;= 3 * 10^4 * 1 \u0026lt;= Node.val \u0026lt;= 10^5 * 0 \u0026lt;= skipA \u0026lt;Â m * 0 \u0026lt;= skipB \u0026lt;Â n * intersectVal is 0 if listA and listB do not intersect. * intersectVal == listA[skipA] == listB[skipB] if listA and listB * intersect. * * * * Follow up: Could you write a solution that runs in O(m + n) time and use * only O(1) memory? */ // @lc code=start /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } * * æ€è·¯1ï¼šä¸¤ä¸ªé“¾è¡¨è‹¥æœ‰äº¤ç‚¹ï¼Œä»é“¾è¡¨æœ«å°¾å‘å‰çœ‹ï¼Œå¿…æœ‰ä¸€æ®µå…¬å…±èŠ‚ç‚¹ï¼Œå› æ­¤ï¼Œ * å…ˆæ±‚å‡º2ä¸ªé“¾è¡¨é•¿åº¦å·®gap, é•¿é“¾è¡¨æŒ‡é’ˆå…ˆèµ°gapæ­¥é•¿ï¼Œç›´åˆ°é•¿çŸ­ä¸¤ä¸ªé“¾è¡¨ä½ç½®å¯¹é½ï¼Œ * åŒæ—¶ç§»åŠ¨é•¿çŸ­é“¾è¡¨çš„æŒ‡é’ˆï¼Œç›´åˆ°ä¸¤ä¸ªæŒ‡é’ˆç›¸ç­‰ï¼Œreturnï¼Œ * å¦åˆ™return null * */ // public class Solution { // public ListNode getIntersectionNode(ListNode headA, ListNode headB) { // int lenA =0; // int lenB =0; // ListNode nodeA = headA; // ListNode nodeB = headB; // while (nodeA != null) { // nodeA = nodeA.next; // lenA +=1; // } // while (nodeB != null) { // nodeB = nodeB.next; // lenB +=1; // } // nodeA = headA; // nodeB = headB; // if(lenB \u0026gt; lenA){ // int tmplen = lenA; // lenA = lenB; // lenB = tmplen; // ListNode nodetmp = nodeA; // nodeA = nodeB; // nodeB = nodetmp; // } // int gap = lenA -lenB; // while (gap-- \u0026gt; 0) { // nodeA = nodeA.next; // } // while (nodeA != null) { // if(nodeA == nodeB){ // return nodeA; // } // nodeA = nodeA.next; // nodeB = nodeB.next; // } // return null; // } // } /* æ€è·¯2ï¼šåˆå¹¶é“¾è¡¨ï¼ŒåŒæ­¥ç§»åŠ¨æŒ‡é’ˆå¯»æ‰¾å…¬å…±èŠ‚ç‚¹ æœ¬è´¨ä¸Šå’Œæ€è·¯1æ˜¯ä¸€æ ·çš„ï¼Œå°±æ˜¯æŒ‡å‘çŸ­é“¾è¡¨çš„å¿«æŒ‡é’ˆå…ˆèµ°ï¼Œ ç›´åˆ°èµ°å®Œï¼ˆä¸¤ä¸ªé“¾è¡¨é•¿åº¦ä¹‹å·®ï¼‰gapæ­¥é•¿åï¼Œ è¿™æ—¶å¿«æ…¢æŒ‡é’ˆåŒæ­¥ç§»åŠ¨ï¼Œå†å¯»æ‰¾å…¬å…±èŠ‚ç‚¹ * * */ public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode pA = headA; ListNode pB = headB; while(pA != pB){ if(pA == null){ //æŒ‡é’ˆpAèµ°ä¸€æ­¥ï¼Œç›´åˆ°èµ°åˆ°aé“¾è¡¨æœ«å°¾ï¼Œåˆ™è½¬åˆ°bé“¾è¡¨ pA = headB; } else { pA = pA.next; } //æŒ‡é’ˆpBèµ°ä¸€æ­¥ï¼Œç›´åˆ°èµ°åˆ°Bé“¾è¡¨æœ«å°¾ï¼Œåˆ™è½¬åˆ°Aé“¾è¡¨ if(pB == null){ pB = headA; } else{ pB = pB.next; } } return pA; } } // @lc code=end ","date":"2024-05-03T00:00:00Z","image":"https://kris0325.github.io/p/160.-intersection-of-two-linked-lists/160_hua62bcbcf9a79dfe26d0875c8d67438b3_9016474_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/160.-intersection-of-two-linked-lists/","title":"160. Intersection of Two Linked Lists"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 /* * @lc app=leetcode id=24 lang=java * * [24] Swap Nodes in Pairs * * https://leetcode.com/problems/swap-nodes-in-pairs/description/ * * algorithms * Medium (64.32%) * Likes: 11816 * Dislikes: 436 * Total Accepted: 1.4M * Total Submissions: 2.1M * Testcase Example: \u0026#39;[1,2,3,4]\u0026#39; * * Given aÂ linked list, swap every two adjacent nodes and return its head. You * must solve the problem withoutÂ modifying the values in the list\u0026#39;s nodes * (i.e., only nodes themselves may be changed.) * * * Example 1: * * * Input: head = [1,2,3,4] * Output: [2,1,4,3] * * * Example 2: * * * Input: head = [] * Output: [] * * * Example 3: * * * Input: head = [1] * Output: [1] * * * * Constraints: * * * The number of nodes in theÂ listÂ is in the range [0, 100]. * 0 \u0026lt;= Node.val \u0026lt;= 100 * * */ // @lc code=start /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } æ€è·¯ï¼šæ­£å¸¸æ¨¡æ‹Ÿå°±è¡Œï¼Œæ³¨æ„æ–­å¼€æŒ‡é’ˆçš„é¡ºåº */ class Solution { public ListNode swapPairs(ListNode head) { //è®¾ç½®ä¸€ä¸ªè™šæ‹Ÿå¤´èŠ‚ç‚¹ ListNode dumyHead = new ListNode(0); //å°†è™šæ‹Ÿå¤´ç»“ç‚¹æŒ‡å‘headï¼Œè¿™æ ·æ–¹ä¾¿åé¢æ“ä½œ dumyHead.next = head; ListNode cur = dumyHead; //ä¸´æ—¶èŠ‚ç‚¹ï¼Œä¿å­˜ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹ä¸­çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ ListNode firstNode ; // ä¸´æ—¶èŠ‚ç‚¹ï¼Œä¿å­˜ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹ä¸­çš„ç¬¬äºŒä¸ªèŠ‚ç‚¹ ListNode secondeNode ; while (cur.next != null \u0026amp;\u0026amp; cur.next.next != null) { // tmpNode = cur.next.next.next; firstNode = cur.next; secondeNode = cur.next.next; //1 curæŒ‡é’ˆnextæŒ‡å‘ç¬¬2ä¸ªèŠ‚ç‚¹ cur.next = secondeNode; //2 ç¬¬ä¸€ä¸ªèŠ‚ç‚¹æŒ‡é’ˆnextæŒ‡å‘ç¬¬ä¸‰ä¸ªèŠ‚ç‚¹ firstNode.next = secondeNode.next; //3 ç¬¬äºŒä¸ªèŠ‚ç‚¹æŒ‡é’ˆnextæŒ‡å‘ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ secondeNode.next = firstNode; //ç§»åŠ¨curæŒ‡é’ˆï¼Œå‡†å¤‡ä¸‹ä¸€è½®äº¤æ¢ cur = cur.next.next; } return dumyHead.next; } } // @lc code=end ","date":"2024-05-03T00:00:00Z","image":"https://kris0325.github.io/p/24.-swap-nodes-in-pairs/24_hua62bcbcf9a79dfe26d0875c8d67438b3_9882202_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/24.-swap-nodes-in-pairs/","title":"24. Swap Nodes in Pairs"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 /* * @lc app=leetcode.cn id=707 lang=java * * [707] è®¾è®¡é“¾è¡¨ * * https://leetcode.cn/problems/design-linked-list/description/ * * algorithms * Medium (34.47%) * Likes: 1013 * Dislikes: 0 * Total Accepted: 302.8K * Total Submissions: 879.7K * Testcase Example: \u0026#39;[\u0026#34;MyLinkedList\u0026#34;,\u0026#34;addAtHead\u0026#34;,\u0026#34;addAtTail\u0026#34;,\u0026#34;addAtIndex\u0026#34;,\u0026#34;get\u0026#34;,\u0026#34;deleteAtIndex\u0026#34;,\u0026#34;get\u0026#34;]\\n\u0026#39; + \u0026#39;[[],[1],[3],[1,2],[1],[1],[1]]\u0026#39; * * ä½ å¯ä»¥é€‰æ‹©ä½¿ç”¨å•é“¾è¡¨æˆ–è€…åŒé“¾è¡¨ï¼Œè®¾è®¡å¹¶å®ç°è‡ªå·±çš„é“¾è¡¨ã€‚ * * å•é“¾è¡¨ä¸­çš„èŠ‚ç‚¹åº”è¯¥å…·å¤‡ä¸¤ä¸ªå±æ€§ï¼šval å’Œ next ã€‚val æ˜¯å½“å‰èŠ‚ç‚¹çš„å€¼ï¼Œnext æ˜¯æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ/å¼•ç”¨ã€‚ * * å¦‚æœæ˜¯åŒå‘é“¾è¡¨ï¼Œåˆ™è¿˜éœ€è¦å±æ€§Â prevÂ ä»¥æŒ‡ç¤ºé“¾è¡¨ä¸­çš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹ã€‚å‡è®¾é“¾è¡¨ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹ä¸‹æ ‡ä» 0 å¼€å§‹ã€‚ * * å®ç° MyLinkedList ç±»ï¼š * * * MyLinkedList() åˆå§‹åŒ– MyLinkedList å¯¹è±¡ã€‚ * int get(int index) è·å–é“¾è¡¨ä¸­ä¸‹æ ‡ä¸º index çš„èŠ‚ç‚¹çš„å€¼ã€‚å¦‚æœä¸‹æ ‡æ— æ•ˆï¼Œåˆ™è¿”å› -1 ã€‚ * void addAtHead(int val) å°†ä¸€ä¸ªå€¼ä¸º val * çš„èŠ‚ç‚¹æ’å…¥åˆ°é“¾è¡¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰ã€‚åœ¨æ’å…¥å®Œæˆåï¼Œæ–°èŠ‚ç‚¹ä¼šæˆä¸ºé“¾è¡¨çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ * void addAtTail(int val) å°†ä¸€ä¸ªå€¼ä¸º val çš„èŠ‚ç‚¹è¿½åŠ åˆ°é“¾è¡¨ä¸­ä½œä¸ºé“¾è¡¨çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚ * void addAtIndex(int index, int val) å°†ä¸€ä¸ªå€¼ä¸º val çš„èŠ‚ç‚¹æ’å…¥åˆ°é“¾è¡¨ä¸­ä¸‹æ ‡ä¸º index çš„èŠ‚ç‚¹ä¹‹å‰ã€‚å¦‚æœ * index ç­‰äºé“¾è¡¨çš„é•¿åº¦ï¼Œé‚£ä¹ˆè¯¥èŠ‚ç‚¹ä¼šè¢«è¿½åŠ åˆ°é“¾è¡¨çš„æœ«å°¾ã€‚å¦‚æœ index æ¯”é•¿åº¦æ›´å¤§ï¼Œè¯¥èŠ‚ç‚¹å°† ä¸ä¼šæ’å…¥ åˆ°é“¾è¡¨ä¸­ã€‚ * void deleteAtIndex(int index) å¦‚æœä¸‹æ ‡æœ‰æ•ˆï¼Œåˆ™åˆ é™¤é“¾è¡¨ä¸­ä¸‹æ ‡ä¸º index çš„èŠ‚ç‚¹ã€‚ * * * * * ç¤ºä¾‹ï¼š * * * è¾“å…¥ * [\u0026#34;MyLinkedList\u0026#34;, \u0026#34;addAtHead\u0026#34;, \u0026#34;addAtTail\u0026#34;, \u0026#34;addAtIndex\u0026#34;, \u0026#34;get\u0026#34;, * \u0026#34;deleteAtIndex\u0026#34;, \u0026#34;get\u0026#34;] * [[], [1], [3], [1, 2], [1], [1], [1]] * è¾“å‡º * [null, null, null, null, 2, null, 3] * * è§£é‡Š * MyLinkedList myLinkedList = new MyLinkedList(); * myLinkedList.addAtHead(1); * myLinkedList.addAtTail(3); * myLinkedList.addAtIndex(1, 2); // é“¾è¡¨å˜ä¸º 1-\u0026gt;2-\u0026gt;3 * myLinkedList.get(1); // è¿”å› 2 * myLinkedList.deleteAtIndex(1); // ç°åœ¨ï¼Œé“¾è¡¨å˜ä¸º 1-\u0026gt;3 * myLinkedList.get(1); // è¿”å› 3 * * * * * æç¤ºï¼š * * * 0 \u0026lt;= index, val \u0026lt;= 1000 * è¯·ä¸è¦ä½¿ç”¨å†…ç½®çš„ LinkedList åº“ã€‚ * è°ƒç”¨ getã€addAtHeadã€addAtTailã€addAtIndex å’Œ deleteAtIndex çš„æ¬¡æ•°ä¸è¶…è¿‡ 2000 ã€‚ * * */ // @lc code=start class ListNode { int val; ListNode next; ListNode(){}; ListNode(int val){ this.val = val; }; } class MyLinkedList { int size; ListNode head; public MyLinkedList() { size = 0; head = new ListNode(0); } public int get(int index) { if(index \u0026lt; 0 || index \u0026gt;= size){ return -1; } ListNode cur = head; for(int i = 0; i \u0026lt;= index; i++){ cur = cur.next; } return cur.val; } public void addAtHead(int val) { addAtIndex(0, val); } public void addAtTail(int val) { addAtIndex(size, val); } public void addAtIndex(int index, int val) { if(index \u0026gt; size){ return; } if(index \u0026lt; 0){ index = 0; } size++; //å¯»æ‰¾åˆ°è¦æ’å…¥èŠ‚ç‚¹çš„å‰é©± ListNode pre = head; for(int i = 0; i\u0026lt;index; i++){ pre = pre.next; } ListNode target = new ListNode(val); target.next = pre.next; pre.next = target; } //åˆ é™¤ç¬¬indexèŠ‚ç‚¹ public void deleteAtIndex(int index) { if(index \u0026gt;= size || index \u0026lt;0){ return; } size--; ListNode pre = head; for(int i =0; i\u0026lt;index;i++ ){ pre = pre.next; } pre.next = pre.next.next; } } /** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList obj = new MyLinkedList(); * int param_1 = obj.get(index); * obj.addAtHead(val); * obj.addAtTail(val); * obj.addAtIndex(index,val); * obj.deleteAtIndex(index); */ // @lc code=end ","date":"2024-04-14T00:00:00Z","image":"https://kris0325.github.io/p/707.-design-linked-list/707_hu5477be140e37c38e9e48439fae2f6b6b_3708872_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/707.-design-linked-list/","title":"707. Design Linked List"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 /* * @lc app=leetcode.cn id=206 lang=java * * [206] åè½¬é“¾è¡¨ * * https://leetcode.cn/problems/reverse-linked-list/description/ * * algorithms * Easy (74.06%) * Likes: 3545 * Dislikes: 0 * Total Accepted: 1.8M * Total Submissions: 2.5M * Testcase Example: \u0026#39;[1,2,3,4,5]\u0026#39; * * ç»™ä½ å•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ head ï¼Œè¯·ä½ åè½¬é“¾è¡¨ï¼Œå¹¶è¿”å›åè½¬åçš„é“¾è¡¨ã€‚ * * * * * ç¤ºä¾‹ 1ï¼š * * * è¾“å…¥ï¼šhead = [1,2,3,4,5] * è¾“å‡ºï¼š[5,4,3,2,1] * * * ç¤ºä¾‹ 2ï¼š * * * è¾“å…¥ï¼šhead = [1,2] * è¾“å‡ºï¼š[2,1] * * * ç¤ºä¾‹ 3ï¼š * * * è¾“å…¥ï¼šhead = [] * è¾“å‡ºï¼š[] * * * * * æç¤ºï¼š * * * é“¾è¡¨ä¸­èŠ‚ç‚¹çš„æ•°ç›®èŒƒå›´æ˜¯ [0, 5000] * -5000 * * * * * è¿›é˜¶ï¼šé“¾è¡¨å¯ä»¥é€‰ç”¨è¿­ä»£æˆ–é€’å½’æ–¹å¼å®Œæˆåè½¬ã€‚ä½ èƒ½å¦ç”¨ä¸¤ç§æ–¹æ³•è§£å†³è¿™é“é¢˜ï¼Ÿ * * * */ // @lc code=start /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } * * æ€è·¯ï¼šåŒæŒ‡é’ˆï¼Œè¿­ä»£ç¿»è½¬é“¾è¡¨ */ class Solution { public ListNode reverseList(ListNode head) { ListNode pre = null; ListNode cur = head; while (cur!= null) { //ä¿å­˜ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ ListNode tmp = cur.next; //ç¿»è½¬æ“ä½œï¼Œå³æ–­å¼€å½“å‰æŒ‡é’ˆå¹¶æŒ‡å‘å‰ä¸€ä¸ªæŒ‡é’ˆ cur.next = pre; //å‘åç§»åŠ¨ pre, curæŒ‡é’ˆ pre = cur; cur = tmp; } return pre; } } // @lc code=end ","date":"2024-04-06T00:00:00Z","image":"https://kris0325.github.io/p/206.-reverse-linked-list/206_hu5477be140e37c38e9e48439fae2f6b6b_11654075_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/206.-reverse-linked-list/","title":"206. Reverse Linked List"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 /* * @lc app=leetcode.cn id=203 lang=java * * [203] ç§»é™¤é“¾è¡¨å…ƒç´  * * https://leetcode.cn/problems/remove-linked-list-elements/description/ * * algorithms * Easy (56.20%) * Likes: 1404 * Dislikes: 0 * Total Accepted: 706.2K * Total Submissions: 1.3M * Testcase Example: \u0026#39;[1,2,6,3,4,5,6]\\n6\u0026#39; * * ç»™ä½ ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ head å’Œä¸€ä¸ªæ•´æ•° val ï¼Œè¯·ä½ åˆ é™¤é“¾è¡¨ä¸­æ‰€æœ‰æ»¡è¶³ Node.val == val çš„èŠ‚ç‚¹ï¼Œå¹¶è¿”å› æ–°çš„å¤´èŠ‚ç‚¹ ã€‚ * * * ç¤ºä¾‹ 1ï¼š * * * è¾“å…¥ï¼šhead = [1,2,6,3,4,5,6], val = 6 * è¾“å‡ºï¼š[1,2,3,4,5] * * * ç¤ºä¾‹ 2ï¼š * * * è¾“å…¥ï¼šhead = [], val = 1 * è¾“å‡ºï¼š[] * * * ç¤ºä¾‹ 3ï¼š * * * è¾“å…¥ï¼šhead = [7,7,7,7], val = 7 * è¾“å‡ºï¼š[] * * * * * æç¤ºï¼š * * * åˆ—è¡¨ä¸­çš„èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ [0, 10^4] å†… * 1 * 0 * * */ // @lc code=start /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeElements(ListNode head, int val) { // å¤´èŠ‚ç‚¹ æ˜¯æ»¡è¶³ Node.val == val çš„èŠ‚ç‚¹ï¼Œåˆ é™¤å¤´èŠ‚ç‚¹, // ä½†æ˜¯nextèŠ‚ç‚¹çš„å€¼å¯èƒ½ä¹Ÿç›¸ç­‰ï¼Œæ‰€ä»¥å¾ªç¯éå† while(head != null \u0026amp;\u0026amp; head.val == val){ head = head.next; } if (head == null) { return head; } ListNode cur = head; while (cur.next != null) { if(cur.next.val == val){ cur.next = cur.next.next; } else { cur = cur.next; } } return head; } } // class Solution { // public ListNode removeElements(ListNode head, int val) { // ListNode dummy = new ListNode(0); // dummy.next = head; // ListNode prev = dummy; // ListNode cur = head; // while (cur != null) { // if (cur.val == val) { // prev.next = cur.next; // } else { // prev = cur; // } // cur = cur.next; // } // return dummy.next; // } // } // @lc code=end ","date":"2024-03-30T00:00:00Z","image":"https://kris0325.github.io/p/203.-remove-linked-list-elements/203_hu5477be140e37c38e9e48439fae2f6b6b_10247729_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/203.-remove-linked-list-elements/","title":"203. Remove Linked List Elements"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 /* * @lc app=leetcode.cn id=59 lang=java * * [59] èºæ—‹çŸ©é˜µ II * * https://leetcode.cn/problems/spiral-matrix-ii/description/ * * algorithms * Medium (71.30%) * Likes: 1271 * Dislikes: 0 * Total Accepted: 407.8K * Total Submissions: 573.1K * Testcase Example: \u0026#39;3\u0026#39; * * ç»™ä½ ä¸€ä¸ªæ­£æ•´æ•°Â n ï¼Œç”Ÿæˆä¸€ä¸ªåŒ…å« 1 åˆ°Â n^2Â æ‰€æœ‰å…ƒç´ ï¼Œä¸”å…ƒç´ æŒ‰é¡ºæ—¶é’ˆé¡ºåºèºæ—‹æ’åˆ—çš„Â n x n æ­£æ–¹å½¢çŸ©é˜µ matrix ã€‚ * * * * ç¤ºä¾‹ 1ï¼š * * * è¾“å…¥ï¼šn = 3 * è¾“å‡ºï¼š[[1,2,3],[8,9,4],[7,6,5]] * * * ç¤ºä¾‹ 2ï¼š * * * è¾“å…¥ï¼šn = 1 * è¾“å‡ºï¼š[[1]] * * * * * æç¤ºï¼š * * * 1 * * * æ€è·¯ï¼šåˆå§‹åŒ–ä¸€ä¸ªn*nçš„çŸ©é˜µmatrixï¼Œç„¶åæ¨¡æ‹Ÿæ•´ä¸ªç”±å†…å‘å¤–èºæ—‹å¡«å…¥æ•°å­—çš„è¿‡ç¨‹ï¼š * 1.å®šä¹‰å½“å‰å·¦å³ä¸Šä¸‹è¾¹ç•Œl,r,t,bã€‚ * è®¡æ•°èµ‹å€¼çš„åˆå§‹å€¼num=1,è¿­ä»£ç»ˆæ­¢å€¼ä¸º target = n*n; * 2.å½“num \u0026lt; targetæ—¶ï¼Œå§‹ç»ˆæŒ‰ç…§ä»å·¦åˆ°å³ï¼Œä»ä¸Šåˆ°ä¸‹ï¼Œä»å³åˆ°å·¦ï¼Œä»ä¸‹åˆ°ä¸Šå¡«å…¥é¡ºåºå¾ªç¯ï¼Œ * æ¯æ¬¡å¡«å…¥åæ‰§è¡Œï¼š * i.æ‰§è¡Œnum +=1 ,å³å¾—åˆ°ä¸‹ä¸€ä¸ªå¾…å¡«å…¥æ•°å€¼ * ii.æ›´æ–°è¾¹ç•Œ, æ¯æ¬¡å¾ªç¯å‰éƒ½éœ€å‘å†…æ”¶ç¼©ï¼Œé¿å…é‡å¤ï¼šä¾‹å¦‚ä»å·¦åˆ°å³å¡«å…¥åï¼Œä¸Šè¾¹ç•Œéœ€è¦ t+=1ï¼Œç›¸å½“äºä¸Šè¾¹ç•Œå‘å†…ç¼©1 * 3.ä½¿ç”¨ num \u0026lt; target, è€Œä¸æ˜¯l\u0026lt;r||t\u0026lt;bä½œä¸ºè¿­ä»£æ¡ä»¶ï¼Œæ˜¯ä¸ºè§£å†³å½“nä¸ºå¥‡æ•°æ—¶ï¼Œ * çŸ©é˜µä¸­å¿ƒæ•°å­—æ— æ³•åœ¨è¿­ä»£è¿‡ç¨‹ä¸­è¢«å¡«å……çš„é—®é¢˜ã€‚ * 4.æœ€ç»ˆè¿”å›matrixå³å¯ã€‚ * * * */ // @lc code=start class Solution { public int[][] generateMatrix(int n) { int [][] matrix = new int[n][n]; int left =0, right = n-1, top = 0, bottom = n-1; int target = n * n, num = 1; while (num \u0026lt;= target ) { //ä»å·¦åˆ°å³éå†ï¼Œè¡Œä¸å˜ä¸ºt for(int l = left; l \u0026lt;=right; l++){ matrix[top][l] = num++; } //å‡†å¤‡è¿›å…¥ä¸‹ä¸€æ¬¡å¾ªç¯ï¼Œä»ä¸Šåˆ°ä¸‹éå†ï¼Œæ‰€ä»¥tåŠ ä¸€ï¼Œ top++; //åˆ—ä¸å˜ä¸ºr for(int t = top; t\u0026lt;=bottom; t++){ matrix[t][right] = num++; } //å‡†å¤‡ä¸‹æ¬¡å¾ªç¯ï¼Œæ‰€ä»¥ä»å³åˆ°å·¦éå†ï¼Œæ‰€ä»¥rå‡ä¸€ï¼Œ right--; //è¡Œä¸å˜ä¸ºb for(int r = right; r\u0026gt;=left;r--){ matrix[bottom][r] = num++; } //å‡†å¤‡è¿›å…¥ä¸‹ä¸€æ¬¡å¾ªç¯ï¼Œä»ä¸‹åˆ°ä¸Šéå†ï¼Œæ‰€ä»¥bå‡ä¸€ bottom--; //åˆ—ä¸å˜ä¸ºl for(int b = bottom; b\u0026gt;=top; b--){ matrix[b][left] = num++; } //å‡†å¤‡è¿›å…¥ä¸‹ä¸€æ¬¡å¾ªç¯ï¼Œä»å·¦åˆ°å³éå†ï¼Œæ‰€ä»¥låŠ ä¸€ left++; } return matrix; } } // @lc code=end ","date":"2024-03-26T00:00:00Z","image":"https://kris0325.github.io/p/59.-spiral-matrix-ii/59_hu5477be140e37c38e9e48439fae2f6b6b_6958036_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/59.-spiral-matrix-ii/","title":"59. Spiral Matrix II"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 /* * @lc app=leetcode.cn id=209 lang=java * * [209] é•¿åº¦æœ€å°çš„å­æ•°ç»„ * * https://leetcode.cn/problems/minimum-size-subarray-sum/description/ * * algorithms * Medium (46.41%) * Likes: 2088 * Dislikes: 0 * Total Accepted: 727.9K * Total Submissions: 1.6M * Testcase Example: \u0026#39;7\\n[2,3,1,2,4,3]\u0026#39; * * ç»™å®šä¸€ä¸ªå«æœ‰Â nÂ ä¸ªæ­£æ•´æ•°çš„æ•°ç»„å’Œä¸€ä¸ªæ­£æ•´æ•° target ã€‚ * * æ‰¾å‡ºè¯¥æ•°ç»„ä¸­æ»¡è¶³å…¶æ€»å’Œå¤§äºç­‰äº target çš„é•¿åº¦æœ€å°çš„ è¿ç»­å­æ•°ç»„Â [numsl, numsl+1, ..., numsr-1, numsr] * ï¼Œå¹¶è¿”å›å…¶é•¿åº¦ã€‚å¦‚æœä¸å­˜åœ¨ç¬¦åˆæ¡ä»¶çš„å­æ•°ç»„ï¼Œè¿”å› 0 ã€‚ * * * * ç¤ºä¾‹ 1ï¼š * * * è¾“å…¥ï¼štarget = 7, nums = [2,3,1,2,4,3] * è¾“å‡ºï¼š2 * è§£é‡Šï¼šå­æ•°ç»„Â [4,3]Â æ˜¯è¯¥æ¡ä»¶ä¸‹çš„é•¿åº¦æœ€å°çš„å­æ•°ç»„ã€‚ * * * ç¤ºä¾‹ 2ï¼š * * * è¾“å…¥ï¼štarget = 4, nums = [1,4,4] * è¾“å‡ºï¼š1 * * * ç¤ºä¾‹ 3ï¼š * * * è¾“å…¥ï¼štarget = 11, nums = [1,1,1,1,1,1,1,1] * è¾“å‡ºï¼š0 * * * * * æç¤ºï¼š * * * 1 \u0026lt;= target \u0026lt;= 10^9 * 1 \u0026lt;= nums.length \u0026lt;= 10^5 * 1 \u0026lt;= nums[i] \u0026lt;= 10^5 * * * * * è¿›é˜¶ï¼š * * * å¦‚æœä½ å·²ç»å®ç° O(n) æ—¶é—´å¤æ‚åº¦çš„è§£æ³•, è¯·å°è¯•è®¾è®¡ä¸€ä¸ª O(n log(n)) æ—¶é—´å¤æ‚åº¦çš„è§£æ³•ã€‚ * * * * æ€è·¯ï¼šæ»‘åŠ¨çª—å£ * å¿«æ…¢æŒ‡é’ˆç§»åŠ¨å½¢æˆæ»‘åŠ¨çª—å£ï¼Œè¿›è¡Œåˆ¤æ–­çª—å£å€¼ä¹‹å’Œæ˜¯å¦æ»¡è¶³æ¡ä»¶ï¼Œå†é€šè¿‡å¿«æ…¢æŒ‡é’ˆç§»åŠ¨æ¨åŠ¨æ»‘åŠ¨çª—å£ */ // @lc code=start class Solution { public int minSubArrayLen(int target, int[] nums) { int reslut = Integer.MAX_VALUE; //æ»‘åŠ¨çª—å£æ•°ç»„å€¼ä¹‹å’Œ int sum = 0; //å·¦è¾¹æ…¢æŒ‡é’ˆå³æ»‘åŠ¨çª—å£èµ·å§‹ä½ç½® int slow = 0; //æ»‘åŠ¨çª—å£çš„é•¿åº¦ int subLength =0; //å³è¾¹å¿«æŒ‡é’ˆå³æ»‘åŠ¨çª—å£ç»“æŸä½ç½® for(int fast = 0; fast \u0026lt; nums.length;fast++){ sum += nums[fast]; //å½“æ¯æ¬¡å¾ªç¯åˆ¤æ–­æ»‘åŠ¨çª—å£çš„æˆªæ–­å‡ºçš„æ•°ç»„å€¼ä¹‹å’Œsumæ»¡è¶³æ¡ä»¶æ—¶ï¼Œ è¿›è¡Œæ¯”è¾ƒå¹¶æ›´æ–°æ»‘åŠ¨çª—å£é•¿åº¦ subLengthï¼Œ //ç„¶åä¸‹ä¸€æ¬¡å¾ªç¯ï¼Œå…ˆæ›´æ–°sumï¼Œåæ›´æ–°å‘å³ç§»åŠ¨æ…¢æŒ‡é’ˆï¼Œ while (sum \u0026gt;= target) { subLength = fast -slow + 1; reslut = Math.min(reslut, subLength ); // sum -= nums[slow++]; //sum -= nums[slow++];æ³¨æ„é¡ºåºï¼Œå³ï¼š sum -= nums[slow]; slow ++; } } return reslut == Integer.MAX_VALUE? 0 : reslut; } } // @lc code=end ","date":"2024-03-25T00:00:00Z","image":"https://kris0325.github.io/p/209.-minimum-size-subarray-sum/209_hu5477be140e37c38e9e48439fae2f6b6b_7955808_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/209.-minimum-size-subarray-sum/","title":"209. Minimum Size Subarray Sum"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 /* * @lc app=leetcode.cn id=977 lang=java * * [977] æœ‰åºæ•°ç»„çš„å¹³æ–¹ * * https://leetcode.cn/problems/squares-of-a-sorted-array/description/ * * algorithms * Easy (67.88%) * Likes: 973 * Dislikes: 0 * Total Accepted: 653.4K * Total Submissions: 962.3K * Testcase Example: \u0026#39;[-4,-1,0,3,10]\u0026#39; * * ç»™ä½ ä¸€ä¸ªæŒ‰ éé€’å‡é¡ºåº æ’åºçš„æ•´æ•°æ•°ç»„ numsï¼Œè¿”å› æ¯ä¸ªæ•°å­—çš„å¹³æ–¹ ç»„æˆçš„æ–°æ•°ç»„ï¼Œè¦æ±‚ä¹ŸæŒ‰ éé€’å‡é¡ºåº æ’åºã€‚ * * * * * * * ç¤ºä¾‹ 1ï¼š * * * è¾“å…¥ï¼šnums = [-4,-1,0,3,10] * è¾“å‡ºï¼š[0,1,9,16,100] * è§£é‡Šï¼šå¹³æ–¹åï¼Œæ•°ç»„å˜ä¸º [16,1,0,9,100] * æ’åºåï¼Œæ•°ç»„å˜ä¸º [0,1,9,16,100] * * ç¤ºä¾‹ 2ï¼š * * * è¾“å…¥ï¼šnums = [-7,-3,2,3,11] * è¾“å‡ºï¼š[4,9,9,49,121] * * * * * æç¤ºï¼š * * * 1 10^4 * -10^4 * nums å·²æŒ‰ éé€’å‡é¡ºåº æ’åº * * * * * è¿›é˜¶ï¼š * * * è¯·ä½ è®¾è®¡æ—¶é—´å¤æ‚åº¦ä¸º O(n) çš„ç®—æ³•è§£å†³æœ¬é—®é¢˜ * * æ€è·¯ï¼š * ç›¸åƒåŒæŒ‡é’ˆï¼Œ * 1.å¯¹åŸæ•°ç»„å…ƒç´ è¿›è¡Œå¹³æ–¹ï¼ŒåŒæ—¶æ–°å»ºä¸€ä¸ªæ•°ç»„ç”¨äºå­˜æ”¾ç»“æœå€¼ * 2.å·¦æŒ‡é’ˆä¸å³æŒ‡é’ˆå¯¹åº”çš„å…ƒç´ æ¯”è¾ƒå¤§å°ï¼Œå°†è¾ƒå¤§å€¼æ”¾å…¥æ–°æ•°ç»„çš„æœ«å°¾ï¼Œ * ï¼ˆå³æ¯æ¬¡å°†æ¯”è¾ƒåè¾ƒå¤§å€¼æ”¾å…¥æ–°æ•°ç»„çš„æœ«å°¾å¹¶ç§»åŠ¨æ–°æ•°ç»„ä¸‹æ ‡ï¼‰ * 3.åŒæ—¶å°†è¾ƒå¤§å€¼å¯¹åº”çš„æŒ‡é’ˆå‘ä¸­é—´æ–¹å‘ç§»åŠ¨ï¼Œç›´åˆ°åˆ°ä¸¤ä¸ªæŒ‡é’ˆç›¸é‡ */ // @lc code=start class Solution { public int[] sortedSquares(int[] nums) { int [] reslut = new int[nums.length]; int left = 0; int right = nums.length -1; int index = nums.length -1; //square for(int i =0; i\u0026lt;= right;i++ ){ nums[i] = nums[i] * nums[i]; } //å·¦å³ç›¸å‘åŒæŒ‡é’ˆï¼Œæ¯”è¾ƒå¯¹åº”å…ƒç´ å¤§å° while (left \u0026lt;= right) { if (nums[left] \u0026lt;= nums[right]) { reslut[index--] =nums[right]; right--; } else if(nums[left] \u0026gt; nums[right]){ reslut[index--] =nums[left]; left++; } } return reslut; } } // @lc code=end ","date":"2024-03-25T00:00:00Z","image":"https://kris0325.github.io/p/977.-squares-of-a-sorted-array/977_hu5477be140e37c38e9e48439fae2f6b6b_10703687_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/977.-squares-of-a-sorted-array/","title":"977. Squares of a Sorted Array"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 /* * @lc app=leetcode.cn id=27 lang=java * * [27] ç§»é™¤å…ƒç´  * * https://leetcode.cn/problems/remove-element/description/ * * algorithms * Easy (59.34%) * Likes: 2181 * Dislikes: 0 * Total Accepted: 1.4M * Total Submissions: 2.4M * Testcase Example: \u0026#39;[3,2,2,3]\\n3\u0026#39; * * ç»™ä½ ä¸€ä¸ªæ•°ç»„ numsÂ å’Œä¸€ä¸ªå€¼ valï¼Œä½ éœ€è¦ åŸåœ° ç§»é™¤æ‰€æœ‰æ•°å€¼ç­‰äºÂ valÂ çš„å…ƒç´ ï¼Œå¹¶è¿”å›ç§»é™¤åæ•°ç»„çš„æ–°é•¿åº¦ã€‚ * * ä¸è¦ä½¿ç”¨é¢å¤–çš„æ•°ç»„ç©ºé—´ï¼Œä½ å¿…é¡»ä»…ä½¿ç”¨ O(1) é¢å¤–ç©ºé—´å¹¶ åŸåœ° ä¿®æ”¹è¾“å…¥æ•°ç»„ã€‚ * * å…ƒç´ çš„é¡ºåºå¯ä»¥æ”¹å˜ã€‚ä½ ä¸éœ€è¦è€ƒè™‘æ•°ç»„ä¸­è¶…å‡ºæ–°é•¿åº¦åé¢çš„å…ƒç´ ã€‚ * * * * è¯´æ˜: * * ä¸ºä»€ä¹ˆè¿”å›æ•°å€¼æ˜¯æ•´æ•°ï¼Œä½†è¾“å‡ºçš„ç­”æ¡ˆæ˜¯æ•°ç»„å‘¢? * * è¯·æ³¨æ„ï¼Œè¾“å…¥æ•°ç»„æ˜¯ä»¥ã€Œå¼•ç”¨ã€æ–¹å¼ä¼ é€’çš„ï¼Œè¿™æ„å‘³ç€åœ¨å‡½æ•°é‡Œä¿®æ”¹è¾“å…¥æ•°ç»„å¯¹äºè°ƒç”¨è€…æ˜¯å¯è§çš„ã€‚ * * ä½ å¯ä»¥æƒ³è±¡å†…éƒ¨æ“ä½œå¦‚ä¸‹: * * * // nums æ˜¯ä»¥â€œå¼•ç”¨â€æ–¹å¼ä¼ é€’çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸å¯¹å®å‚ä½œä»»ä½•æ‹·è´ * int len = removeElement(nums, val); * * // åœ¨å‡½æ•°é‡Œä¿®æ”¹è¾“å…¥æ•°ç»„å¯¹äºè°ƒç”¨è€…æ˜¯å¯è§çš„ã€‚ * // æ ¹æ®ä½ çš„å‡½æ•°è¿”å›çš„é•¿åº¦, å®ƒä¼šæ‰“å°å‡ºæ•°ç»„ä¸­ è¯¥é•¿åº¦èŒƒå›´å†… çš„æ‰€æœ‰å…ƒç´ ã€‚ * for (int i = 0; i \u0026lt; len; i++) { * print(nums[i]); * } * * * * * ç¤ºä¾‹ 1ï¼š * * * è¾“å…¥ï¼šnums = [3,2,2,3], val = 3 * è¾“å‡ºï¼š2, nums = [2,2] * è§£é‡Šï¼šå‡½æ•°åº”è¯¥è¿”å›æ–°çš„é•¿åº¦ 2, å¹¶ä¸” nums ä¸­çš„å‰ä¸¤ä¸ªå…ƒç´ å‡ä¸º 2ã€‚ä½ ä¸éœ€è¦è€ƒè™‘æ•°ç»„ä¸­è¶…å‡ºæ–°é•¿åº¦åé¢çš„å…ƒç´ ã€‚ä¾‹å¦‚ï¼Œå‡½æ•°è¿”å›çš„æ–°é•¿åº¦ä¸º 2 ï¼Œè€Œ * nums = [2,2,3,3] æˆ– nums = [2,2,0,0]ï¼Œä¹Ÿä¼šè¢«è§†ä½œæ­£ç¡®ç­”æ¡ˆã€‚ * * * ç¤ºä¾‹ 2ï¼š * * * è¾“å…¥ï¼šnums = [0,1,2,2,3,0,4,2], val = 2 * è¾“å‡ºï¼š5, nums = [0,1,3,0,4] * è§£é‡Šï¼šå‡½æ•°åº”è¯¥è¿”å›æ–°çš„é•¿åº¦ 5, å¹¶ä¸” nums ä¸­çš„å‰äº”ä¸ªå…ƒç´ ä¸º 0, 1, 3, 0, * 4ã€‚æ³¨æ„è¿™äº”ä¸ªå…ƒç´ å¯ä¸ºä»»æ„é¡ºåºã€‚ä½ ä¸éœ€è¦è€ƒè™‘æ•°ç»„ä¸­è¶…å‡ºæ–°é•¿åº¦åé¢çš„å…ƒç´ ã€‚ * * * * * æç¤ºï¼š * * * 0 \u0026lt;= nums.length \u0026lt;= 100 * 0 \u0026lt;= nums[i] \u0026lt;= 50 * 0 \u0026lt;= val \u0026lt;= 100 * * æ€è·¯ï¼šin-palceåŸåœ°ç§»å‡ºæ•°ç»„å…ƒç´ ï¼Œ * æ–¹æ³•1.è€ƒè™‘ä½¿ç”¨ç›¸å‘åŒæŒ‡é’ˆ * æ–¹æ³•2.è€ƒè™‘ä½¿ç”¨å¿«æ…¢åŒæŒ‡é’ˆ */ // @lc code=start class Solution11 { public int removeElement(int[] nums, int val) { int left = 0; int right =nums.length -1; int tmp = 0; while (left \u0026lt;= right) { if(nums[left] == val){ tmp = nums[left]; nums[left] = nums[right]; nums[right] = tmp; right--; } else { left++; } } return left; } } class Solution12 { public int removeElement(int[] nums, int val) { int left = 0; int right =nums.length -1; // int tmp = 0; while (left \u0026lt;= right) { if(nums[left] == val){ // tmp = nums[left]; //ç›´æ¥ç”¨å³è¾¹çš„å€¼è¦†ç›–å·¦è¾¹çš„å€¼ nums[left] = nums[right]; // nums[right] = tmp; right--; } else { left++; } } return left; } } class Solution { public int removeElement(int[] nums, int val) { //å¿«æŒ‡é’ˆ: å¯»æ‰¾æ–°æ•°ç»„çš„å…ƒç´ ï¼Œæ–°æ•°ç»„å°±æ˜¯ä¸å«æœ‰ç›®æ ‡å…ƒç´ çš„æ•°ç»„ï¼Œæ‰€ä»¥ä¸€ç›´å…ˆå³ç§»åŠ¨ï¼Œé‡åˆ°ç›¸åŒå…ƒç´ æ—¶ï¼Œç»§ç»­èµ°ï¼› // é‡åˆ°ä¸åŒå…ƒç´ æ—¶ï¼Œ äº¤æ¢å¿«æ…¢æŒ‡é’ˆå¯¹åº”æ•°ç»„çš„å…ƒç´ ï¼Œä»è€Œå®ç°å°†æ–°å…ƒç´ å‘å·¦ç§»åŠ¨ //æ…¢æŒ‡é’ˆ: ç”¨äºæ”¶é›†æ–°å…ƒç´ ï¼ŒæŒ‡å‘æ›´æ–° æ–°æ•°ç»„ä¸‹æ ‡çš„ä½ç½®ï¼Œæ‰€ä»¥é‡åˆ°ç›¸åŒå…ƒç´ æ—¶ï¼Œä¸ç§»åŠ¨ï¼› // é‡åˆ°ä¸åŒå…ƒç´ æ—¶å³ç§»ä¸€æ­¥ int slowPointer = 0; for(int fastPointer = 0; fastPointer\u0026lt; nums.length; fastPointer++){ if(nums[fastPointer] != val){ nums[slowPointer] = nums[fastPointer]; slowPointer++; } } return slowPointer; } } // @lc code=end ","date":"2024-03-23T00:00:00Z","image":"https://kris0325.github.io/p/27.-remove-element/27_hu5477be140e37c38e9e48439fae2f6b6b_9247318_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/27.-remove-element/","title":"27. Remove Element"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 /* * @lc app=leetcode.cn id=704 lang=java * * [704] äºŒåˆ†æŸ¥æ‰¾ * * https://leetcode.cn/problems/binary-search/description/ * * algorithms * Easy (55.14%) * Likes: 1551 * Dislikes: 0 * Total Accepted: 1.2M * Total Submissions: 2.2M * Testcase Example: \u0026#39;[-1,0,3,5,9,12]\\n9\u0026#39; * * ç»™å®šä¸€ä¸ªÂ nÂ ä¸ªå…ƒç´ æœ‰åºçš„ï¼ˆå‡åºï¼‰æ•´å‹æ•°ç»„Â nums å’Œä¸€ä¸ªç›®æ ‡å€¼Â target ï¼Œå†™ä¸€ä¸ªå‡½æ•°æœç´¢Â numsÂ ä¸­çš„ * targetï¼Œå¦‚æœç›®æ ‡å€¼å­˜åœ¨è¿”å›ä¸‹æ ‡ï¼Œå¦åˆ™è¿”å› -1ã€‚ * * * ç¤ºä¾‹ 1: * * è¾“å…¥: nums = [-1,0,3,5,9,12], target = 9 * è¾“å‡º: 4 * è§£é‡Š: 9 å‡ºç°åœ¨ nums ä¸­å¹¶ä¸”ä¸‹æ ‡ä¸º 4 * * * ç¤ºä¾‹Â 2: * * è¾“å…¥: nums = [-1,0,3,5,9,12], target = 2 * è¾“å‡º: -1 * è§£é‡Š: 2 ä¸å­˜åœ¨ nums ä¸­å› æ­¤è¿”å› -1 * * * * * æç¤ºï¼š * * * ä½ å¯ä»¥å‡è®¾ numsÂ ä¸­çš„æ‰€æœ‰å…ƒç´ æ˜¯ä¸é‡å¤çš„ã€‚ * nÂ å°†åœ¨Â [1, 10000]ä¹‹é—´ã€‚ * numsÂ çš„æ¯ä¸ªå…ƒç´ éƒ½å°†åœ¨Â [-9999, 9999]ä¹‹é—´ã€‚ * * æ€è·¯ï¼šæ’åºæ•°ç»„æ‰¾targetï¼Œå¯ä»¥ä½¿ç”¨å•æŒ‡é’ˆè¿›è¡ŒäºŒåˆ†æœç´¢ */ // @lc code=start class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.length -1; while (left \u0026lt;= right) { int middle = left + (right -left)/2; //targetåœ¨å·¦åŒºé—´ if(target \u0026lt; nums[middle]){ //middleæŒ‡é’ˆä¸‹æ ‡éœ€è¦å‘å·¦è¾¹ç§»åŠ¨æ—¶ï¼Œé¿å…2ä¸ªå…ƒç´ æ•°ç»„çš„caseä¸‹æ ‡ä¸ç§»åŠ¨ï¼Œæ‰€ä»¥éœ€è¦-1 right = middle -1; } else if(target \u0026gt; nums[middle]){ //targetåœ¨å³åŒºé—´ //åŒç†ï¼ŒmiddleæŒ‡é’ˆå‘å³ç§»åŠ¨æ—¶ï¼Œä¸‹æ ‡éœ€è¦+1ï¼Œ left = middle +1; } else{ return middle; } } return -1; } } // @lc code=end ","date":"2024-03-23T00:00:00Z","image":"https://kris0325.github.io/p/704.-binary-search/704_hu5477be140e37c38e9e48439fae2f6b6b_6288324_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/704.-binary-search/","title":"704. Binary Search"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 /* * @lc app=leetcode.cn id=509 lang=java * * [509] æ–æ³¢é‚£å¥‘æ•° * * https://leetcode.cn/problems/fibonacci-number/description/ * * algorithms * Easy (65.98%) * Likes: 745 * Dislikes: 0 * Total Accepted: 674.9K * Total Submissions: 1M * Testcase Example: \u0026#39;2\u0026#39; * * æ–æ³¢é‚£å¥‘æ•°Â ï¼ˆé€šå¸¸ç”¨Â F(n) è¡¨ç¤ºï¼‰å½¢æˆçš„åºåˆ—ç§°ä¸º æ–æ³¢é‚£å¥‘æ•°åˆ— ã€‚è¯¥æ•°åˆ—ç”±Â 0 å’Œ 1 å¼€å§‹ï¼Œåé¢çš„æ¯ä¸€é¡¹æ•°å­—éƒ½æ˜¯å‰é¢ä¸¤é¡¹æ•°å­—çš„å’Œã€‚ä¹Ÿå°±æ˜¯ï¼š * * * F(0) = 0ï¼ŒF(1)Â = 1 * F(n) = F(n - 1) + F(n - 2)ï¼Œå…¶ä¸­ n \u0026gt; 1 * * * ç»™å®šÂ n ï¼Œè¯·è®¡ç®— F(n) ã€‚ * * * * ç¤ºä¾‹ 1ï¼š * * * è¾“å…¥ï¼šn = 2 * è¾“å‡ºï¼š1 * è§£é‡Šï¼šF(2) = F(1) + F(0) = 1 + 0 = 1 * * * ç¤ºä¾‹ 2ï¼š * * * è¾“å…¥ï¼šn = 3 * è¾“å‡ºï¼š2 * è§£é‡Šï¼šF(3) = F(2) + F(1) = 1 + 1 = 2 * * * ç¤ºä¾‹ 3ï¼š * * * è¾“å…¥ï¼šn = 4 * è¾“å‡ºï¼š3 * è§£é‡Šï¼šF(4) = F(3) + F(2) = 2 + 1 = 3 * * * * * æç¤ºï¼š * * * 0 \u0026lt;= n \u0026lt;= 30 * * * æ€è·¯ï¼šåŠ¨æ€è§„åˆ’ï¼Œ * 1.å®šä¹‰dpæ•°ç»„ * 2.åˆå§‹åŒ–dpæ•°ç»„çš„åˆå§‹å€¼ï¼Œ * 3.å†™å‡ºé€’æ¨å…¬å¼ * 4.é€‰æ‹©é€’æ¨é¡ºåº * 5.æ‰“å°é€’æ¨æ•°ç»„ * * æ³¨æ„ï¼šn\u0026lt;2çš„è¾¹ç•Œæ¡ä»¶éœ€è¦é¢å¤–å¤„ç† */ // @lc code=start class Solution { public int fib(int n) { //æ³¨æ„å¤„ç†è¾¹ç•Œæ¡ä»¶ if(n\u0026lt;2) return n; int[] fib = new int[n+1]; fib[0]= 0; fib[1]= 1; for(int i =2; i \u0026lt;=n ;i++){ fib[i] = fib[i-1]+fib[i-2]; // System.out.println(\u0026#34;fib[n]:\u0026#34;+fib[n]); } return fib[n]; } } // @lc code=end ","date":"2024-03-22T00:00:00Z","image":"https://kris0325.github.io/p/509.-fibonacci-number/509_hu5477be140e37c38e9e48439fae2f6b6b_9999474_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/509.-fibonacci-number/","title":"509. Fibonacci Number"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 /* * @lc app=leetcode.cn id=70 lang=java * * [70] çˆ¬æ¥¼æ¢¯ * * https://leetcode.cn/problems/climbing-stairs/description/ * * algorithms * Easy (54.41%) * Likes: 3474 * Dislikes: 0 * Total Accepted: 1.4M * Total Submissions: 2.6M * Testcase Example: \u0026#39;2\u0026#39; * * å‡è®¾ä½ æ­£åœ¨çˆ¬æ¥¼æ¢¯ã€‚éœ€è¦ nÂ é˜¶ä½ æ‰èƒ½åˆ°è¾¾æ¥¼é¡¶ã€‚ * * æ¯æ¬¡ä½ å¯ä»¥çˆ¬ 1 æˆ– 2 ä¸ªå°é˜¶ã€‚ä½ æœ‰å¤šå°‘ç§ä¸åŒçš„æ–¹æ³•å¯ä»¥çˆ¬åˆ°æ¥¼é¡¶å‘¢ï¼Ÿ * * * * ç¤ºä¾‹ 1ï¼š * * * è¾“å…¥ï¼šn = 2 * è¾“å‡ºï¼š2 * è§£é‡Šï¼šæœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥çˆ¬åˆ°æ¥¼é¡¶ã€‚ * 1. 1 é˜¶ + 1 é˜¶ * 2. 2 é˜¶ * * ç¤ºä¾‹ 2ï¼š * * * è¾“å…¥ï¼šn = 3 * è¾“å‡ºï¼š3 * è§£é‡Šï¼šæœ‰ä¸‰ç§æ–¹æ³•å¯ä»¥çˆ¬åˆ°æ¥¼é¡¶ã€‚ * 1. 1 é˜¶ + 1 é˜¶ + 1 é˜¶ * 2. 1 é˜¶ + 2 é˜¶ * 3. 2 é˜¶ + 1 é˜¶ * * * * * æç¤ºï¼š * * * 1 \u0026lt;= n \u0026lt;= 45 * * */ // @lc code=start class Solution { public int climbStairs(int n) { if(n\u0026lt;=2){ return n; } int []dp = new int[n +1]; dp[1]= 1; dp[2]= 2; //æ³¨æ„ä¸‹æ ‡indexå¼€å§‹äºi=3 for(int i =3; i\u0026lt;=n; i++){ dp[i] = dp[i-2] +dp[i-1]; // System.out.println(\u0026#34;dp[i]\u0026#34;+ \u0026#34;i:\u0026#34;+ i+\u0026#34;:\u0026#34;+dp[i]); } return dp[n]; } } // @lc code=end ","date":"2024-03-22T00:00:00Z","image":"https://kris0325.github.io/p/70.-climbing-stairs/70_hu5477be140e37c38e9e48439fae2f6b6b_10700263_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/70.-climbing-stairs/","title":"70. Climbing Stairs"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 /* * @lc app=leetcode.cn id=746 lang=java * * [746] ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯ * * https://leetcode.cn/problems/min-cost-climbing-stairs/description/ * * algorithms * Easy (66.29%) * Likes: 1455 * Dislikes: 0 * Total Accepted: 416K * Total Submissions: 626.5K * Testcase Example: \u0026#39;[10,15,20]\u0026#39; * * ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ cost ï¼Œå…¶ä¸­ cost[i] æ˜¯ä»æ¥¼æ¢¯ç¬¬ i ä¸ªå°é˜¶å‘ä¸Šçˆ¬éœ€è¦æ”¯ä»˜çš„è´¹ç”¨ã€‚ä¸€æ—¦ä½ æ”¯ä»˜æ­¤è´¹ç”¨ï¼Œå³å¯é€‰æ‹©å‘ä¸Šçˆ¬ä¸€ä¸ªæˆ–è€…ä¸¤ä¸ªå°é˜¶ã€‚ * * ä½ å¯ä»¥é€‰æ‹©ä»ä¸‹æ ‡ä¸º 0 æˆ–ä¸‹æ ‡ä¸º 1 çš„å°é˜¶å¼€å§‹çˆ¬æ¥¼æ¢¯ã€‚ * * è¯·ä½ è®¡ç®—å¹¶è¿”å›è¾¾åˆ°æ¥¼æ¢¯é¡¶éƒ¨çš„æœ€ä½èŠ±è´¹ã€‚ * * * * ç¤ºä¾‹ 1ï¼š * * * è¾“å…¥ï¼šcost = [10,15,20] * è¾“å‡ºï¼š15 * è§£é‡Šï¼šä½ å°†ä»ä¸‹æ ‡ä¸º 1 çš„å°é˜¶å¼€å§‹ã€‚ * - æ”¯ä»˜ 15 ï¼Œå‘ä¸Šçˆ¬ä¸¤ä¸ªå°é˜¶ï¼Œåˆ°è¾¾æ¥¼æ¢¯é¡¶éƒ¨ã€‚ * æ€»èŠ±è´¹ä¸º 15 ã€‚ * * * ç¤ºä¾‹ 2ï¼š * * * è¾“å…¥ï¼šcost = [1,100,1,1,1,100,1,1,100,1] * è¾“å‡ºï¼š6 * è§£é‡Šï¼šä½ å°†ä»ä¸‹æ ‡ä¸º 0 çš„å°é˜¶å¼€å§‹ã€‚ * - æ”¯ä»˜ 1 ï¼Œå‘ä¸Šçˆ¬ä¸¤ä¸ªå°é˜¶ï¼Œåˆ°è¾¾ä¸‹æ ‡ä¸º 2 çš„å°é˜¶ã€‚ * - æ”¯ä»˜ 1 ï¼Œå‘ä¸Šçˆ¬ä¸¤ä¸ªå°é˜¶ï¼Œåˆ°è¾¾ä¸‹æ ‡ä¸º 4 çš„å°é˜¶ã€‚ * - æ”¯ä»˜ 1 ï¼Œå‘ä¸Šçˆ¬ä¸¤ä¸ªå°é˜¶ï¼Œåˆ°è¾¾ä¸‹æ ‡ä¸º 6 çš„å°é˜¶ã€‚ * - æ”¯ä»˜ 1 ï¼Œå‘ä¸Šçˆ¬ä¸€ä¸ªå°é˜¶ï¼Œåˆ°è¾¾ä¸‹æ ‡ä¸º 7 çš„å°é˜¶ã€‚ * - æ”¯ä»˜ 1 ï¼Œå‘ä¸Šçˆ¬ä¸¤ä¸ªå°é˜¶ï¼Œåˆ°è¾¾ä¸‹æ ‡ä¸º 9 çš„å°é˜¶ã€‚ * - æ”¯ä»˜ 1 ï¼Œå‘ä¸Šçˆ¬ä¸€ä¸ªå°é˜¶ï¼Œåˆ°è¾¾æ¥¼æ¢¯é¡¶éƒ¨ã€‚ * æ€»èŠ±è´¹ä¸º 6 ã€‚ * * * * * æç¤ºï¼š * * * 2 \u0026lt;= cost.length \u0026lt;= 1000 * 0 \u0026lt;= cost[i] \u0026lt;= 999 * * * * æ€è·¯ï¼šåŠ¨æ€è§„åˆ’ï¼Œ * å…ˆ1.å®šä¹‰dpæ•°ç»„ * 2.åˆå§‹åŒ–dpæ•°ç»„çš„åˆå§‹å€¼ï¼Œ * 3.å†™å‡ºé€’æ¨å…¬å¼ * 4.é€‰æ‹©é€’æ¨é¡ºåº * 5.æ‰“å°é€’æ¨æ•°ç»„ */ // @lc code=start class Solution { public int minCostClimbingStairs(int[] cost) { //å®šä¹‰dpæ•°ç»„ int[] dp = new int [cost.length +1]; //åˆå§‹åŒ–dpåˆå§‹å€¼ï¼Œå¯ä»¥ä¸‹æ ‡ä¸º0æˆ–1çš„å°é˜¶å¼€å§‹ï¼Œå› æ­¤åˆå§‹å€¼å‡ä¸º0 dp[0]= 0; dp[1]= 0; //1.å†™å‡ºé€’æ¨å…¬å¼dp[i] = Math.min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2]); //2.é€‰æ‹©é€’æ¨é¡ºåºï¼Œè¿›è¡Œå¾ªç¯é€’æ¨æ±‚è§£ for(int i = 2; i\u0026lt;= cost.length; i++){ dp[i] = Math.min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2]); //æ‰“å°é€’æ¨å€¼ // System.out.println(dp[i]); } return dp[cost.length]; } } // @lc code=end ","date":"2024-03-22T00:00:00Z","image":"https://kris0325.github.io/p/746.-min-cost-climbing-stairs/746_hu3d8040dde552413e254984f4d0fd0a1d_11887603_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/746.-min-cost-climbing-stairs/","title":"746. Min Cost Climbing Stairs"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 /* * @lc app=leetcode id=784 lang=java * * [784] Letter Case Permutation * * https://leetcode.com/problems/letter-case-permutation/description/ * * algorithms * Medium (74.08%) * Likes: 4588 * Dislikes: 154 * Total Accepted: 294.9K * Total Submissions: 397.8K * Testcase Example: \u0026#39;\u0026#34;a1b2\u0026#34;\u0026#39; * * Given a string s, youÂ can transform every letter individually to be * lowercase or uppercase to create another string. * * Return a list of all possible strings we could create. Return the output in * any order. * * * Example 1: * * * Input: s = \u0026#34;a1b2\u0026#34; * Output: [\u0026#34;a1b2\u0026#34;,\u0026#34;a1B2\u0026#34;,\u0026#34;A1b2\u0026#34;,\u0026#34;A1B2\u0026#34;] * * * Example 2: * * * Input: s = \u0026#34;3z4\u0026#34; * Output: [\u0026#34;3z4\u0026#34;,\u0026#34;3Z4\u0026#34;] * * * * Constraints: * * * 1 \u0026lt;= s.length \u0026lt;= 12 * s consists of lowercase English letters, uppercase English letters, and * digits. * * * \u0026gt;æ€è·¯åˆ†æï¼š è¿™ä¸€ç±»æœç´¢é—®é¢˜æ˜¯åœ¨ä¸€ä¸ªéšå¼çš„æ ‘ä¸Šè¿›è¡Œçš„æœç´¢é—®é¢˜ï¼Œå³ã€Œæ ‘å½¢é—®é¢˜ã€ã€‚è§£å†³è¿™ä¸€ç±»é—®é¢˜ï¼Œ å…ˆç”»å‡ºé€’å½’æ ‘æ˜¯ååˆ†é‡è¦çš„ï¼Œå¯ä»¥å¸®åŠ©æ‰“å¼€æ€è·¯ ï¼Œç„¶åçœ‹ç€å›¾å½¢æŠŠä»£ç å†™å‡ºæ¥ï¼› è¿™ä¸ªé—®é¢˜æ‰€æ±‚çš„è§£ï¼Œæ˜¯è¿™æ£µæ ‘çš„å¶å­ç»“ç‚¹ä¸Šçš„å€¼ã€‚å› æ­¤ï¼Œå¯ä»¥ä½¿ç”¨æ·±åº¦ä¼˜å…ˆéå†ï¼Œæ”¶é›† æ‰€æœ‰ å¶å­ç»“ç‚¹çš„å€¼ï¼Œæ·±åº¦ä¼˜å…ˆéå†ç”¨äºæœç´¢ä¹Ÿå«å›æº¯ç®—æ³•ï¼› å›æº¯ç®—æ³•å› ä¸ºæœ‰å›å¤´çš„è¿‡ç¨‹ï¼Œå› æ­¤å…¶æ˜¾è‘—ç‰¹å¾æ˜¯ çŠ¶æ€é‡ç½®ã€‚å›æº¯ç®—æ³•çš„å…¥é—¨é—®é¢˜æ˜¯ã€ŒåŠ›æ‰£ã€ç¬¬ 46 é¢˜ï¼šå…¨æ’åˆ—ï¼‰ã€‚ ç”±äºé›†åˆå…ƒç´ å­—æ¯åªæœ‰å¤§å†™ï¼Œå°å†™ä¹‹åˆ†ï¼Œé‚£ä¹ˆç»“æœæ ‘ä¸ºäºŒå‰æ ‘ï¼Œæ‰€ä»¥ä¸éœ€è¦ç”¨forå¾ªç¯å»éå†é›†åˆå…ƒç´  å¤§å°å†™è½¬æ¢ï¼š æˆ‘ä»¬å‘ç°å¤§å†™å­—ç¬¦ä¸å…¶å¯¹åº”çš„å°å†™å­—ç¬¦çš„ ASCII çš„å·®ä¸º 32ï¼Œ32 è¿™ä¸ªå€¼å¦‚æœæ•æ„Ÿçš„è¯ï¼Œå®ƒæ˜¯ 2^5 ï¼Œåœ¨ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œå¯ä»¥è¡¨ç¤ºä¸º 1 \u0026lt;\u0026lt; 5ã€‚è€Œ å˜æ¢å¤§å°å†™è¿™ä»¶äº‹ç­‰ä»·äºï¼š å¦‚æœå­—ç¬¦æ˜¯å°å†™å­—ç¬¦ï¼Œå‡å» 32 å¾—åˆ°å¤§å†™å­—ç¬¦ï¼› å¦‚æœå­—ç¬¦æ˜¯å¤§å†™å­—ç¬¦ï¼ŒåŠ ä¸Š 32 å¾—åˆ°å°å†™å­—ç¬¦ã€‚ è€Œè¿™ä¸¤è€…åˆå¹¶èµ·æ¥ï¼Œå°±æ˜¯ç»™è¿™ä¸ªå­—ç¬¦åšä¸€æ¬¡ä¸è¿›ä½çš„åŠ æ³•ï¼Œå³å¼‚æˆ–ä¸Š 1 \u0026lt;\u0026lt; 5ã€‚ */ // @lc code=start import java.util.ArrayList; class Solution { public List\u0026lt;String\u0026gt; letterCasePermutation(String s) { List\u0026lt;String\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); char[]charArray = s.toCharArray(); backTrack(charArray,0,result); return result; } public void backTrack(char[]charArray, Integer index,List\u0026lt;String\u0026gt; result ){ if(charArray.length == index){ result.add(new String(charArray)); return; } backTrack(charArray, index+1, result); if(Character.isLetter(charArray[index])){ /* å¤§å°å¯«è½‰æ› æ³¨æ„ï¼šchar[]charArray æ˜¯åŸºæœ¬æ•°æ®ç±»å‹ï¼Œæ‰€ä»¥æ˜¯å€¼ä¼ é€’ï¼Œå³ä¼ é€’çš„æ˜¯å‰¯æœ¬ ï¼Œæ‰€ä»¥æ•°ç»„ä¸­çš„æŸä¸ªå…ƒç´ è¿›è¡Œå¤§å°å†™è½¬æ¢åï¼Œå¹¶ä¸ä¼šå½±å“åŸå§‹æ•°ç»„çš„å€¼ï¼Œ å®é™…ä¸Šæ¯ä¸€å±‚æ˜¯ç”±ç³»ç»Ÿè°ƒç”¨æ ˆä¿å­˜çš„ï¼Œé‚£ä¹ˆå°±ä¸ç”¨å†å†™é¢å¤–çš„å¸¸è§„çš„â€œçŠ¶æ€é‡ç½®â€æ“ä½œ **/ charArray[index] ^= 1\u0026lt;\u0026lt;5; backTrack(charArray, index+1,result); } } } // @lc code=end ","date":"2024-03-06T00:00:00Z","image":"https://kris0325.github.io/p/784.letter-case-permutation/784_hu606ca62585253a2e41ef4f76e0603ca2_5079664_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/784.letter-case-permutation/","title":"784.Letter Case Permutation"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 /* * @lc app=leetcode id=46 lang=java * * [46] Permutations * * https://leetcode.com/problems/permutations/description/ * * algorithms * Medium (77.71%) * Likes: 18602 * Dislikes: 313 * Total Accepted: 2M * Total Submissions: 2.5M * Testcase Example: \u0026#39;[1,2,3]\u0026#39; * * Given an array nums of distinct integers, return all the possible * permutations. You can return the answer in any order. * * * Example 1: * Input: nums = [1,2,3] * Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] * Example 2: * Input: nums = [0,1] * Output: [[0,1],[1,0]] * Example 3: * Input: nums = [1] * Output: [[1]] * * * Constraints: * * * 1 \u0026lt;= nums.length \u0026lt;= 6 * -10 \u0026lt;= nums[i] \u0026lt;= 10 * All the integers of nums are unique. * * */ // @lc code=start import java.util.ArrayList; import java.util.List; class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); backTrack(nums, path); return result; } public void backTrack(int[] nums, List\u0026lt;Integer\u0026gt; path){ if(nums.length == path.size()){ result.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } for(int i = 0 ; i \u0026lt; nums.length; i++){ if(!path.contains(nums[i])){ path.add(nums[i]); backTrack(nums, path); path.removeLast(); } } } } // class Solution { // List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); // public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { // List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); // int len = nums.length; // boolean [] used = new boolean[len]; // backTrack(nums, path, used); // return result; // } // public void backTrack(int[] nums, // List\u0026lt;Integer\u0026gt; path,boolean [] used ){ // if(nums.length == path.size()){ // result.add(new ArrayList\u0026lt;\u0026gt;(path)); // return; // } // for(int i = 0 ; i \u0026lt; nums.length; i++){ // if(!used[i]){ // path.add(nums[i]); // used[i] = true; // backTrack(nums, path, used); // used[i] = false; // path.removeLast(); // } // } // } // } // class Main { // public static void main(String[] args) { // // Create a new Solution instance // Solution solution = new Solution(); // // Create a test case // int[] nums = {1, 2, 3}; // // Get the answer // boolean answer = solution.permute(nums); // // Print the answer // System.out.println(answer); // } // } // @lc code=end ","date":"2024-03-05T00:00:00Z","image":"https://kris0325.github.io/p/46.permutations/46_hu53d701c2791f7bf43c897940a94a4d78_6016204_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/46.permutations/","title":"46.Permutations"},{"content":" æ€è·¯ï¼šè¿™ä¸ªè§£å†³æ–¹æ¡ˆç»“åˆäº†Permutationså’ŒSubsets IIçš„æ€æƒ³ã€‚å½“è¾“å…¥æ•°ç»„ä¸­å­˜åœ¨é‡å¤å…ƒç´ æ—¶ï¼Œæˆ‘ä»¬é¦–å…ˆå¯¹è¾“å…¥æ•°ç»„è¿›è¡Œæ’åºï¼Œç„¶ååªæœ‰åœ¨ä»¥ä¸‹æƒ…å†µä¸‹é€‰æ‹©å…ƒç´ ï¼šå®ƒæ˜¯ç¬¬ä¸€ä¸ªè¦é€‰æ‹©çš„å…ƒç´ ï¼Œå®ƒä¸å‰ä¸€ä¸ªå…ƒç´ ä¸åŒï¼Œæˆ–è€…å®ƒä¸å‰ä¸€ä¸ªå…ƒç´ ç›¸åŒï¼Œä½†å‰ä¸€ä¸ªå…ƒç´ ä¹Ÿå·²ç»è¢«é€‰æ‹©ã€‚å…¶ä½™çš„è§£å†³æ–¹æ¡ˆéµå¾ªä¸æ²¡æœ‰é‡å¤å…ƒç´ çš„æ’åˆ—ç›¸åŒçš„é€»è¾‘ï¼Œå…·æœ‰ç›¸åŒçš„æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 /* * @lc app=leetcode id=47 lang=java * * [47] Permutations II * * https://leetcode.com/problems/permutations-ii/description/ * * algorithms * Medium (58.51%) * Likes: 8373 * Dislikes: 139 * Total Accepted: 893.1K * Total Submissions: 1.5M * Testcase Example: \u0026#39;[1,1,2]\u0026#39; * Given a collection of numbers, nums,Â that might contain duplicates, return * all possible unique permutations in any order. * * * Example 1: * * * Input: nums = [1,1,2] * Output: * [[1,1,2], * â [1,2,1], * â [2,1,1]] * * * Example 2: * * * Input: nums = [1,2,3] * Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] * * * * Constraints: * * * 1 \u0026lt;= nums.length \u0026lt;= 8 * -10 \u0026lt;= nums[i] \u0026lt;= 10 * * */ // @lc code=start import java.util.Arrays; class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permuteUnique(int[] nums) { List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); int len = nums.length; Arrays.sort(nums); boolean [] used = new boolean[len]; backTrack(nums, path, used); return result; } public void backTrack(int[] nums, List\u0026lt;Integer\u0026gt; path,boolean [] used ){ if(nums.length == path.size()){ result.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } for(int i = 0 ; i \u0026lt; nums.length; i++){ //ç„¶ååªæœ‰åœ¨ä»¥ä¸‹æƒ…å†µä¸‹é€‰æ‹©å…ƒç´ ï¼šå®ƒæ²’è¢«é¸æ“‡éã€‚å®ƒæ˜¯ç¬¬ä¸€ä¸ªè¦é€‰æ‹©çš„å…ƒç´ ï¼Œå®ƒä¸å‰ä¸€ä¸ªå…ƒç´ ä¸åŒï¼Œæˆ–è€…å®ƒä¸å‰ä¸€ä¸ªå…ƒç´ ç›¸åŒï¼Œä½†å‰ä¸€ä¸ªå…ƒç´ ä¹Ÿå·²ç»è¢«é€‰æ‹©ã€‚ if(!used[i] \u0026amp;\u0026amp; (i==0 || nums[i] != nums[i-1] || used[i-1])){ path.add(nums[i]); used[i] = true; backTrack(nums, path, used); used[i] = false; path.removeLast(); } } } } // class Solution2 { // List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); // public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permuteUnique(int[] nums) { // List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); // int len = nums.length; // boolean [] used = new boolean[len]; // backTrack(nums, path, used); // List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; deduped = result.stream() // .distinct() // .toList(); // return deduped; // } // public void backTrack(int[] nums, // List\u0026lt;Integer\u0026gt; path,boolean [] used ){ // if(nums.length == path.size()){ // result.add(new ArrayList\u0026lt;\u0026gt;(path)); // return; // } // for(int i = 0 ; i \u0026lt; nums.length; i++){ // if(!used[i]){ // path.add(nums[i]); // used[i] = true; // backTrack(nums, path, used); // used[i] = false; // path.removeLast(); // } // } // } // } // @lc code=end ","date":"2024-03-05T00:00:00Z","image":"https://kris0325.github.io/p/47.permutations-ii/47_hu5477be140e37c38e9e48439fae2f6b6b_9032782_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/47.permutations-ii/","title":"47.Permutations-ii"},{"content":"æ™‚éš”å››å¹´ï¼Œæ•…åœ°é‡æ¸¸ã€‚\nåˆ°é”æ±äº¬æˆç”°åœ‹éš›æ©Ÿå ´å¾Œï¼Œç›´å¥”åœ‹ç«‹è¥¿æ´‹è—è¡“åšç‰©é¤¨ï¼Œå¹¸é‹çš„äº‹è¶•åœ¨é–‰é¤¨çš„å‰ä¸€å¤©çœ‹åˆ°äº†è±å¯Œçš„è—å“ åšç‰©é¤¨çš„å‰µå»ºè€…æ¾æ–¹å¹¸æ¬¡éƒå…ˆç”Ÿçš„ç•«åƒã€‚æ¾æ–¹å…ˆç”Ÿæ…·æ…¨åœ°æè´ˆäº†å¤§é‡è—è¡“è—å“çµ¦åšç‰©é¤¨ ç‚ºèƒ½ç™»åŠå³¶å‹Ÿæ é€›å®Œåšç‰©é¤¨å‡ºä¾†ï¼Œå¤œå¹•é™è‡¨ï¼Œçš“æœˆç•¶ç©º ","date":"2024-03-05T00:00:00Z","image":"https://kris0325.github.io/p/%E6%95%85%E5%9C%B0%E9%87%8D%E6%B8%B8/The%20National%20Museum%20of%20Western%20Art_hu209af62a5c347621b358fca369c6201f_4823951_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/%E6%95%85%E5%9C%B0%E9%87%8D%E6%B8%B8/","title":"æ•…åœ°é‡æ¸¸"},{"content":"/*\n@lc app=leetcode id=216 lang=java [216] Combination Sum III https://leetcode.com/problems/combination-sum-iii/description/ algorithms Medium (69.07%) Likes: 5799 Dislikes: 107 Total Accepted: 485.5K Total Submissions: 700.5K Testcase Example: \u0026lsquo;3\\n7\u0026rsquo; Find all valid combinations of k numbers that sum up to n such that the following conditions are true: Only numbers 1 through 9 are used. Each number is used at most once. Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order. Example 1: Input: k = 3, n = 7 Output: [[1,2,4]] Explanation: 1 + 2 + 4 = 7 There are no other valid combinations. Example 2: Input: k = 3, n = 9 Output: [[1,2,6],[1,3,5],[2,3,4]] Explanation: 1 + 2 + 6 = 9 1 + 3 + 5 = 9 2 + 3 + 4 = 9 There are no other valid combinations. Example 3: Input: k = 4, n = 1 Output: [] Explanation: There are no valid combinations. Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 \u0026gt; 1, there are no valid combination. Constraints: 2 \u0026lt;= k \u0026lt;= 9 1 \u0026lt;= n \u0026lt;= 60 */\næ€è·¯ï¼š æœ¬é¢˜å°±æ˜¯åœ¨[1,2,3,4,5,6,7,8,9]è¿™ä¸ªé›†åˆä¸­æ‰¾åˆ°å’Œä¸ºnçš„kä¸ªæ•°çš„ç»„åˆã€‚ ç›¸å¯¹äº77. ç»„åˆï¼Œæ— éå°±æ˜¯å¤šäº†ä¸€ä¸ªé™åˆ¶ï¼Œæœ¬é¢˜æ˜¯è¦æ‰¾åˆ°å’Œä¸ºnçš„kä¸ªæ•°çš„ç»„åˆï¼Œè€Œæ•´ä¸ªé›†åˆå·²ç»æ˜¯å›ºå®šçš„äº†[1,\u0026hellip;,9]ã€‚ æƒ³åˆ°è¿™ä¸€ç‚¹äº†ï¼Œåšè¿‡77. ç»„åˆä¹‹åï¼Œæœ¬é¢˜æ˜¯ç®€å•ä¸€äº›äº†ã€‚ æœ¬é¢˜kç›¸å½“äºæ ‘çš„æ·±åº¦ï¼Œ9ï¼ˆå› ä¸ºæ•´ä¸ªé›†åˆå°±æ˜¯9ä¸ªæ•°ï¼‰å°±æ˜¯æ ‘çš„å®½åº¦ã€‚ ä¾‹å¦‚ k = 2ï¼Œn = 4çš„è¯ï¼Œå°±æ˜¯åœ¨é›†åˆ[1,2,3,4,5,6,7,8,9]ä¸­æ±‚ kï¼ˆä¸ªæ•°ï¼‰ = 2, nï¼ˆå’Œï¼‰ = 4çš„ç»„åˆã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // @lc code=start import java.util.ArrayList; import java.util.LinkedList; import java.util.ArrayList; import java.util.LinkedList; class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); LinkedList\u0026lt;Integer\u0026gt; path = new LinkedList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum3(int k, int n) { backTrack( n , k,1,0 ); return result; } public void backTrack(Integer sumTarget, int k, int begin, int sum ){ //å‰ªæ if(sum \u0026gt; sumTarget){ return; } if(path.size() == k \u0026amp;\u0026amp; sum == sumTarget ){ result.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } //å‰ªæ i \u0026lt;= 9 - (k -path.size()) +1 for(int i = begin; i \u0026lt;= 9 - (k -path.size()) +1 ; i++){ path.add(i); sum += i; backTrack(sumTarget,k, i+1, sum); path.removeLast(); sum -= i; } } } // @lc code=end ","date":"2024-02-27T00:00:00Z","image":"https://kris0325.github.io/p/216.combination-sum-iii/216_huee336b0bcb2a7652cd11fea2dee339d9_1429265_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/216.combination-sum-iii/","title":"216.Combination Sum III"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 /* * @lc app=leetcode id=17 lang=java * * [17] Letter Combinations of a Phone Number */ // @lc code=start import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; /* * DFS æ·±åº¦ä¼˜å…ˆæœç´ ç®—æ³• */ // class Solution { // public List\u0026lt;String\u0026gt; letterCombinations(String digits) { // // List\u0026lt;String\u0026gt; phoneNum2String = new ArrayList\u0026lt;String\u0026gt;(Arrays.asList(\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;abc\u0026#34;,\u0026#34;def\u0026#34;,\u0026#34;ghi\u0026#34;,\u0026#34;jkl\u0026#34;,\u0026#34;mno\u0026#34;,\u0026#34;pqrs\u0026#34;,\u0026#34;tuv\u0026#34;,\u0026#34;wxyz\u0026#34;)); // //ä½¿ç”¨hashMap å¯åº”å¯¹å¼‚å¸¸è¾¹ç•Œæ¡ä»¶ï¼Œæ¯”å¦‚è¾“å…¥0,1æˆ–è€…éæ•°å­— // Map\u0026lt;Character,String\u0026gt; phoneNum2String = new HashMap\u0026lt;\u0026gt;(){{ // put(\u0026#39;0\u0026#39;, \u0026#34;\u0026#34;); // put(\u0026#39;1\u0026#39;, \u0026#34;\u0026#34;); // put(\u0026#39;2\u0026#39;, \u0026#34;abc\u0026#34;); // put(\u0026#39;3\u0026#39;, \u0026#34;def\u0026#34;); // put(\u0026#39;4\u0026#39;, \u0026#34;ghi\u0026#34;); // put(\u0026#39;5\u0026#39;, \u0026#34;jkl\u0026#34;); // put(\u0026#39;6\u0026#39;, \u0026#34;mno\u0026#34;); // put(\u0026#39;7\u0026#39;, \u0026#34;pqrs\u0026#34;); // put(\u0026#39;8\u0026#39;, \u0026#34;tuv\u0026#34;); // put(\u0026#39;9\u0026#39;, \u0026#34;wxyz\u0026#34;); // }}; // List\u0026lt;String\u0026gt; combinations = new ArrayList\u0026lt;\u0026gt;(); // int index = 0; // //å­˜å½“å‰å­—ç¬¦ä¸² // StringBuffer current = new StringBuffer(); // //ç®—æ³•ï¼šDFSæ·±åº¦ä¼˜å…ˆæœç´¢ / å›æº¯ å®ç°æœç´¢ï¼Œ // findCombinationsBacktrack(phoneNum2String,combinations,0,digits,current); // return combinations; // } // public void findCombinationsBacktrack(Map\u0026lt;Character,String\u0026gt; phoneNum2String, List\u0026lt;String\u0026gt; combinations ,int index, String digits,StringBuffer current){ // if(index == digits.length()){ // if(index == 0){ // return; // } // combinations.add(current.toString()); // return; // } // String alphaString = phoneNum2String.get(digits.charAt(index)); // for(int i = 0; i\u0026lt;alphaString.length();i++){ // current.append(alphaString.charAt(i)); // findCombinationsBacktrack(phoneNum2String,combinations,index+1,digits,current); // current.deleteCharAt(index); // } // } // } /* * BFS å¹¿åº¦ä¼˜å…ˆæœç´ ç®—æ³• */ class Solution { public List\u0026lt;String\u0026gt; letterCombinationsBSF(String digits) { if (digits.length() == 0) return new ArrayList\u0026lt;String\u0026gt;(); String[] d = new String[]{\u0026#34; \u0026#34;, \u0026#34;\u0026#34;, \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;, \u0026#34;wxyz\u0026#34;}; List\u0026lt;String\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); ans.add(\u0026#34;\u0026#34;); for (char digit : digits.toCharArray()) { List\u0026lt;String\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); for (String t : ans) { String s = d[Character.getNumericValue(digit)]; for (int i = 0; i \u0026lt; s.length(); ++i) tmp.add(t + s.charAt(i)); } ans = tmp; } return ans; } } /* * debug */ class Main{ public static void main(String[] args) { // Create a new Solution instance Solution solution = new Solution(); // Create a test case String testCase = \u0026#34;23\u0026#34;; // Get the answer List\u0026lt;String\u0026gt; result = solution.letterCombinationsBSF(testCase); // Print the answer System.out.println(result); } } // @lc code=end ","date":"2024-01-25T00:00:00Z","image":"https://kris0325.github.io/p/17.letter-combinations-of-a-phone-number/17_hua62bcbcf9a79dfe26d0875c8d67438b3_4738208_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/17.letter-combinations-of-a-phone-number/","title":"17.letter-combinations-of-a-phone-number"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 /* * @lc app=leetcode id=39 lang=java * * [39] Combination Sum * * https://leetcode.com/problems/combination-sum/description/ * * algorithms * Medium (70.32%) * Likes: 17899 * Dislikes: 367 * Total Accepted: 1.7M * Total Submissions: 2.4M * Testcase Example: \u0026#39;[2,3,6,7]\\n7\u0026#39; * * Given an array of distinct integers candidates and a target integer target, * return a list of all unique combinations of candidates where the chosen * numbers sum to target. You may return the combinations in any order. * * The same number may be chosen from candidates an unlimited number of times. * Two combinations are unique if the frequency of at least one of the chosen * numbers is different. * * The test cases are generated such that the number of unique combinations * that sum up to target is less than 150 combinations for the given input. * * * Example 1: * * * Input: candidates = [2,3,6,7], target = 7 * Output: [[2,2,3],[7]] * Explanation: * 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple * times. * 7 is a candidate, and 7 = 7. * These are the only two combinations. * * * Example 2: * * * Input: candidates = [2,3,5], target = 8 * Output: [[2,2,2,2],[2,3,3],[3,5]] * * * Example 3: * * * Input: candidates = [2], target = 1 * Output: [] * * * * Constraints: * * * 1 \u0026lt;= candidates.length \u0026lt;= 30 * 2 \u0026lt;= candidates[i] \u0026lt;= 40 * All elements of candidates are distinct. * 1 \u0026lt;= target \u0026lt;= 40 * * * * @param candidates å€™é€‰æ•°ç»„ * @param begin æœç´¢èµ·ç‚¹ * @param len å†—ä½™å˜é‡ï¼Œæ˜¯ candidates é‡Œçš„å±æ€§ï¼Œå¯ä»¥ä¸ä¼  * @param target æ¯å‡å»ä¸€ä¸ªå…ƒç´ ï¼Œç›®æ ‡å€¼å˜å° * @param cur ä»æ ¹ç»“ç‚¹åˆ°å¶å­ç»“ç‚¹çš„è·¯å¾„ï¼Œæ˜¯ä¸€ä¸ªæ ˆ * @param res ç»“æœé›†åˆ—è¡¨ å‚è€ƒé“¾æ¥ï¼šhttps://leetcode.cn/problems/combination-sum/solutions/14697/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/ * * å¯¹äºæ‰€æœ‰æœç´ å¯è¡Œè§£ç±»å‹çš„é—®é¢˜ï¼Œéƒ½å¯ä»¥å°è¯• â€œæœç´¢å›æº¯â€çš„æ–¹æ³•æ±‚è§£ * solution1 * æ·±åº¦ä¼˜å…ˆæœç´¢ç®—æ³• * * * å‰ªææé€Ÿ æ ¹æ®ä¸Šé¢ç”»æ ‘å½¢å›¾çš„ç»éªŒï¼Œå¦‚æœ target å‡å»ä¸€ä¸ªæ•°å¾—åˆ°è´Ÿæ•°ï¼Œé‚£ä¹ˆå‡å»ä¸€ä¸ªæ›´å¤§çš„æ ‘ä¾ç„¶æ˜¯è´Ÿæ•°ï¼ŒåŒæ ·æœç´¢ä¸åˆ°ç»“æœã€‚åŸºäºè¿™ä¸ªæƒ³æ³•ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹è¾“å…¥æ•°ç»„è¿›è¡Œæ’åºï¼Œæ·»åŠ ç›¸å…³é€»è¾‘è¾¾åˆ°è¿›ä¸€æ­¥å‰ªæçš„ç›®çš„ï¼› æ’åºæ˜¯ä¸ºäº†æé«˜æœç´¢é€Ÿåº¦ï¼Œå¯¹äºè§£å†³è¿™ä¸ªé—®é¢˜æ¥è¯´éå¿…è¦ã€‚ä½†æ˜¯æœç´¢é—®é¢˜ä¸€èˆ¬å¤æ‚åº¦è¾ƒé«˜ï¼Œèƒ½å‰ªæå°±å°½é‡å‰ªæã€‚å®é™…å·¥ä½œä¸­å¦‚æœé‡åˆ°ä¸¤ç§æ–¹æ¡ˆæ‹¿æä¸å‡†çš„æƒ…å†µï¼Œéƒ½è¯•ä¸€ä¸‹ã€‚ * solution2 * 1 å…ˆæ’åºï¼Œå‰ªæ * 2 å†ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢ç®—æ³• */ // @lc code=start import java.lang.reflect.Array; import java.util.ArrayList; import java.util.Arrays; import java.util.Deque; class Solution1 { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinations = new ArrayList\u0026lt;\u0026gt;(); int length = candidates.length; Deque\u0026lt;Integer\u0026gt; cur = new ArrayDeque\u0026lt;\u0026gt;(); if(length==0){ return combinations; } dfs(candidates,target,0,length,combinations,cur); return combinations; } public void dfs(int[] candidates, int target, int begin, int length, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinations, Deque\u0026lt;Integer\u0026gt; cur ){ if(target \u0026lt;0){ return; } if(target == 0){ combinations.add(new ArrayList(cur)); return; } // é‡ç‚¹ç†è§£è¿™é‡Œä» begin å¼€å§‹æœç´¢çš„è¯­æ„ for (int i = begin; i \u0026lt; length; i++){ cur.addLast(candidates[i]); // æ³¨æ„ï¼šç”±äºæ¯ä¸€ä¸ªå…ƒç´ å¯ä»¥é‡å¤ä½¿ç”¨ï¼Œä¸‹ä¸€è½®æœç´¢çš„èµ·ç‚¹ä¾ç„¶æ˜¯ iï¼Œè€Œä¸æ˜¯i+1ï¼Œè¿™é‡Œéå¸¸å®¹æ˜“å¼„é”™ dfs(candidates,target-candidates[i], i, length,combinations,cur); // çŠ¶æ€é‡ç½® cur.removeLast(); } } } class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinations = new ArrayList\u0026lt;\u0026gt;(); int length = candidates.length; // æ’åºæ˜¯å‰ªæçš„å‰æ Arrays.sort(candidates); Deque\u0026lt;Integer\u0026gt; cur = new ArrayDeque\u0026lt;\u0026gt;(); if(length==0){ return combinations; } dfs(candidates,target, 0, length,combinations,cur); return combinations; } public void dfs(int[] candidates, int target, int begin, int length, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinations, Deque\u0026lt;Integer\u0026gt; cur ){ // ç”±äºè¿›å…¥æ›´æ·±å±‚çš„æ—¶å€™ï¼Œå°äº 0 çš„éƒ¨åˆ†è¢«å‰ªæï¼Œå› æ­¤é€’å½’ç»ˆæ­¢æ¡ä»¶å€¼åªåˆ¤æ–­ç­‰äº 0 çš„æƒ…å†µ if(target == 0){ combinations.add(new ArrayList(cur)); return; } for (int i = begin; i \u0026lt; length; i++){ if(target \u0026lt; candidates[i]) { break; } cur.addLast(candidates[i]); dfs(candidates,target-candidates[i], i, length,combinations,cur); cur.removeLast(); } } } // @lc code=end ","date":"2024-01-25T00:00:00Z","permalink":"https://kris0325.github.io/p/39.combination-sum/","title":"39.combination-sum"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 /* * @lc app=leetcode id=40 lang=java * * [40] Combination Sum II * * https://leetcode.com/problems/combination-sum-ii/description/ * * algorithms * Medium (53.88%) * Likes: 9859 * Dislikes: 261 * Total Accepted: 861.2K * Total Submissions: 1.6M * Testcase Example: \u0026#39;[10,1,2,7,6,1,5]\\n8\u0026#39; * * Given a collection of candidate numbers (candidates) and a target number * (target), find all unique combinations in candidatesÂ where the candidate * numbers sum to target. * * Each number in candidatesÂ may only be used once in the combination. * * Note:Â The solution set must not contain duplicate combinations. * * * Example 1: * * * Input: candidates = [10,1,2,7,6,1,5], target = 8 * Output: * [ * [1,1,6], * [1,2,5], * [1,7], * [2,6] * ] * * * Example 2: * * * Input: candidates = [2,5,2,1,2], target = 5 * Output: * [ * [1,2,2], * [5] * ] * * * * Constraints: * * * 1 \u0026lt;=Â candidates.length \u0026lt;= 100 * 1 \u0026lt;=Â candidates[i] \u0026lt;= 50 * 1 \u0026lt;= target \u0026lt;= 30 * * * * * solution: * * * @param candidates å€™é€‰æ•°ç»„ * @param begin ä»å€™é€‰æ•°ç»„çš„ begin ä½ç½®å¼€å§‹æœç´¢ * @param target è¡¨ç¤ºå‰©ä½™ï¼Œè¿™ä¸ªå€¼ä¸€å¼€å§‹ç­‰äº targetï¼ŒåŸºäºé¢˜ç›®ä¸­è¯´æ˜çš„\u0026#34;æ‰€æœ‰æ•°å­—ï¼ˆåŒ…æ‹¬ç›®æ ‡æ•°ï¼‰éƒ½æ˜¯æ­£æ•´æ•°\u0026#34;è¿™ä¸ªæ¡ä»¶ * @param cur ä»æ ¹ç»“ç‚¹åˆ°å¶å­ç»“ç‚¹çš„è·¯å¾„ * @param combination æœ€ç»ˆçš„æ‰€æœ‰ç»„åˆ å‚è€ƒé“¾æ¥ï¼šhttps://leetcode.cn/problems/combination-sum-ii/solutions/14753/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/ * * æ·±åº¦ä¼˜å…ˆæœç´  * æ³¨æ„å»é‡ * */ // @lc code=start import java.util.ArrayList; import java.util.Arrays; import java.util.List; class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum2(int[] candidates, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combination = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; cur = new ArrayList\u0026lt;\u0026gt;(); if(candidates.length == 0){ return combination; } Arrays.sort(candidates); dfs(candidates, target, 0, combination, cur); return combination; } public void dfs(int[] candidates, int target, int begin,List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combination, List\u0026lt;Integer\u0026gt; cur){ if(target==0){ combination.add(new ArrayList\u0026lt;\u0026gt;(cur)); return; } for(int i = begin; i\u0026lt; candidates.length;i++){ //å¤§å‰ªæï¼Œå‡å» targetæ¯”candidates[i]å°çš„ if(target\u0026lt;candidates[i]){ return; } //å°å‰ªæï¼Œæ’åºåï¼ŒåŒä¸€å±‚ï¼Œç›¸åŒå…ƒç´ ï¼Œä¼šäº§ç”Ÿé‡å¤ç»„åˆï¼Œæ‰€ä»¥è¿›è¡Œè·³è¿‡å»é‡ if(i\u0026gt;begin \u0026amp;\u0026amp; candidates[i] == candidates[i-1] ){ continue; } cur.add(candidates[i]); //æ³¨æ„å…ƒç´ ä¸èƒ½é‡å¤ä½¿ç”¨ï¼Œæ‰€ä»¥ä¸‹ä¸€å±‚æœç´¢beginä»i+1å¼€å§‹æœç´¢ dfs(candidates,target - candidates[i],i+1,combination,cur); cur.remove(cur.size() -1); } } } // @lc code=end ","date":"2024-01-25T00:00:00Z","permalink":"https://kris0325.github.io/p/40.combination-sum-ii/","title":"40.combination-sum-ii"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 /* * @lc app=leetcode id=77 lang=java * * [77] Combinations * * https://leetcode.com/problems/combinations/description/ * * algorithms * Medium (69.56%) * Likes: 7886 * Dislikes: 206 * Total Accepted: 822.7K * Total Submissions: 1.2M * Testcase Example: \u0026#39;4\\n2\u0026#39; * * Given two integers n and k, return all possible combinations of k numbers * chosen from the range [1, n]. * * You may return the answer in any order. * * * Example 1: * * * Input: n = 4, k = 2 * Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]] * Explanation: There are 4 choose 2 = 6 total combinations. * Note that combinations are unordered, i.e., [1,2] and [2,1] are considered * to be the same combination. * * * Example 2: * * * Input: n = 1, k = 1 * Output: [[1]] * Explanation: There is 1 choose 1 = 1 total combination. * * * * Constraints: * * * 1 \u0026lt;= n \u0026lt;= 20 * 1 \u0026lt;= k \u0026lt;= n * * */ // @lc code=start import java.util.ArrayList; import java.util.List; class Solution1 { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinations = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; cur = new ArrayList\u0026lt;\u0026gt;(); if( k \u0026lt;= 0 || k \u0026gt; n){ return combinations; } dfs(n, k, 1, cur, combinations); return combinations; } public void dfs(int n, int k, int begin, List\u0026lt;Integer\u0026gt; cur, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinations){ if(cur.size() == k){ combinations.add(new ArrayList\u0026lt;\u0026gt;(cur)); return; } for(int i = begin; i \u0026lt;= n; i++){ cur.add(i); dfs(n, k, i+1, cur, combinations); cur.remove(cur.size() - 1); } } } class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinations = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; cur = new ArrayList\u0026lt;\u0026gt;(); if( k \u0026lt;= 0 || k \u0026gt; n){ return combinations; } dfs(n, k, 1, cur, combinations); return combinations; } public void dfs(int n, int k, int begin, List\u0026lt;Integer\u0026gt; cur, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinations){ if(cur.size() == k){ combinations.add(new ArrayList\u0026lt;\u0026gt;(cur)); return; } //å‰ªææ¢ä»¶ï¼Œæœç´¢çš„beginè¾¹ç•Œéœ€è¦æ»¡è¶³ å‰©ä½™çš„å…ƒç´ éœ€è¦è¶³å¤Ÿå¤šï¼Œä¹Ÿå°±æ˜¯ k - cur.size() \u0026lt;= n-i +1ï¼Œå¦è€…é€²è¡Œå‰ªæï¼Œ for(int i = begin; i \u0026lt;= n - (k - cur.size()) +1; i++){ cur.add(i); dfs(n, k, i+1, cur, combinations); cur.remove(cur.size() - 1); } } } // @lc code=end ","date":"2024-01-25T00:00:00Z","permalink":"https://kris0325.github.io/p/77.combinations/","title":"77.combinations"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 /* * @lc app=leetcode id=78 lang=java * * [78] Subsets * * https://leetcode.com/problems/subsets/description/ * * algorithms * Medium (76.47%) * Likes: 16199 * Dislikes: 243 * Total Accepted: 1.7M * Total Submissions: 2.2M * Testcase Example: \u0026#39;[1,2,3]\u0026#39; * * Given an integer array nums of unique elements, return all possible subsets * (the power set). * * The solution set must not contain duplicate subsets. Return the solution in * any order. * * * Example 1: * * * Input: nums = [1,2,3] * Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] * * * Example 2: * * * Input: nums = [0] * Output: [[],[0]] * * * * Constraints: * * * 1 \u0026lt;= nums.length \u0026lt;= 10 * -10 \u0026lt;= nums[i] \u0026lt;= 10 * All the numbers ofÂ nums are unique. * * * * solutionï¼š * é—®é¢˜æ‹†åˆ†æˆ ä»nä¸ªå…ƒç´ çš„æ•°ç»„ä¸­é€‰è€…kä¸ªå…ƒç´ çš„ç´ å…¨ç»„åˆ, å†æ”¶é›†æ‰€æœ‰ç»„åˆå³å¯ */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 // @lc code=start import java.util.ArrayList; /* å…¶å®å¯ä»¥ä¸éœ€è¦åŠ ç»ˆæ­¢æ¡ä»¶ï¼Œå› ä¸ºstartIndex \u0026gt;= nums.size()ï¼Œæœ¬å±‚forå¾ªç¯æœ¬æ¥ä¹Ÿç»“æŸäº†ã€‚ å•å±‚æœç´¢é€»è¾‘ æ±‚å–å­é›†é—®é¢˜ï¼Œä¸éœ€è¦ä»»ä½•å‰ªæï¼å› ä¸ºå­é›†å°±æ˜¯è¦éå†æ•´æ£µæ ‘ã€‚ */ class Solution { //backtracking: subsetå­é›†é—®é¢˜ï¼š List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { backtracking(nums, 0); return result; } public void backtracking(int nums[], int startIndex) { result.add(new Arraylist\u0026lt;\u0026gt;(path)); /* å¯ä»¥ä¸éœ€è¦åŠ ç»ˆæ­¢æ¡ä»¶ï¼Œå› ä¸ºstartIndex \u0026gt;= nums.size()ï¼Œæœ¬å±‚forå¾ªç¯æœ¬æ¥ä¹Ÿç»“æŸäº†ã€‚ å•å±‚æœç´¢é€»è¾‘ æ±‚å–å­é›†é—®é¢˜ï¼Œä¸éœ€è¦ä»»ä½•å‰ªæï¼å› ä¸ºå­é›†å°±æ˜¯è¦éå†æ•´æ£µæ ‘ã€‚ */ for (int i = startIndex; i \u0026lt; nums.length; i++) { path.add(nums[i]); backtracking(nums, i + 1); path.removeLast(); } } } // @lc code=end ```java // @lc code=start class Solution1 { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets = new ArrayList\u0026lt;\u0026gt;(); for(int k = 0; k \u0026lt;= nums.length; k++){ dfs(nums, 0, k, new ArrayList\u0026lt;\u0026gt;(),subsets); } return subsets; } public void dfs(int[] nums, int begin, int k, List\u0026lt;Integer\u0026gt; cur , List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets){ if(k == cur.size()){ subsets.add(new ArrayList\u0026lt;\u0026gt;(cur)); return; } //å‰ªæä¼˜åŒ–ï¼Œç”±i \u0026lt; n ä¼˜åŒ–ä¸º // å‰©ä½™çš„å…ƒç´ ä¸ä¸‹æ ‡i(begin)çš„å…³ç³»å¿…é¡»æ»¡è¶³ k - cur.size() \u0026lt; n -i +1 //ä¸‹æ ‡æ˜¯ä»beginæ˜¯ä»0å¼€å§‹ï¼Œæ‰€ä»¥è®¡ç®—ä¸Šé¢\u0026lt;ä¸ç­‰å¼å³è¾¹éœ€è¦+1 for(int i = begin; i \u0026lt; nums.length -(k - cur.size() -1); i++){ cur.add(nums[i]); dfs(nums, i+1, k, cur, subsets); cur.remove(cur.size()-1); } } } // @lc code=end ","date":"2024-01-25T00:00:00Z","permalink":"https://kris0325.github.io/p/78.subsets/","title":"78.subsets"},{"content":"å›æº¯ç®—æ³• ä»€ä¹ˆæ˜¯å›æº¯æ³• å›æº¯æ³•ä¹Ÿå¯ä»¥å«åšå›æº¯æœç´¢æ³•ï¼Œå®ƒæ˜¯ä¸€ç§æœç´¢çš„æ–¹å¼ã€‚\nåœ¨äºŒå‰æ ‘ç³»åˆ—ä¸­ï¼Œæˆ‘ä»¬å·²ç»ä¸æ­¢ä¸€æ¬¡ï¼Œæåˆ°äº†å›æº¯ï¼Œä¾‹å¦‚äºŒå‰æ ‘ï¼šä»¥ä¸ºä½¿ç”¨äº†é€’å½’ï¼Œå…¶å®è¿˜éšè—ç€å›æº¯ (opens new window)ã€‚\nå›æº¯æ˜¯é€’å½’çš„å‰¯äº§å“ï¼Œåªè¦æœ‰é€’å½’å°±ä¼šæœ‰å›æº¯ã€‚\næ‰€ä»¥ä»¥ä¸‹è®²è§£ä¸­ï¼Œå›æº¯å‡½æ•°ä¹Ÿå°±æ˜¯é€’å½’å‡½æ•°ï¼ŒæŒ‡çš„éƒ½æ˜¯ä¸€ä¸ªå‡½æ•°ã€‚\nå›æº¯æ³•çš„æ•ˆç‡ å›æº¯æ³•çš„æ€§èƒ½å¦‚ä½•å‘¢ï¼Œè¿™é‡Œè¦å’Œå¤§å®¶è¯´æ¸…æ¥šäº†ï¼Œè™½ç„¶å›æº¯æ³•å¾ˆéš¾ï¼Œå¾ˆä¸å¥½ç†è§£ï¼Œä½†æ˜¯å›æº¯æ³•å¹¶ä¸æ˜¯ä»€ä¹ˆé«˜æ•ˆçš„ç®—æ³•ã€‚\nå› ä¸ºå›æº¯çš„æœ¬è´¨æ˜¯ç©·ä¸¾ï¼Œç©·ä¸¾æ‰€æœ‰å¯èƒ½ï¼Œç„¶åé€‰å‡ºæˆ‘ä»¬æƒ³è¦çš„ç­”æ¡ˆï¼Œå¦‚æœæƒ³è®©å›æº¯æ³•é«˜æ•ˆä¸€äº›ï¼Œå¯ä»¥åŠ ä¸€äº›å‰ªæçš„æ“ä½œï¼Œä½†ä¹Ÿæ”¹ä¸äº†å›æº¯æ³•å°±æ˜¯ç©·ä¸¾çš„æœ¬è´¨ã€‚\né‚£ä¹ˆæ—¢ç„¶å›æº¯æ³•å¹¶ä¸é«˜æ•ˆä¸ºä»€ä¹ˆè¿˜è¦ç”¨å®ƒå‘¢ï¼Ÿ\nå› ä¸ºæ²¡å¾—é€‰ï¼Œä¸€äº›é—®é¢˜èƒ½æš´åŠ›æœå‡ºæ¥å°±ä¸é”™äº†ï¼Œæ’‘æ­»äº†å†å‰ªæä¸€ä¸‹ï¼Œè¿˜æ²¡æœ‰æ›´é«˜æ•ˆçš„è§£æ³•ã€‚\næ­¤æ—¶å¤§å®¶åº”è¯¥å¥½å¥‡äº†ï¼Œéƒ½ä»€ä¹ˆé—®é¢˜ï¼Œè¿™ä¹ˆç‰›é€¼ï¼Œåªèƒ½æš´åŠ›æœç´¢ã€‚\nå›æº¯æ³•è§£å†³çš„é—®é¢˜ å›æº¯æ³•ï¼Œä¸€èˆ¬å¯ä»¥è§£å†³å¦‚ä¸‹å‡ ç§é—®é¢˜ï¼š\nç»„åˆé—®é¢˜ï¼šNä¸ªæ•°é‡Œé¢æŒ‰ä¸€å®šè§„åˆ™æ‰¾å‡ºkä¸ªæ•°çš„é›†åˆ\nåˆ‡å‰²é—®é¢˜ï¼šä¸€ä¸ªå­—ç¬¦ä¸²æŒ‰ä¸€å®šè§„åˆ™æœ‰å‡ ç§åˆ‡å‰²æ–¹å¼\nå­é›†é—®é¢˜ï¼šä¸€ä¸ªNä¸ªæ•°çš„é›†åˆé‡Œæœ‰å¤šå°‘ç¬¦åˆæ¡ä»¶çš„å­é›†\næ’åˆ—é—®é¢˜ï¼šNä¸ªæ•°æŒ‰ä¸€å®šè§„åˆ™å…¨æ’åˆ—ï¼Œæœ‰å‡ ç§æ’åˆ—æ–¹å¼\næ£‹ç›˜é—®é¢˜ï¼šNçš‡åï¼Œè§£æ•°ç‹¬ç­‰ç­‰ ç›¸ä¿¡å¤§å®¶çœ‹ç€è¿™äº›ä¹‹åä¼šå‘ç°ï¼Œæ¯ä¸ªé—®é¢˜ï¼Œéƒ½ä¸ç®€å•ï¼\nå¦‚ä½•ç†è§£å›æº¯æ³• å›æº¯æ³•è§£å†³çš„é—®é¢˜éƒ½å¯ä»¥æŠ½è±¡ä¸ºæ ‘å½¢ç»“æ„ï¼Œæ˜¯çš„ï¼Œæˆ‘æŒ‡çš„æ˜¯æ‰€æœ‰å›æº¯æ³•çš„é—®é¢˜éƒ½å¯ä»¥æŠ½è±¡ä¸ºæ ‘å½¢ç»“æ„ï¼\nå› ä¸ºå›æº¯æ³•è§£å†³çš„éƒ½æ˜¯åœ¨é›†åˆä¸­é€’å½’æŸ¥æ‰¾å­é›†ï¼Œé›†åˆçš„å¤§å°å°±æ„æˆäº†æ ‘çš„å®½åº¦ï¼Œé€’å½’çš„æ·±åº¦å°±æ„æˆäº†æ ‘çš„æ·±åº¦ã€‚\né€’å½’å°±è¦æœ‰ç»ˆæ­¢æ¡ä»¶ï¼Œæ‰€ä»¥å¿…ç„¶æ˜¯ä¸€æ£µé«˜åº¦æœ‰é™çš„æ ‘ï¼ˆNå‰æ ‘ï¼‰ã€‚\nè¿™å—å¯èƒ½åˆå­¦è€…è¿˜ä¸å¤ªç†è§£ï¼Œåé¢çš„å›æº¯ç®—æ³•è§£å†³çš„æ‰€æœ‰é¢˜ç›®ä¸­ï¼Œæˆ‘éƒ½ä¼šå¼ºè°ƒè¿™ä¸€ç‚¹å¹¶ç”»å›¾ä¸¾ç›¸åº”çš„ä¾‹å­ï¼Œç°åœ¨æœ‰ä¸€ä¸ªå°è±¡å°±è¡Œã€‚\nå›æº¯æ³•æ¨¡æ¿ è¿™é‡Œç»™å‡ºCarlæ€»ç»“çš„å›æº¯ç®—æ³•æ¨¡æ¿ã€‚\nåœ¨è®²äºŒå‰æ ‘çš„é€’å½’ ä¸­æˆ‘ä»¬è¯´äº†é€’å½’ä¸‰éƒ¨æ›²ï¼Œè¿™é‡Œæˆ‘å†ç»™å¤§å®¶åˆ—å‡ºå›æº¯ä¸‰éƒ¨æ›²ã€‚\nå›æº¯å‡½æ•°æ¨¡æ¿è¿”å›å€¼ä»¥åŠå‚æ•° åœ¨å›æº¯ç®—æ³•ä¸­ï¼Œæˆ‘çš„ä¹ æƒ¯æ˜¯å‡½æ•°èµ·åå­—ä¸ºbacktrackingï¼Œè¿™ä¸ªèµ·åå¤§å®¶éšæ„ã€‚\nå›æº¯ç®—æ³•ä¸­å‡½æ•°è¿”å›å€¼ä¸€èˆ¬ä¸ºvoidã€‚\nå†æ¥çœ‹ä¸€ä¸‹å‚æ•°ï¼Œå› ä¸ºå›æº¯ç®—æ³•éœ€è¦çš„å‚æ•°å¯ä¸åƒäºŒå‰æ ‘é€’å½’çš„æ—¶å€™é‚£ä¹ˆå®¹æ˜“ä¸€æ¬¡æ€§ç¡®å®šä¸‹æ¥ï¼Œæ‰€ä»¥ä¸€èˆ¬æ˜¯å…ˆå†™é€»è¾‘ï¼Œç„¶åéœ€è¦ä»€ä¹ˆå‚æ•°ï¼Œå°±å¡«ä»€ä¹ˆå‚æ•°ã€‚\nä½†åé¢çš„å›æº¯é¢˜ç›®çš„è®²è§£ä¸­ï¼Œä¸ºäº†æ–¹ä¾¿å¤§å®¶ç†è§£ï¼Œæˆ‘åœ¨ä¸€å¼€å§‹å°±å¸®å¤§å®¶æŠŠå‚æ•°ç¡®å®šä¸‹æ¥ã€‚\nå›æº¯å‡½æ•°ä¼ªä»£ç å¦‚ä¸‹ï¼š\nvoid backtracking(å‚æ•°) å›æº¯å‡½æ•°ç»ˆæ­¢æ¡ä»¶ æ—¢ç„¶æ˜¯æ ‘å½¢ç»“æ„ï¼Œé‚£ä¹ˆæˆ‘ä»¬åœ¨è®²è§£äºŒå‰æ ‘çš„é€’å½’ (opens new window)çš„æ—¶å€™ï¼Œå°±çŸ¥é“éå†æ ‘å½¢ç»“æ„ä¸€å®šè¦æœ‰ç»ˆæ­¢æ¡ä»¶ã€‚\næ‰€ä»¥å›æº¯ä¹Ÿæœ‰è¦ç»ˆæ­¢æ¡ä»¶ã€‚\nä»€ä¹ˆæ—¶å€™è¾¾åˆ°äº†ç»ˆæ­¢æ¡ä»¶ï¼Œæ ‘ä¸­å°±å¯ä»¥çœ‹å‡ºï¼Œä¸€èˆ¬æ¥è¯´æœåˆ°å¶å­èŠ‚ç‚¹äº†ï¼Œä¹Ÿå°±æ‰¾åˆ°äº†æ»¡è¶³æ¡ä»¶çš„ä¸€æ¡ç­”æ¡ˆï¼ŒæŠŠè¿™ä¸ªç­”æ¡ˆå­˜æ”¾èµ·æ¥ï¼Œå¹¶ç»“æŸæœ¬å±‚é€’å½’ã€‚\næ‰€ä»¥å›æº¯å‡½æ•°ç»ˆæ­¢æ¡ä»¶ä¼ªä»£ç å¦‚ä¸‹ï¼š\n1 2 3 4 if (ç»ˆæ­¢æ¡ä»¶) { å­˜æ”¾ç»“æœ; return; } å›æº¯æœç´¢çš„éå†è¿‡ç¨‹ åœ¨ä¸Šé¢æˆ‘ä»¬æåˆ°äº†ï¼Œå›æº¯æ³•ä¸€èˆ¬æ˜¯åœ¨é›†åˆä¸­é€’å½’æœç´¢ï¼Œé›†åˆçš„å¤§å°æ„æˆäº†æ ‘çš„å®½åº¦ï¼Œé€’å½’çš„æ·±åº¦æ„æˆçš„æ ‘çš„æ·±åº¦ã€‚\næ³¨æ„å›¾ä¸­ï¼Œæˆ‘ç‰¹æ„ä¸¾ä¾‹é›†åˆå¤§å°å’Œå­©å­çš„æ•°é‡æ˜¯ç›¸ç­‰çš„ï¼\nå›æº¯å‡½æ•°éå†è¿‡ç¨‹ä¼ªä»£ç å¦‚ä¸‹ï¼š\n1 2 3 4 5 for (é€‰æ‹©ï¼šæœ¬å±‚é›†åˆä¸­å…ƒç´ ï¼ˆæ ‘ä¸­èŠ‚ç‚¹å­©å­çš„æ•°é‡å°±æ˜¯é›†åˆçš„å¤§å°ï¼‰) { å¤„ç†èŠ‚ç‚¹; backtracking(è·¯å¾„ï¼Œé€‰æ‹©åˆ—è¡¨); // é€’å½’ å›æº¯ï¼Œæ’¤é”€å¤„ç†ç»“æœ } forå¾ªç¯å°±æ˜¯éå†é›†åˆåŒºé—´ï¼Œå¯ä»¥ç†è§£ä¸€ä¸ªèŠ‚ç‚¹æœ‰å¤šå°‘ä¸ªå­©å­ï¼Œè¿™ä¸ªforå¾ªç¯å°±æ‰§è¡Œå¤šå°‘æ¬¡ã€‚\nbacktrackingè¿™é‡Œè‡ªå·±è°ƒç”¨è‡ªå·±ï¼Œå®ç°é€’å½’ã€‚\nå¤§å®¶å¯ä»¥ä»å›¾ä¸­çœ‹å‡ºforå¾ªç¯å¯ä»¥ç†è§£æ˜¯æ¨ªå‘éå†ï¼Œbacktrackingï¼ˆé€’å½’ï¼‰å°±æ˜¯çºµå‘éå†ï¼Œè¿™æ ·å°±æŠŠè¿™æ£µæ ‘å…¨éå†å®Œäº†ï¼Œä¸€èˆ¬æ¥è¯´ï¼Œæœç´¢å¶å­èŠ‚ç‚¹å°±æ˜¯æ‰¾çš„å…¶ä¸­ä¸€ä¸ªç»“æœäº†ã€‚\nåˆ†æå®Œè¿‡ç¨‹ï¼Œå›æº¯ç®—æ³•æ¨¡æ¿æ¡†æ¶å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 void backtracking(å‚æ•°) { if (ç»ˆæ­¢æ¡ä»¶) { å­˜æ”¾ç»“æœ; return; } for (é€‰æ‹©ï¼šæœ¬å±‚é›†åˆä¸­å…ƒç´ ï¼ˆæ ‘ä¸­èŠ‚ç‚¹å­©å­çš„æ•°é‡å°±æ˜¯é›†åˆçš„å¤§å°ï¼‰) { å¤„ç†èŠ‚ç‚¹; backtracking(è·¯å¾„ï¼Œé€‰æ‹©åˆ—è¡¨); // é€’å½’ å›æº¯ï¼Œæ’¤é”€å¤„ç†ç»“æœ } } é€‚ç”¨é¢˜å‹ï¼šåˆ—å‡ºæ‰€æœ‰å¯èƒ½çš„é€‰æ‹©å¦‚ï¼šç»„åˆï¼Œåˆ‡å‰²ï¼Œéƒ¨åˆ†å­é›†é—®é¢˜ï¼Œæ’åˆ—ï¼Œæ£‹ç›˜ e.g. leetcode 17.ç”µè¯å·ç ç»„åˆ\nç®—æ³•æ¨¡æ¿ï¼š\n1 2 3 4 5 6 7 8 9 10 void backstracking(List\u0026lt;Sting\u0026gt; arg1, Integer arg2...){ if(å‡ºå£çš„ç»ˆæ­¢æ¡ä»¶){ æ”¶é›†ç»“æœï¼› rerun; } for(é›†åˆå…ƒç´ ){ å¤„ç†èŠ‚ç‚¹ï¼› è°ƒç”¨é€’å½’å‡½æ•°backstrackingï¼› å›æº¯æ“ä½œï¼› } https://www.youtube.com/watch?v=ev5XJ78Fn84\n","date":"2024-01-25T00:00:00Z","image":"https://kris0325.github.io/p/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/backtracking_hu2e5a54eaf2acbac44f9a9ce7d3337f38_346767_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","title":"å›æº¯ç®—æ³•"},{"content":"å’Œè¨±å¤šä¹åå¹´ä»£å‡ºç”Ÿçš„äººä¸€æ¨£ï¼Œé¦™æ¸¯é»ƒé‡‘æ™‚ä»£çš„ç¶“å…¸é›»å½±èˆ‡æµè¡Œæ­Œæ›²ä¸€è·¯ä¼´éš¨æˆ‘æˆé•·ï¼Œèµ°éå¤¢å¹»çš„ç«¥å¹´ã€‚ é‚£æ™‚çš„é¦™æ¸¯æ­£è™•æ–¼ä¸€å€‹å¦‚å¤¢ä¼¼å¹»æ­²æœˆæµé‡‘çš„å¹´ä»£ï¼Œæ˜¯ä¸€åº§è®“äººå°æœªä¾†çš„å……æ»¿å¸Œæœ›ï¼Œä»¤äººè‘—è¿·çš„åŸå¸‚ã€‚ æ–¼æ˜¯æƒ³è‘—æœ‰æœä¸€æ—¥ï¼Œå®šè¦å»æ‹œè¨ªçœ‹çœ‹ã€‚\nå·¥ä½œå¾Œï¼Œå»éå¾ˆå¤šåœ°æ–¹ï¼Œä¸çŸ¥ä½•æ™‚èµ·æ¼¸æ¼¸è¦ºå¾—ï¼Œå’Œæˆ‘æ‰€åœ¨çš„åŸå¸‚ä¸Šæµ·æ¯”ï¼Œé¦™æ¸¯æ‡‰è©²ä¹Ÿåªæ˜¯å¦ä¸€åº§æ‘©ç™»éƒ½å¸‚ï¼Œåè€Œæ²’æœ‰å¾ˆæƒ³å»æ¢ç´¢çš„æ…¾æœ›ã€‚ æ¯æ¬¡å‡ºé–€æ—…è¡Œï¼Œç¸½æ˜¯å‚¾å‘å»ç•°åœ‹éŠç©ã€‚\nå»å¹´å› ç‚ºä¸Šæµ·lockdownï¼Œè®“æˆ‘å€‘éŒ¯éäº†æ•´å€‹æ˜¥å¤©ã€‚ è¢«å¥ªèµ°çš„ç¾å¥½çš„æ±è¥¿ï¼Œç¸½æƒ³è‘—æ‰¾å›ä¾†ï¼Œé‚£æ™‚å€™å°±å†æƒ³ï¼Œè§£å°å¾Œä¸€å®šè¦å‡ºè¶Ÿé é–€ï¼Œå»å‘¼å¸é‚£æ–°é®®è‡ªç”±çš„ç©ºæ°£ï¼ ç­‰éå®Œæ˜¥ç¯€å›ä¸Šæµ·ï¼Œä¸€åˆ‡éƒ½é‚„æœªå¾lockdownä¸­ç·©éç¥ä¾†ï¼Œè€ƒæ…®åˆ°ç•¶æ™‚æƒ…æ³ï¼Œé¦™æ¸¯ä¾¿æˆäº†å¯é¸çš„é¦–ç«™åŸå¸‚ã€‚\n2023å¹´è¾²æ›†æ­£æœˆåˆåï¼Œåˆæ˜¥ï¼Œå’‹æš–é‚„å¯’ï¼Œå¸¶è‘—ä¸€è·¯èˆˆå¥®èˆ‡æœŸå¾…ï¼Œæˆ‘å€‘åä¸Šäº†ä¸Šæµ·é£›å¾€é¦™æ¸¯çš„é£›æ©Ÿï¼\nä¸‹æ¦»çš„é£¯åº—è®“äººæƒ³èµ·äº†å¸ƒé”ä½©æ–¯å¤§é£¯åº— å…ƒå®µç¯€åœ¨é£¯åº—æ—éš¨æ©Ÿçš„é¸åˆ°çš„ä¸€å®¶å¥½åƒçš„èŒ¶é¤å»³ åƒè§€é¦™æ¸¯æ•…å®®åšç‰©é™¢ï¼Œçœ‹åˆ°äº†è¨±å¤šæ˜æ¸…æ™‚æœŸçš„å±•å“ï¼Œè—‰æ­¤ä¸€çªºé‚£å€‹æ™‚ä»£äººå€‘çš„ç”Ÿæ´»ã€‚\nåšç‰©é™¢çš„å±•å“ è¡—é‚Šçš„å¥½åƒçš„é›è›‹ä»” åœ¨åšç‰©é™¢çš„éœ²è‡ºä¸Šä¿¯ç°ç¶­æ¸¯ è¶•åœ¨é»ƒæ˜æ—¥è½å‰ï¼Œçˆ¬ä¸Šå¤ªå¹³å±±é ‚ï¼Œè¿½åˆ°äº†æœ€å¾Œä¸€æŠ¹å¤•é™½çš„æŸ”å…‰ï¼Œé€™æ™‚å±±é–“å¹ä¾†é™£é™£æ¶¼é¢¨ï¼Œæ‹‚å»ç™½æ—¥çš„äº›è¨±æ‚¶ç†±ï¼Œä¸€åˆ‡ä»¤äººèˆ’é©é¬†å¼›ã€‚\nå¤ªå¹³å±±é ‚çš„æ—¥è½ åœ“æœˆå‡èµ·ï¼Œæµ·é¢¨å¹æ‹‚è‘—äº”åƒå¹´çš„ç¶­æ¸¯ å¤œå¹•é™ä¸´ï¼Œä¿¯ç°åç¯åˆä¸Šçš„åŸå¸‚ æœªå®Œå¾…çºŒ\u0026hellip;\n","date":"2024-01-24T00:00:00Z","image":"https://kris0325.github.io/p/hong-kong-memories/1_hudef55410758b11b92016a31532bb1813_84464_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/hong-kong-memories/","title":"Hong Kong Memories"},{"content":"å¦‚ä½•ç”¨ GitHub Pages + Hugo æ­å»ºä¸ªäººåšå®¢ https://cuttontail.blog/blog/create-a-wesite-using-github-pages-and-hugo/#1-%E6%A6%82%E5%BF%B5%E6%90%AD%E5%BB%BA%E6%80%9D%E8%B7%AF%E5%92%8C%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83\nFor more information about this theme, check the documentation: https://stack.jimmycai.com/\nWant a site like this? Check out hugo-theme-stack-stater\næ¦‚å¿µï¼Œæ­å»ºæ€è·¯å’Œè¿è¡Œç¯å¢ƒ 1.1 ä»€ä¹ˆæ˜¯ GitHub Pagesï¼Ÿ 1.2 ä»€ä¹ˆæ˜¯ Hugoï¼Ÿ 1.3 ç½‘ç«™æ­å»ºæ€è·¯ 1.4 è¿è¡Œç¯å¢ƒ å®‰è£… Hugo åˆ›å»º GitHub ä»“åº“ 3.1 åˆ›å»ºåšå®¢æºä»“åº“ 3.2 åˆ›å»º GitHub Page ä»“åº“ å…‹éš†åšå®¢æºä»“åº“åˆ°æœ¬åœ° ä½¿ç”¨ Hugo åˆ›å»ºç½‘ç«™ å®‰è£…å’Œé…ç½® Hugo ä¸»é¢˜ 6.1 é€‰æ‹© Hugo ä¸»é¢˜ 6.2 å®‰è£… Hugo ä¸»é¢˜ 6.3 é…ç½® Hugo ä¸»é¢˜ ç”¨ Hugo åˆ›å»ºæ–‡ç«  æœ¬åœ°è°ƒè¯•å’Œé¢„è§ˆ å‘å¸ƒå†…å®¹ Reference 1. æ¦‚å¿µï¼Œæ­å»ºæ€è·¯å’Œè¿è¡Œç¯å¢ƒ# 1.1 ä»€ä¹ˆæ˜¯ GitHub Pagesï¼Ÿ# GitHub Pages æ˜¯ä¸€ç»„é™æ€ç½‘é¡µé›†åˆï¼ˆStatic Web Pageï¼‰ï¼Œè¿™äº›é™æ€ç½‘é¡µç”± GitHub æ‰˜ç®¡ï¼ˆhostï¼‰å’Œå‘å¸ƒï¼Œæ‰€ä»¥æ˜¯ GitHub + Pagesã€‚\n1.2 ä»€ä¹ˆæ˜¯ Hugoï¼Ÿ# Hugo æ˜¯ç”¨ Go è¯­è¨€å†™çš„é™æ€ç½‘ç«™ç”Ÿæˆå™¨ï¼ˆStatic Site Generatorï¼‰ã€‚å¯ä»¥æŠŠ Markdown æ–‡ä»¶è½¬åŒ–æˆ HTML æ–‡ä»¶ã€‚\n1.3 ç½‘ç«™æ­å»ºæ€è·¯ åˆ›å»º 2 ä¸ª GitHub ä»“åº“ åšå®¢æºä»“åº“ï¼šå‚¨å­˜æ‰€æœ‰ Markdown æºæ–‡ä»¶ï¼ˆåšå®¢å†…å®¹ï¼‰ï¼Œå’Œåšå®¢ä¸­ç”¨åˆ°çš„å›¾ç‰‡ç­‰ã€‚ GitHub Pages ä»“åº“ï¼šå‚¨å­˜ç”± Hugo ä»Markdown æ–‡ä»¶ç”Ÿæˆçš„ HTML æ–‡ä»¶ã€‚ å°†åœ¨åšå®¢æºä»“åº“ä¸­ Hugo ç”Ÿæˆçš„é™æ€ HTML æ–‡ä»¶éƒ¨ç½²åˆ°è¿œç«¯ GitHub Pages ä»“åº“ä¸­ã€‚\n1.4 è¿è¡Œç¯å¢ƒ è¿™ç¯‡æ•™ç¨‹å‡è®¾ä½ å·²ç»ï¼š äº†è§£åŸºæœ¬çš„ç»ˆç«¯å‘½ä»¤è¡ŒçŸ¥è¯†ï¼Œå¦‚ï¼šcd, ls å®‰è£…äº† Gitï¼Œå¹¶ä¸”äº†è§£åŸºæœ¬çš„ Git çŸ¥è¯† æœ‰ä¸€ä¸ª GitHubè´¦å· æœ‰è‡ªå·±åå¥½çš„ä»£ç ç¼–è¾‘å™¨ï¼ˆæˆ‘ä½¿ç”¨çš„æ˜¯ VS Codeï¼‰\n2. å®‰è£… Hugo è¿™é‡Œä½¿ç”¨åŒ…ç®¡ç†å™¨å®‰è£… Hugoï¼Œæˆ‘çš„æ“ä½œç³»ç»Ÿæ˜¯ Mac OSï¼Œæ‰€ä»¥ä½¿ç”¨ Homebrew å®‰è£… Hugoã€‚å¦‚æœä½ ä½¿ç”¨çš„æ˜¯ Windows æˆ– Linuxï¼Œå¯ä»¥æ ¹æ® Hugo æ–‡æ¡£æç¤ºçš„æ–¹å¼å®‰è£…ï¼š Hugo æ–‡æ¡£ï¼šInstall Hugo\nbrew install hugo æŸ¥çœ‹ Hugo æ˜¯å¦å®‰è£…æˆåŠŸï¼Œæ˜¾ç¤º Hugo ç‰ˆæœ¬å·ä»£è¡¨ Hugo å®‰è£…æˆåŠŸã€‚\nhugo version\n3. åˆ›å»º GitHub ä»“åº“ 3.1 åˆ›å»ºåšå®¢æºä»“åº“ å‘½ååšå®¢æºä»“åº“ï¼ˆwhatever you wantï¼‰ å‹¾é€‰ Publicï¼Œè®¾ç½®ä¸ºå…¬å¼€ä»“åº“ã€‚ å‹¾é€‰æ·»åŠ  README æ–‡ä»¶\n3.2 åˆ›å»º GitHub Page ä»“åº“ å‘½å GitHub Pages ä»“åº“ï¼Œè¿™ä¸ªä»“åº“å¿…é¡»ä½¿ç”¨ç‰¹æ®Šçš„å‘½åæ ¼å¼ \u0026lt;username.github.io\u0026gt;ï¼Œ æ˜¯è‡ªå·±çš„ GitHub çš„ç”¨æˆ·åã€‚ å‹¾é€‰ Publicï¼Œè®¾ç½®ä¸ºå…¬å¼€ä»“åº“ã€‚ å‹¾é€‰æ·»åŠ  README æ–‡ä»¶ï¼Œè¿™ä¼šè®¾ç½® main åˆ†æ”¯ä¸ºä»“åº“çš„é»˜è®¤ä¸»åˆ†æ”¯ï¼Œè¿™åœ¨åé¢æäº¤æ¨é€åšå®¢å†…å®¹æ—¶å¾ˆé‡è¦ã€‚\n4. å…‹éš†åšå®¢æºä»“åº“åˆ°æœ¬åœ° æ‰“å¼€æƒ³è¦åœ¨æœ¬åœ°å‚¨å­˜é¡¹ç›®çš„æ–‡ä»¶å¤¹ï¼ˆæ¯”å¦‚æˆ‘çš„é¡¹ç›®çš„æ–‡ä»¶å¤¹æ˜¯ project ï¼‰\ncd project å…‹éš†åšå®¢æºä»“åº“åˆ°é¡¹ç›®æ–‡ä»¶å¤¹ï¼Œå…‹éš†æ—¶ä½¿ç”¨çš„ HTTPS ä»“åº“é“¾æ¥åœ¨è¿™é‡ŒæŸ¥çœ‹ï¼š\ngit clone https://github.com/miawithcode/cuttontail.git\n5. ä½¿ç”¨ Hugo åˆ›å»ºç½‘ç«™ è¿›å…¥åˆšåˆšå…‹éš†ä¸‹æ¥çš„åšå®¢æºä»“åº“æ–‡ä»¶å¤¹ï¼ˆæ¯”å¦‚ï¼šæˆ‘çš„åšå®¢æºä»“åº“æ–‡ä»¶å¤¹åæ˜¯ cuttontailï¼Œåˆ™cd cuttontail ï¼‰ï¼Œåœ¨è¿™ä¸ªæ–‡ä»¶å¤¹é‡Œç”¨ Hugo åˆ›å»ºä¸€ä¸ªç½‘ç«™æ–‡ä»¶å¤¹ã€‚\nç”¨ Hugo åˆ›å»ºç½‘ç«™æ–‡ä»¶å¤¹çš„å‘½ä»¤æ˜¯ hugo new site ç½‘ç«™åå­—ã€‚(æ¯”å¦‚ï¼Œæˆ‘çš„å‘½åæ˜¯ cuttontail-blog)\ncd cuttontail hugo new site cuttontail-blog\nç”¨ Hugo åˆ›å»ºçš„ç½‘ç«™å…±æœ‰ 7 ä¸ªæ–‡ä»¶å¤¹å’Œ 1 ä¸ªæ–‡ä»¶ï¼Œè¿™äº›æ–‡ä»¶åˆ†åˆ«ä»£è¡¨ï¼š\narchetypesï¼šå­˜æ”¾ç”¨ hugo å‘½ä»¤æ–°å»ºçš„ Markdown æ–‡ä»¶åº”ç”¨çš„ front matter æ¨¡ç‰ˆ contentï¼šå­˜æ”¾å†…å®¹é¡µé¢ï¼Œæ¯”å¦‚ã€Œåšå®¢ã€ã€ã€Œè¯»ä¹¦ç¬”è®°ã€ç­‰ layoutsï¼šå­˜æ”¾å®šä¹‰ç½‘ç«™çš„æ ·å¼ï¼Œå†™åœ¨layoutsæ–‡ä»¶ä¸‹çš„æ ·å¼ä¼šè¦†ç›–å®‰è£…çš„ä¸»é¢˜ä¸­çš„ layoutsæ–‡ä»¶åŒåçš„æ ·å¼ staticï¼šå­˜æ”¾æ‰€æœ‰é™æ€æ–‡ä»¶ï¼Œå¦‚å›¾ç‰‡ dataï¼šå­˜æ”¾åˆ›å»ºç«™ç‚¹æ—¶ Hugo ä½¿ç”¨çš„å…¶ä»–æ•°æ® publicï¼šå­˜æ”¾ Hugo ç”Ÿæˆçš„é™æ€ç½‘é¡µ themesï¼šå­˜æ”¾ä¸»é¢˜æ–‡ä»¶ config.tomlï¼šç½‘ç«™é…ç½®æ–‡ä»¶ 6.å®‰è£…å’Œé…ç½® Hugo ä¸»é¢˜ 6.1 é€‰æ‹© Hugo ä¸»é¢˜# å¯ä»¥ä» Hugo ç¤¾åŒºæä¾›çš„ä¸»é¢˜ä¸­é€‰æ‹©ä¸€ä¸ªå–œæ¬¢çš„ä¸»é¢˜åº”ç”¨åœ¨è‡ªå·±çš„ç½‘ç«™ä¸­ã€‚\n6.2 å®‰è£… Hugo ä¸»é¢˜# ä¸€èˆ¬åœ¨ä½ é€‰æ‹©çš„ Hugo ä¸»é¢˜çš„æ–‡æ¡£ä¸­ï¼Œéƒ½ä¼šç»™å‡ºã€Œå¦‚ä½•å®‰è£…è¿™ä¸ªä¸»é¢˜ã€çš„å‘½ä»¤ï¼Œæ¯”å¦‚æˆ‘é€‰ç”¨çš„ Hugo Bear Blog çš„æ–‡æ¡£ä¸­ç»™å‡ºï¼š\næ‰“å¼€åˆšåˆšç”¨ Hugo åˆ›å»ºçš„ç½‘ç«™æ–‡ä»¶å¤¹ï¼ˆæˆ‘çš„æ˜¯ cuttontail-blogï¼‰ï¼Œåœ¨ç»ˆç«¯ç²˜è´´æ–‡æ¡£ä¸­ç»™å‡ºçš„å®‰è£…å‘½ä»¤ã€‚\n7. ç”¨ Hugo åˆ›å»ºæ–‡ç«  ç”¨ Hugo åˆ›å»ºä¸€ç¯‡æ–‡ç« çš„å‘½ä»¤æ˜¯:\nhugo new xxx.md ç”¨è¿™ä¸ªå‘½ä»¤åˆ›å»ºçš„ Markdown æ–‡ä»¶ä¼šå¥—ç”¨ archetypes æ–‡ä»¶å¤¹ä¸­çš„ front matter æ¨¡ç‰ˆï¼Œåœ¨ç©ºç™½å¤„ç”¨ Markdown å†™å…¥å†…å®¹ã€‚\nå…¶ä¸­ï¼Œdraft: trueä»£è¡¨è¿™ç¯‡æ–‡ç« æ˜¯ä¸€ä¸ªè‰ç¨¿ï¼ŒHugo ä¸ä¼šæ˜¾ç¤ºè‰ç¨¿ï¼Œè¦åœ¨ä¸»é¡µæ˜¾ç¤ºæ·»åŠ çš„æ–‡ç« ï¼Œå¯ä»¥è®¾ç½® draft: falseï¼›æˆ–è€…ç›´æ¥åˆ æ‰è¿™è¡Œã€‚\n8. æœ¬åœ°è°ƒè¯•å’Œé¢„è§ˆ# åœ¨å‘å¸ƒåˆ°ç½‘ç«™å‰å¯ä»¥åœ¨æœ¬åœ°é¢„è§ˆç½‘ç«™æˆ–å†…å®¹çš„æ•ˆæœï¼Œè¿è¡Œå‘½ä»¤ï¼š hugo server\nä¹Ÿå¯ä»¥åœ¨æœ¬åœ°ç¼–è¾‘ Markdown æ–‡ä»¶æ—¶ï¼Œé€šè¿‡ hugo server æ¥å®æ—¶é¢„è§ˆæ˜¾ç¤ºæ•ˆæœã€‚ hugo server è¿è¡ŒæˆåŠŸåï¼Œå¯ä»¥åœ¨ http://localhost:1313/ ä¸­é¢„è§ˆç½‘ç«™\n9. å‘å¸ƒå†…å®¹ hugo å‘½ä»¤å¯ä»¥å°†ä½ å†™çš„ Markdown æ–‡ä»¶ç”Ÿæˆé™æ€ HTML ç½‘é¡µï¼Œç”Ÿæˆçš„ HTML æ–‡ä»¶é»˜è®¤å­˜æ”¾åœ¨ public æ–‡ä»¶å¤¹ä¸­ã€‚\nhugo\nå› ä¸ºhugo ç”Ÿæˆçš„é™æ€ HTML ç½‘é¡µæ–‡ä»¶é»˜è®¤å­˜æ”¾åœ¨ public æ–‡ä»¶ä¸­ï¼Œæ‰€ä»¥æ¨é€ç½‘é¡µå†…å®¹åªéœ€è¦æŠŠ public ä¸­çš„ HTML ç½‘é¡µæ–‡ä»¶å‘å¸ƒåˆ° GitHub Pages ä»“åº“ä¸­ã€‚\nå°† public æ–‡ä»¶å¤¹åˆå§‹åŒ–ä¸º Git ä»“åº“ï¼Œå¹¶è®¾ç½®é»˜è®¤ä¸»åˆ†æ”¯åä¸º mainã€‚è¿™ä¹ˆåšçš„åŸå› æ˜¯ï¼š\nGitHub åˆ›å»ºä»“åº“æ—¶ç”Ÿæˆçš„é»˜è®¤ä¸»åˆ†æ”¯åæ˜¯ main ç”¨ git init åˆå§‹åŒ– Git ä»“åº“æ—¶åˆ›å»ºçš„é»˜è®¤ä¸»åˆ†æ”¯åæ˜¯ master å°† git init åˆ›å»ºçš„ master ä¿®æ”¹æˆ main ï¼Œå†æ¨é€ç»™è¿œç«¯ä»“åº“ .github.io ï¼Œè¿™æ ·æ‰ä¸ä¼šæŠ¥é”™ã€‚ cd public git init -b main\nå°† public æ–‡ä»¶å¤¹å…³è”è¿œç¨‹ GitHub Pages ä»“åº“ï¼Œä½¿ç”¨ GitHub Pages ä»“åº“çš„ SSH é“¾æ¥ã€‚\nï¼ˆ âš ï¸ æ³¨æ„ï¼šè¦è®© SSH é“¾æ¥èµ·ä½œç”¨ï¼Œéœ€è¦ä½ æ·»åŠ è¿‡ SSH Keyã€‚å¦‚æœä½ æ²¡æœ‰è®¾ç½®è¿‡ SSH Keyï¼Œè¯·å‚è€ƒ å¦‚ä½•åœ¨ Mac ä¸Šä¸º GitHub è®¾ç½® SSH Keyï¼‰\nGitHub Pages ä»“åº“çš„ SSH é“¾æ¥å¯ä»¥åœ¨è¿™é‡ŒæŸ¥çœ‹ï¼š\ngit remote add origin git@github.com:miawithcode/miawithcode.github.io.git\næ¨é€åšå®¢æºä»“åº“çš„ public æ–‡ä»¶å¤¹ä¸­çš„ HTML ç½‘é¡µæ–‡ä»¶åˆ° GitHub Pages ä»“åº“ ä¸­ï¼Œåœ¨æ¨é€ä»“åº“å†…å®¹å‰è¦å…ˆç”¨ git pull \u0026ndash;rebase origin main å’Œè¿œç«¯ä»“åº“åŒæ­¥ï¼Œå¦åˆ™ä¼šæŠ¥é”™ã€‚\ngit pull \u0026ndash;rebase origin main git add . git commit -m \u0026ldquo;\u0026hellip;(ä¿®æ”¹çš„ä¿¡æ¯)\u0026rdquo; git push origin main\nè½¬åˆ° GitHub æŸ¥çœ‹ GitHub Pages ä»“åº“ä¸­æ˜¯å¦å­˜åœ¨åˆšåˆšæ¨é€çš„æ–‡ä»¶ï¼Œå­˜åœ¨åˆ™ä»£è¡¨æ¨é€æˆåŠŸã€‚\nå¦‚æœä½ æ²¡æœ‰è®¾ç½®è‡ªå®šä¹‰åŸŸåï¼Œä¸”æŠŠ comfig.toml æ–‡ä»¶ä¸­çš„ baseURL è®¾ç½®ä¸º https://.github.ioï¼Œå°±å¯ä»¥åœ¨ https://username.github.io ä¸­æŸ¥çœ‹åˆšåˆšåˆ›å»ºçš„ç½‘ç«™ã€‚ ( ğŸ‘€ æˆ‘ä½¿ç”¨çš„æ˜¯è‡ªå®šä¹‰åŸŸåï¼Œæ‰€ä»¥è¿™é‡Œç”¨æˆ‘çš„è‡ªå®šä¹‰åŸŸåæŸ¥çœ‹ã€‚)\nåç»­çš„æ›´æ–°æ­¥éª¤ï¼š\nåˆ›å»ºä½ çš„æ–‡ç« xxx.md ç”¨ hugo server åœ¨æœ¬åœ°é¢„è§ˆï¼Œæ»¡æ„åå‡†å¤‡å‘å¸ƒã€‚ è¿è¡Œ hugo å‘½ä»¤å°† Markdown æ–‡ä»¶ç”Ÿæˆ HTML æ–‡ä»¶ã€‚ å°†ä¿®æ”¹å…ˆæäº¤è‡³åšå®¢æºä»“åº“ git add . git commit -m \u0026ldquo;\u0026hellip;(ä¿®æ”¹çš„ä¿¡æ¯)\u0026rdquo; git push æ‰“å¼€ public æ–‡ä»¶ è¿è¡Œï¼š git add . git commit -m \u0026ldquo;\u0026hellip;(ä¿®æ”¹çš„ä¿¡æ¯)\u0026rdquo; git pull \u0026ndash;rebase origin main #å¯é€‰,å¦‚æœè¿œç«¯ä»“åº“ä¸æœ¬åœ°ä¸€è‡´ï¼Œåˆ™ä¸éœ€è¦åˆå¹¶ã€‚ git push origin main å¦‚æœä½ ä½¿ç”¨çš„æ˜¯è‡ªå®šä¹‰åŸŸåï¼Œç¬¬ä¸€æ¬¡æ¨é€æˆåŠŸåï¼ŒGitHub Pages ä»“åº“ä¼šç”Ÿæˆ CNAME æ–‡ä»¶ï¼Œæ‰€ä»¥ç¬¬äºŒæ¬¡æ¨é€è¿˜è¦å†åˆå¹¶ä¸€æ¬¡ï¼šgit pull \u0026ndash;rebase origin mainã€‚åç»­æ›´æ–°åšå®¢å°±ä¸å†éœ€è¦ä½¿ç”¨è¿™ä¸ªå‘½ä»¤äº†ã€‚ï¼ˆæ ¹æ®å®é™…æƒ…å†µä½¿ç”¨ï¼‰ å‘å¸ƒå†…å®¹é™¤äº†æ‰‹åŠ¨å‘å¸ƒï¼Œè¿˜èƒ½ä½¿ç”¨ GitHub Action è‡ªåŠ¨å‘å¸ƒã€‚ä½†æˆ‘è®¤ä¸ºåˆšåˆšæ­å»ºå¥½ä¸€ä¸ªç½‘ç«™ï¼Œç«‹åˆ»å°±ç”¨ GitHub Action æœ‰äº› Overwhelmingï¼Œå…ˆå­¦ä¼šæ‰‹åŠ¨å‘å¸ƒï¼Œç†Ÿç»ƒä¹‹åå†å¼€å§‹ä½¿ç”¨ GitHub Action è‡ªåŠ¨å‘å¸ƒä¼šæ¯”è¾ƒå¥½ã€‚\n10. Reference Creating a Blog with Hugo and Github in 10 minutes Hugo + GitHub Actionï¼Œæ­å»ºä½ çš„åšå®¢è‡ªåŠ¨å‘å¸ƒç³»ç»Ÿ Hugo - Quick Start\n","date":"2024-01-24T00:00:00Z","image":"https://kris0325.github.io/p/hello-world/fall_hu5477be140e37c38e9e48439fae2f6b6b_11160813_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/hello-world/","title":"å¦‚ä½•ç”¨ GitHub Pages + Hugo æ­å»ºä¸ªäººåšå®¢"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 /* * @lc app=leetcode id=90 lang=java * * [90] Subsets II * * https://leetcode.com/problems/subsets-ii/description/ * * algorithms * Medium (56.68%) * Likes: 9237 * Dislikes: 265 * Total Accepted: 819.4K * Total Submissions: 1.4M * Testcase Example: \u0026#39;[1,2,2]\u0026#39; * * Given an integer array nums that may contain duplicates, return all possible * subsets (the power set). * * The solution set must not contain duplicate subsets. Return the solution in * any order. * * * Example 1: * Input: nums = [1,2,2] * Output: [[],[1],[1,2],[1,2,2],[2],[2,2]] * Example 2: * Input: nums = [0] * Output: [[],[0]] * * * Constraints: * * * 1 \u0026lt;= nums.length \u0026lt;= 10 * -10 \u0026lt;= nums[i] \u0026lt;= 10 * * * * Solution1 æ€è·¯ï¼šä½¿ç”¨å›æº¯ç®—æ³•, å¯¹uniqueæ•°ç»„çš„å…¨æ’åˆ—çš„å˜ç§ * é—®é¢˜æ‹†åˆ†æˆ ä»nä¸ªå…ƒç´ çš„æ•°ç»„ä¸­é€‰è€…kä¸ªå…ƒç´ çš„ç´ å…¨ç»„åˆ * , å†æ”¶é›†æ‰€æœ‰å­ç»„åˆæ—¶å»é‡å³å¯ * * \u0026gt; https://leetcode.cn/problems/subsets-ii/solutions/1/90-zi-ji-iiche-di-li-jie-zi-ji-wen-ti-ru-djmf/ * Solution2 æ€è·¯ï¼šè¿™é“é¢˜ç›®å’Œ78.å­é›†åŒºåˆ«å°±æ˜¯é›†åˆé‡Œæœ‰é‡å¤å…ƒç´ äº†ï¼Œè€Œä¸”æ±‚å–çš„å­é›†è¦å»é‡ã€‚ * 1 æ³¨æ„å»é‡éœ€è¦å…ˆå¯¹é›†åˆæ’åº * 2 ç”»å‡ºæ ‘å½¢å›¾ï¼Œä»å›¾ä¸­å¯ä»¥çœ‹å‡ºï¼ŒåŒä¸€æ ‘å±‚ä¸Šé‡å¤å–2 å°±è¦è¿‡æ»¤æ‰ï¼Œ * åŒä¸€æ ‘æä¸Šå°±å¯ä»¥é‡å¤å–2ï¼Œå› ä¸ºåŒä¸€æ ‘æä¸Šå…ƒç´ çš„é›†åˆæ‰æ˜¯å”¯ä¸€å­é›†ï¼ */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 // @lc code=start import java.util.ArrayList; import java.util.Arrays; import java.util.List; // Solution1 forå¾ªç¯ä¸­éå†ä¸­æ’åºï¼Œæ—¶é—´å¤æ‚åº¦å¤ªé«˜ class Solution1 { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsetsWithDup(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets = new ArrayList\u0026lt;\u0026gt;(); for(int k = 0; k\u0026lt;= nums.length; k++){ dfs(nums,0,k,new ArrayList\u0026lt;\u0026gt;(),subsets); } return subsets; } public void dfs(int[] nums, int begin, int k, List\u0026lt;Integer\u0026gt; cur , List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets ){ if(k == cur.size()){ //donnot collect dep subset if(isContainTargeList(subsets, new ArrayList\u0026lt;\u0026gt;(cur))){ return; } subsets.add(new ArrayList\u0026lt;\u0026gt;(cur)); return; } for(int i =begin; i \u0026lt;nums.length - (k - cur.size()-1); i++){ cur.add(nums[i]); dfs(nums, i+1, k, cur, subsets); cur.remove(cur.size()-1); } } public boolean isContainTargeList(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets, List\u0026lt;Integer\u0026gt; targeList ){ //å› ä¸ºæ˜¯ç»„åˆï¼Œä¸è€ƒè™‘å…ƒç´ é¡ºåºï¼Œæ‰€æœ‰éœ€è¦éå†subsets,åˆ¤æ–­æ˜¯å¦æ˜¯å¦åŒ…å«ä¸targeListç›¸åŒçš„ç»„åˆ for(int i = 0; i\u0026lt; subsets.size();i++){ Collections.sort(subsets.get(i)); Collections.sort(targeList); if(subsets.get(i).equals(targeList)){ return true; } } return false; } } class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsetsWithDup(int[] nums) { Arrays.sort(nums); dfs(nums,0); return subsets; } public void dfs(int[] nums, int begin){ subsets.add(new ArrayList\u0026lt;\u0026gt;(path)); for(int i = begin; i\u0026lt; nums.length; i++ ){ //æ ‘çš„åŒä¸€å±‚ï¼Œç›¸åŒå…ƒç´ éœ€è¦å»é‡ï¼Œç›´æ¥è·³è¿‡ if(i \u0026gt; begin \u0026amp;\u0026amp; nums[i] == nums[i-1]){ continue; } path.add(nums[i]); dfs(nums, i+1); path.removeLast(); } } } // @lc code=end ","date":"2024-01-23T00:00:00Z","image":"https://kris0325.github.io/p/90.subsets-ii/90_hu5477be140e37c38e9e48439fae2f6b6b_7746938_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/90.subsets-ii/","title":"90.subsets-ii"},{"content":"Hugo theme Stack supports the creation of interactive image galleries using Markdown. It\u0026rsquo;s powered by PhotoSwipe and its syntax was inspired by Typlog.\nTo use this feature, the image must be in the same directory as the Markdown file, as it uses Hugo\u0026rsquo;s page bundle feature to read the dimensions of the image. External images are not supported.\nSyntax 1 ![Image 1](1.jpg) ![Image 2](2.jpg) Result Photo by mymind and Luke Chesser on Unsplash\n","date":"2023-08-26T00:00:00Z","image":"https://kris0325.github.io/p/image-gallery/2_hubce42636ecacc1a380b462f3110efcec_37455_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/image-gallery/","title":"Image gallery"},{"content":" Photo by Codioful on Unsplash\n","date":"2023-08-25T00:00:00Z","image":"https://kris0325.github.io/p/shortcodes/cover_huec3c3e34981507583e214021ad1b9a4b_12942_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/shortcodes/","title":"Shortcodes"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;â€”\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\nâ€” Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements â€” abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://kris0325.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887â€¦$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"https://kris0325.github.io/p/math-typesetting/","title":"Math Typesetting"}]