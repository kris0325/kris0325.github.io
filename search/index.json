[{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* 2024-07-15 18:11:19 Best Time to Buy and Sell Stock Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (53.62%)\t30890\t1149 Tags array | dynamic-programming Companies amazon | bloomberg | facebook | microsoft | uber You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. Example 1: Input: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell. Example 2: Input: prices = [7,6,4,3,1] Output: 0 Explanation: In this case, no transactions are done and the max profit = 0. Constraints: 1 \u0026lt;= prices.length \u0026lt;= 105 0 \u0026lt;= prices[i] \u0026lt;= 104 */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 //leetcode submit region begin(Prohibit modification and deletion) class Solution { //dp: 二維數組， 0｜1表示持有股票｜不持有股票的狀態 //定義 dp[i][0]: 第i天持有股票的最大收益 ， 要么保持前一天持有股票的狀態，要么當天第一次買入股票（那麼收益需要減去當天股票價格，所以為負數：-prices[i]）。 //遞推公式：dp[i][0] = Math.max(dp[i-1][0], -prices[i]) // dp[i][1]: 第i天不持有股票的最大收益，要么保持前一天不持有股票的狀態，要么在當天賣出股票。 // 遞推公式： dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i]) 第i-1天有股票，在i天賣掉股票｜ 第i-1天就不擁有股票，那保持和i-1不變 //初始化， 第0天現金為0， 持有股票，那麼一定就是買入股票，所以dp[0][0] = 0- prices[0] // 第0不持有股票後最多現金， ，不持有股票， 那現金就是0， 所以dp[0][1] = 0 public int maxProfit(int[] prices) { int[][] dp = new int[prices.length + 1][2]; //第0天持有股票的收益（負值） dp[0][0] = -prices[0]; //第0天不持有股票的收益 dp[0][1] = 0; for (int i = 1; i \u0026lt; prices.length; i++) { //不能這樣定義 因為 dp[i-1][1] 包涵了持有股票並賣出股票的case邏輯, 那麼 dp[i-1][1] - prices[i] 就相當於同一天先賣出股票，再買入股票，不符合題目的限制 //因為我們在同一天只能進行一次操作（要么買入，要么賣出）所以，這裡的邏輯是不對的 // bug: dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]-prices[i]); //如果允許同一天多次買賣即，122. Best Time to Buy and Sell Stock II，那麼就應該寫為：dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]-prices[i]); dp[i][0] = Math.max(dp[i - 1][0], -prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]); } return dp[prices.length - 1][1]; } } //leetcode submit region end(Prohibit modification and deletion) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution1 { //greedy: 遍历prices， 紀錄並取左最左最小價格， 取最右最大值，那麼得到差值就是最大利潤 public int maxProfit(int[] prices) { int lowPrice = Integer.MAX_VALUE; int maxProfit = 0; for (int i = 0; i \u0026lt; prices.length; i++) { lowPrice = Math.min(lowPrice, prices[i]); //相當於，當區間利潤變大時，才更新maxProfit maxProfit = Math.max(maxProfit, prices[i] - lowPrice); } return maxProfit; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution0 { //暴力解法 : 两层for loop, 遍历每天，计算买当前股票，未来某一天卖出的最大值，如何结果取最大值 //time limit exceeded public int maxProfit(int[] prices) { int maxProfit = 0; for (int i = 0; i \u0026lt; prices.length - 1; i++) { for (int j = i + 1; j \u0026lt; prices.length; j++) { maxProfit = Math.max(prices[j] - prices[i], maxProfit); } } return maxProfit; } } ","date":"2024-07-15T00:00:00Z","image":"https://kris0325.github.io/p/121.besttimetobuyandsellstock/121_hue85b2e7bab1f30b7b29041d5fedf799e_6645868_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/121.besttimetobuyandsellstock/","title":"121.BestTimeToBuyAndSellStock"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /** * You are a professional robber planning to rob houses along a street. Each house * has a certain amount of money stashed, the only constraint stopping you from * robbing each of them is that adjacent houses have security systems connected and * it will automatically contact the police if two adjacent houses were broken into * on the same night. * \u0026lt;p\u0026gt; * Given an integer array nums representing the amount of money of each house, * return the maximum amount of money you can rob tonight without alerting the police. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 1: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: nums = [1,2,3,1] * Output: 4 * Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). * Total amount you can rob = 1 + 3 = 4. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 2: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: nums = [2,7,9,3,1] * Output: 12 * Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 ( * money = 1). * Total amount you can rob = 2 + 9 + 1 = 12. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Constraints: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * 1 \u0026lt;= nums.length \u0026lt;= 100 * 0 \u0026lt;= nums[i] \u0026lt;= 400 * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Related Topics Array Dynamic Programming 👍 21014 👎 422 */ /* 2024-07-12 15:20:03 */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int rob(int[] nums) { return stealStore(nums); } public int stealStore(int[] stores) { if (stores == null || stores.length == 0) { return 0; } if (stores.length == 1) { return stores[0]; } int[] dp = new int[stores.length]; dp[0] = stores[0]; dp[1] = Math.max(dp[0], stores[1]); for (int i = 2; i \u0026lt; stores.length; i++) { //dp[i] 可以分為 不rob ｜ rob 當前stores[i]，取二者中的較大值 dp[i] = Math.max(dp[i - 1], dp[i - 2] + stores[i]); System.out.printf(\u0026#34;i:%s, dp[i]:%s \u0026#34;, i, dp[i]); } return dp[stores.length - 1]; } } ","date":"2024-07-15T00:00:00Z","image":"https://kris0325.github.io/p/198.houserobber/198_hubd383456b9673aed2bfe56a6b5423b94_14187007_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/198.houserobber/","title":"198.HouseRobber"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 /** * You are a professional robber planning to rob houses along a street. Each house * has a certain amount of money stashed. All houses at this place are arranged in * a circle. That means the first house is the neighbor of the last one. Meanwhile, * adjacent houses have a security system connected, and it will automatically * contact the police if two adjacent houses were broken into on the same night. * \u0026lt;p\u0026gt; * Given an integer array nums representing the amount of money of each house, * return the maximum amount of money you can rob tonight without alerting the police. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 1: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: nums = [2,3,2] * Output: 3 * Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2) * , because they are adjacent houses. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 2: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: nums = [1,2,3,1] * Output: 4 * Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). * Total amount you can rob = 1 + 3 = 4. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 3: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: nums = [1,2,3] * Output: 3 * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Constraints: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * 1 \u0026lt;= nums.length \u0026lt;= 100 * 0 \u0026lt;= nums[i] \u0026lt;= 1000 * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Related Topics Array Dynamic Programming 👍 9805 👎 151 */ /* 2024-07-12 16:35:45 House Robber II Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (41.96%)\t9805\t151 Tags dynamic-programming Companies microsoft */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { //DP: consider circle nums, nums[0], nums[length-1] are adjacent, so we can divide nums into two line new nums such as nums1: nums[0] -num[length-2] , nums2: nums[1] -num[length-1], // and get maximum = Math.max( rob(nums1), rob(nums2)) //將環狀house，拆為線型house,讓首尾house不再相連，簡化問題，即将nums 拆分為2個數組， 從而把打家劫舍robII 转化为 打家劫舍rob public int rob(int[] nums) { if (nums == null || nums.length == 0) { return 0; } if (nums.length == 1) { return nums[0]; } //從第一家開始打劫,直到nums[nums.length - 2], start to rob from the first house nums[0], so not consider to rob the last house nums[length-1] int robFromFirst = robLinear(nums, 0, nums.length - 2); //從第二家開始打劫，直到nums[nums.length - 1], start to rob from the second house num[1], so consider to rob the last house nums[length-1] int robFromSecond = robLinear(nums, 1, nums.length - 1); return Math.max(robFromFirst, robFromSecond); } public int robLinear(int[] nums, int start, int end) { if (start == end) { return nums[start]; } int[] dp = new int[nums.length]; dp[start] = nums[start]; dp[start+1] = Math.max(nums[start], nums[start + 1]); for (int i = start + 2; i \u0026lt;= end; i++) { //dp[i] 可以分為 rob ｜ 不rob 當前stores[i]，取二者中的較大值 dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]); } return dp[end]; } private int robLinear2(int[] houses, int start, int end) { if (start == end) { return houses[start]; } int n = end - start + 1; int[] dp = new int[n]; //注意处理初始化值，与dp[n]数组 dp[0] = houses[start]; dp[1] = Math.max(houses[start], houses[start + 1]); for (int i = 2; i \u0026lt; n; i++) { dp[i] = Math.max(dp[i - 1], dp[i - 2] + houses[start + i]); } return dp[n - 1]; } } ","date":"2024-07-12T00:00:00Z","image":"https://kris0325.github.io/p/213.houserobberii/213_hu38db8936e2cc7a120e9a7c60257dabc2_1817286_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/213.houserobberii/","title":"213.HouseRobberII"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 /** * You are given an integer array nums and an integer target. * \u0026lt;p\u0026gt; * You want to build an expression out of nums by adding one of the symbols \u0026#39;+\u0026#39; * and \u0026#39;-\u0026#39; before each integer in nums and then concatenate all the integers. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * For example, if nums = [2, 1], you can add a \u0026#39;+\u0026#39; before 2 and a \u0026#39;-\u0026#39; before 1 * and concatenate them to build the expression \u0026#34;+2-1\u0026#34;. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Return the number of different expressions that you can build, which evaluates * to target. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 1: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: nums = [1,1,1,1,1], target = 3 * Output: 5 * Explanation: There are 5 ways to assign symbols to make the sum of nums be * target 3. * -1 + 1 + 1 + 1 + 1 = 3 * +1 - 1 + 1 + 1 + 1 = 3 * +1 + 1 - 1 + 1 + 1 = 3 * +1 + 1 + 1 - 1 + 1 = 3 * +1 + 1 + 1 + 1 - 1 = 3 * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 2: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: nums = [1], target = 1 * Output: 1 * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Constraints: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * 1 \u0026lt;= nums.length \u0026lt;= 20 * 0 \u0026lt;= nums[i] \u0026lt;= 1000 * 0 \u0026lt;= sum(nums[i]) \u0026lt;= 1000 * -1000 \u0026lt;= target \u0026lt;= 1000 * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Related Topics Array Dynamic Programming Backtracking 👍 10847 👎 359 */ /* 2024-07-11 11:48:49 Target Sum Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (46.76%)\t10847\t359 Tags dynamic-programming | depth-first-search Companies facebook | google */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class TargetSum { public static void main(String[] args) { Solution solution = new TargetSum().new Solution(); } //leetcode submit region begin(Prohibit modification and deletion) class Solution { //dp: 01背包問題 //如何轉為01背包問題？ //可以假設將nums[i] 拆分為2個數組，即添加+的數組add， 和添加-的數組minus， 加法總和為add, 減法總和為minus 那麼可得到公式： // add + minus = sum (sum為nums元素總和) // add - minus = target //那麼可以推導出 add = (sum + target)/2 , 就轉化為問題：求拆分一個數組add滿足add = (sum + target)/2的方案右多少種 // 便可轉化為求裝滿容量為add的01背包，有多少種方法 dp[j], j為背包容量 //注意：由於計算add 為向下取整，那麼 (sum + target) %2 ==1，此時沒有方案 //那麼遞推數組 dp[j] += dp[j - nums[i]], 注意和求背包裝最大價值物品問題不一樣，這裡是求多少種方案，所以是累加 //初始化為dp[0] =1 , ( 因為如果dp[0] = 0，那麼dp[j]都會為0) public int findTargetSumWays(int[] nums, int target) { int sum = 0; for (int i = 0; i \u0026lt; nums.length; i++) { sum += nums[i]; } //無法分配，沒有方案 if ((sum + target) % 2 == 1) { return 0; } //無法分配，沒有方案 if (Math.abs(target) \u0026gt; sum) { return 0; } int addBagSize = (sum + target) / 2; int[] dp = new int[addBagSize + 1]; //如果初始化dp[0] = 0 會發現dp[j]全為0 dp[0] = 1; for (int i = 0; i \u0026lt; nums.length; i++) { for (int j = addBagSize; j \u0026gt;= nums[i]; j--) { //dp[j - nums[i]] 表示 容量為j的背包，去掉重量nums[i]的物品， dp[j] += dp[j - nums[i]]; } } return dp[addBagSize]; } } //leetcode submit region end(Prohibit modification and deletion) } ","date":"2024-07-11T00:00:00Z","image":"https://kris0325.github.io/p/494.-targetsum/494_huf9c9f2cd678c7281d39a5aa5065d5df2_9785122_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/494.-targetsum/","title":"494. TargetSum"},{"content":" 代碼隨想錄.二叉樹總結\n二叉樹題型 二叉树的理论基础 关于二叉树，你该了解这些！ (opens new window)：二叉树的种类、存储方式、遍历方式、定义方式\n二叉树的遍历方式 深度优先遍历 二叉樹的遍歷\n二叉树：前中后序递归法 (opens new window)：递归三部曲初次亮相\n二叉树：前中后序迭代法（一） (opens new window)：通过栈模拟递归\n二叉树：前中后序迭代法（二）统一风格(opens new window)\n广度优先遍历\n二叉树的层序遍历 (opens new window)：通过队列模拟\n求二叉树的属性 二叉树：是否对称(opens new window)\n递归：后序，比较的是根节点的左子树与右子树是不是相互翻转\n迭代：使用队列/栈将两个节点顺序放入容器中进行比较\n二叉树：求最大深度(opens new window)\n递归：后序，求根节点最大高度就是最大深度，通过递归函数的返回值做计算树的高度\n迭代：层序遍历\n二叉树：求最小深度(opens new window)\n递归：后序，求根节点最小高度就是最小深度，注意最小深度的定义\n迭代：层序遍历\n二叉树：求有多少个节点(opens new window)\n递归：后序，通过递归函数的返回值计算节点数量\n迭代：层序遍历\n二叉树：是否平衡(opens new window)\n递归：后序，注意后序求高度和前序求深度，递归过程判断高度差\n迭代：效率很低，不推荐\n二叉树：找所有路径(opens new window)\n递归：前序，方便让父节点指向子节点，涉及回溯处理根节点到叶子的所有路径\n迭代：一个栈模拟递归，一个栈来存放对应的遍历路径\n二叉树：递归中如何隐藏着回溯(opens new window)\n详解二叉树：找所有路径 (opens new window)中递归如何隐藏着回溯\n二叉树：求左叶子之和(opens new window)\n递归：后序，必须三层约束条件，才能判断是否是左叶子。\n迭代：直接模拟后序遍历\n二叉树：求左下角的值(opens new window)\n递归：顺序无所谓，优先左孩子搜索，同时找深度最大的叶子节点。\n迭代：层序遍历找最后一行最左边\n二叉树：求路径总和(opens new window)\n递归：顺序无所谓，递归函数返回值为bool类型是为了搜索一条边，没有返回值是搜索整棵树。\n迭代：栈里元素不仅要记录节点指针，还要记录从头结点到该节点的路径数值总和\n二叉树的修改与构造 翻转二叉树(opens new window)\n递归：前序，交换左右孩子\n迭代：直接模拟前序遍历\n构造二叉树(opens new window)\n递归：前序，重点在于找分割点，分左右区间构造\n迭代：比较复杂，意义不大\n构造最大的二叉树(opens new window)\n递归：前序，分割点为数组最大值，分左右区间构造\n迭代：比较复杂，意义不大\n合并两个二叉树(opens new window)\n递归：前序，同时操作两个树的节点，注意合并的规则\n迭代：使用队列，类似层序遍历\n#求二叉搜索树的属性\n二叉搜索树中的搜索(opens new window)\n递归：二叉搜索树的递归是有方向的\n迭代：因为有方向，所以迭代法很简单\n是不是二叉搜索树(opens new window)\n递归：中序，相当于变成了判断一个序列是不是递增的\n迭代：模拟中序，逻辑相同\n求二叉搜索树的最小绝对差(opens new window)\n递归：中序，双指针操作\n迭代：模拟中序，逻辑相同\n求二叉搜索树的众数(opens new window)\n递归：中序，清空结果集的技巧，遍历一遍便可求众数集合\n二叉搜索树转成累加树(opens new window)\n递归：中序，双指针操作累加\n迭代：模拟中序，逻辑相同\n二叉树公共祖先问题 二叉树的公共祖先问题(opens new window)\n递归：后序，回溯，找到左子树出现目标值，右子树节点目标值的节点。\n迭代：不适合模拟回溯\n二叉搜索树的公共祖先问题(opens new window)\n递归：顺序无所谓，如果节点的数值在目标区间就是最近公共祖先\n迭代：按序遍历\n二叉搜索树的修改与构造 二叉搜索树中的插入操作(opens new window)\n递归：顺序无所谓，通过递归函数返回值添加节点\n迭代：按序遍历，需要记录插入父节点，这样才能做插入操作\n二叉搜索树中的删除操作(opens new window)\n递归：前序，想清楚删除非叶子节点的情况\n迭代：有序遍历，较复杂\n修剪二叉搜索树(opens new window)\n递归：前序，通过递归函数返回值删除节点\n迭代：有序遍历，较复杂\n构造二叉搜索树(opens new window)\n递归：前序，数组中间节点分割\n迭代：较复杂，通过三个队列来模拟\n阶段总结 大家以上题目都做过了，也一定要看如下阶段小结。\n本周小结！（二叉树系列一）(opens new window) 本周小结！（二叉树系列二）(opens new window) 本周小结！（二叉树系列三）(opens new window) 本周小结！（二叉树系列四）(opens new window)\n最后总结 在二叉树题目选择什么遍历顺序是不少同学头疼的事情，我们做了这么多二叉树的题目了，Carl给大家大体分分类。\n涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。\n求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。\n求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。\n注意在普通二叉树的属性中，我用的是一般为后序，例如单纯求深度就用前序，二叉树：找所有路径 (opens new window)也用了前序，这是为了方便让父节点指向子节点。\n所以求普通二叉树的属性还是要具体问题具体分析。\nbinaryTree 問題 ","date":"2024-07-11T00:00:00Z","image":"https://kris0325.github.io/p/binary-tree/bt_hua99fcc1aaa1faf16ce5e5faccd4635f1_11277059_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/binary-tree/","title":"Binary Tree"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 /** * You are given an array of integers stones where stones[i] is the weight of the * iᵗʰ stone. * \u0026lt;p\u0026gt; * We are playing a game with the stones. On each turn, we choose any two stones * and smash them together. Suppose the stones have weights x and y with x \u0026lt;= y. * The result of this smash is: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * If x == y, both stones are destroyed, and * If x != y, the stone of weight x is destroyed, and the stone of weight y has * new weight y - x. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * At the end of the game, there is at most one stone left. * \u0026lt;p\u0026gt; * Return the smallest possible weight of the left stone. If there are no stones * left, return 0. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 1: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: stones = [2,7,4,1,8,1] * Output: 1 * Explanation: * We can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then, * we can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then, * we can combine 2 and 1 to get 1, so the array converts to [1,1,1] then, * we can combine 1 and 1 to get 0, so the array converts to [1], then that\u0026#39;s the * optimal value. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 2: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: stones = [31,26,33,21,40] * Output: 5 * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Constraints: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * 1 \u0026lt;= stones.length \u0026lt;= 30 * 1 \u0026lt;= stones[i] \u0026lt;= 100 * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Related Topics Array Dynamic Programming 👍 3100 👎 118 */ /* 2024-07-09 20:34:47 Last Stone Weight II Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (55.26%)\t3100\t118 Tags array | greedy Companies Unknown */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //leetcode submit region begin(Prohibit modification and deletion) class Solution { //dp: 与416.分割等和子集同类型题目，同属于01背包 //思路：尽可能分成2组等重量石头，相同石头重量会撞碎，剩下部分即为最后的重量 public int lastStoneWeightII(int[] stones) { int sum = 0; for (int i = 0; i \u0026lt; stones.length; i++) { sum += stones[i]; } int target = sum / 2; //dp[i]容量为i的背包能装下最大价值的物品（石头），物品重量为stone[i],物品价值value[i]也为stone[i] int[] dp = new int[target + 1]; //遍历物品 for (int i = 0; i \u0026lt; stones.length; i++) { //遍历背包 for (int j = target; j \u0026gt;= stones[i]; j--) { dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]); } } //dp[target]即为容量为target的背包能装下的最大价值的石头 //将石头分成2堆，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target] //因为在计算target时，target = sum / 2向下取整，所以sum - dp[target] 一定大于等于dp[target] //那么相撞后，剩下最小石头的重量就是(sum -dp[target]) - dp[target] return (sum - dp[target]) - dp[target]; } } //leetcode submit region end(Prohibit modification and deletion) ","date":"2024-07-09T00:00:00Z","permalink":"https://kris0325.github.io/p/1049.laststoneweight-ii/","title":"1049.LastStoneWeight II"},{"content":"二叉樹的遍歷，常規遞歸與迭代實現 二叉樹前序遍歷\n144.binary-tree-preorder-traversal.java\n二叉樹中序遍歷\n94.binary-tree-inorder-traversal.java\n二叉樹後序遍歷\n145.binary-tree-postorder-traversal.java\n二叉樹前序遍歷 144.binary-tree-preorder-traversal.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 /* * 思路：遞歸實現 * 中-左-右 */ class Solution1 { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { if (null == root) { return result; } result.add(root.val); preorderTraversal(root.left); preorderTraversal(root.right); return result; } } /* * 思路：迭代實現 */ class Solution { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { if (null == root) { return result; } Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); result.add(node.val); if (node.right != null) { stack.push(node.right); } if (node.left != null) { stack.push(node.left); } } return result; } } // @lc code=end 二叉樹中序遍歷 94.binary-tree-inorder-traversal.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* * 思路：遞歸實現中序遍歷 * 左-右-中 * * */ class Solution1 { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { if (null == root) { return result; } if (root.left != null) { inorderTraversal(root.left); } result.add(root.val); if (root.right != null) { inorderTraversal(root.right); } return result; } } /* * 思路：迭代實現中序遍歷 * * * */ class Solution { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); TreeNode cur = root; while (cur != null || !stack.isEmpty()) { //左 while (cur != null) { stack.push(cur); cur = cur.left; } //中 cur = stack.pop(); result.add(cur.val); //右 cur = cur.right; } return result; } } 二叉樹後序遍歷 145.binary-tree-postorder-traversal.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 /* * 思路1：递归实现后序遍历 * 左-右-中 */ class Solution1 { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { if (null == root) { return result; } postorderTraversal(root.left); postorderTraversal(root.right); result.add(root.val); return result; } } /* * 思路2：stack递归实现后序遍历，使用一个额外的栈反转节点 */ class Solution2 { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { if (root == null) { return result; } Stack\u0026lt;TreeNode\u0026gt; stack1 = new Stack\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack2 = new Stack\u0026lt;\u0026gt;(); stack1.push(root); while (!stack1.isEmpty()) { TreeNode node = stack1.pop(); stack2.push(node); if (node.left != null) { stack1.push(node.left); } if (node.right != null) { stack1.push(node.right); } } while (!stack2.isEmpty()) { result.add(stack2.pop().val); } return result; } } /* * 思路3：stack递归实现后序遍历，借鉴前序遍历的遞歸遍歷，稍微调整下入栈顺序即可 * 前序遍歷是：中-左-右，後序遍歷是左-右-中，那麼調整前序遍歷的代碼順序，變成中-右-左， * 然後再反轉result數組，即可得到後序遍歷的順序 */ class Solution { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { if (root == null) { return result; } Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); result.add(node.val); if (root.left != null) { stack.push(root.left); } if (root.right != null) { stack.push(root.left); } } result.reversed(); return result; } } 此时我们用迭代法写出了二叉树的前后中序遍历，大家可以看出前序和中序是完全两种代码风格，并不像递归写法那样代码稍做调整，就可以实现前后中序。 这是因为前序遍历中访问节点（遍历节点）和处理节点（将元素放进result数组中）可以同步处理，但是中序就无法做到同步！\n二叉樹的迭代遍歷統一寫法 在二叉树：听说递归能做的，栈也能做！ 中提到说使用栈的话，无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况。\n那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。\n如何标记呢，就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。 这种方法也可以叫做标记法。\n前序遍歷的遞歸實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* * 前序遍歷 中-左-右，基於標記法遞歸實現 */ class Solution { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { if (null == root) { return result; } Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.peek(); if (null != node) { stack.pop(); //右 if (null != node.right) { stack.push(node.right); } //左 if (null != node.left) { stack.push(node.left); } //中 stack.push(node); //中節點訪問過，但還沒處理，加入null節點標記。標記上一個節點是需要處理的節點 stack.push(null); } else { //當判斷pop()的節點為null ,則先pop,再取第二個節點便是為需要處理節點 stack.pop(); result.add(stack.pop().val); } } return result; } } 中序遍歷的遞歸實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* * 中序遍歷 左-中-右，基於標記法遞歸實現 */ class Solution { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { if (null == root) { return result; } Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.peek(); if (null != node) { stack.pop(); //右 if (null != node.right) { stack.push(node.right); } //中 stack.push(node); //中節點訪問過，但還沒處理，加入null節點標記。標記上一個節點是需要處理的節點 stack.push(null); //左 if (null != node.left) { stack.push(node.left); } } else { //當判斷pop()的節點為null ,則先pop,再取第二個節點便是為需要處理節點 stack.pop(); result.add(stack.pop().val); } } return result; } } 後序遍歷的遞歸實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* * 後序遍歷 左-右-右，基於標記法遞歸實現 */ class Solution { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { if (null == root) { return result; } Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.peek(); if (null != node) { stack.pop(); //中 stack.push(node); //中節點訪問過，但還沒處理，加入null節點標記。標記上一個節點是需要處理的節點 stack.push(null); //右 if (null != node.right) { stack.push(node.right); } //左 if (null != node.left) { stack.push(node.left); } } else { //當判斷pop()的節點為null ,則先pop,再取第二個節點便是為需要處理節點 stack.pop(); result.add(stack.pop().val); } } return result; } } ","date":"2024-07-07T00:00:00Z","image":"https://kris0325.github.io/p/%E4%BA%8C%E5%8F%89%E6%A8%B9%E7%9A%84%E9%81%8D%E6%AD%B7%E7%9A%84%E9%81%9E%E6%AD%B8%E5%AF%A6%E7%8F%BE%E8%88%87%E8%BF%AD%E4%BB%A3%E5%AF%A6%E7%8F%BE/BinaryTreeTraversal_hu7cf6e264dbacbb15e58f444182418964_7138799_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/%E4%BA%8C%E5%8F%89%E6%A8%B9%E7%9A%84%E9%81%8D%E6%AD%B7%E7%9A%84%E9%81%9E%E6%AD%B8%E5%AF%A6%E7%8F%BE%E8%88%87%E8%BF%AD%E4%BB%A3%E5%AF%A6%E7%8F%BE/","title":"Binary Tree Traversal"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* 2024-07-04 15:49:59 Partition Equal Subset Sum Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (46.27%)\t12200\t247 Tags dynamic-programming Companies ebay Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise. Example 1: Input: nums = [1,5,11,5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11]. Example 2: Input: nums = [1,2,3,5] Output: false Explanation: The array cannot be partitioned into equal sum subsets. Constraints: 1 \u0026lt;= nums.length \u0026lt;= 200 1 \u0026lt;= nums[i] \u0026lt;= 100 */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class PartitionEqualSubsetSum { public static void main(String[] args) { Solution solution = new PartitionEqualSubsetSum().new Solution(); } //leetcode submit region begin(Prohibit modification and deletion) class Solution { //01dp: 套用01背包 model //第i个元素（物品） 重量为nums[i] 价值也为nums[i] //背包重量为 target = sum/2 //题目转化为价值 dp[j] = max(dp[j], dp[i- nums[i]] + nums[i]) public boolean canPartition(int[] nums) { int sum = 0; int n = nums.length; for (int num : nums) { sum += num; } //sum为奇数无法拆分 if(sum %2 != 0){ return false; } int bagWeight = sum / 2; int targetValue = sum / 2; int []dp = new int[bagWeight+1]; dp[0] = 0; for(int i = 0; i \u0026lt; n; i++){ for(int j = bagWeight; j \u0026gt;= nums[i]; j--){ //背包容量为bagWeight，装物品i, 物品i的重量是nums[i], 价值也是nums[i] dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]); } //剪枝：每次完成内层loop， 立即检查当前i个元素就是否已满足条件 已寻找到可分割的sunset， i无需再遍历计算dp了 if(dp[bagWeight] == targetValue){ return true; } } return dp[bagWeight] == targetValue; } } //leetcode submit region end(Prohibit modification and deletion) } ","date":"2024-07-04T00:00:00Z","permalink":"https://kris0325.github.io/p/416.partitionequalsubsetsum/","title":"416.PartitionEqualSubsetSum"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 /** * You are given an integer array prices where prices[i] is the price of a given * stock on the iᵗʰ day. * \u0026lt;p\u0026gt; * On each day, you may decide to buy and/or sell the stock. You can only hold at * most one share of the stock at any time. However, you can buy it then * immediately sell it on the same day. * \u0026lt;p\u0026gt; * Find and return the maximum profit you can achieve. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 1: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: prices = [7,1,5,3,6,4] * Output: 7 * Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5- * 1 = 4. * Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. * Total profit is 4 + 3 = 7. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 2: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: prices = [1,2,3,4,5] * Output: 4 * Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5- * 1 = 4. * Total profit is 4. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 3: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: prices = [7,6,4,3,1] * Output: 0 * Explanation: There is no way to make a positive profit, so we never buy the * stock to achieve the maximum profit of 0. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Constraints: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * 1 \u0026lt;= prices.length \u0026lt;= 3 * 10⁴ * 0 \u0026lt;= prices[i] \u0026lt;= 10⁴ * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Related Topics Array Dynamic Programming Greedy 👍 13507 👎 2694 */ /* 2024-07-03 17:02:18 Best Time to Buy and Sell Stock II Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (66.40%)\t13507\t2694 Tags array | greedy Companies bloomberg */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 //leetcode submit region begin(Prohibit modification and deletion) class Solution1 { //greedy algorithm： 價格低時買入，價格高時賣出， //要求局部最優解，那麼可以每天都交易，然後算出每天的profit，price[i] -price[i-1], 只收集正利潤即可 public int maxProfit(int[] prices) { int maxProfit = 0; for (int i = 1; i \u0026lt; prices.length; i++) { //只收集正利潤 maxProfit += Math.max(prices[i] - prices[i - 1], 0); } return maxProfit; } } class Solution { //DP algorithm： 價格低時買入，價格高時賣出， public int maxProfit(int[] prices) { int[][] dp = new int[prices.length][2]; //dp[i][0] 第i天持有股票後的最多現金 //dp[i][1] 第i天持有的最多現金(前一天賣掉股票) //第0天買入股票，開始現金為0,那麼買入股票後的現金就是-prices[0]，所以是一個負數 dp[0][0] = -prices[0]; int n = prices.length; for (int i = 1; i \u0026lt; n; i++) { //第i天持有股票後的最多現金 = max(保持第i-1天的狀態不變 即第i - 1天持有股票後的最多現金, 第i-1天持有的最多現金-買第i天股票的錢） dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]); //第i天持有的最多現金 = max(第i-1天持有的最多現金, 第i-1天持有股票後的最多現金+賣第i天股票的錢) dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]); } return Math.max(dp[n - 1][0], dp[n - 1][1]); } } //leetcode submit region end(Prohibit modification and deletion) ","date":"2024-07-03T00:00:00Z","image":"https://kris0325.github.io/p/122.besttimetobuyandsellstock-ii/122_hub8798eeb12429cb98d0a0ed6a256661c_7673051_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/122.besttimetobuyandsellstock-ii/","title":"122.BestTimeToBuyAndSellStock II"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /** * Given an integer n, break it into the sum of k positive integers, where k \u0026gt;= 2, * and maximize the product of those integers. * \u0026lt;p\u0026gt; * Return the maximum product you can get. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 1: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: n = 2 * Output: 1 * Explanation: 2 = 1 + 1, 1 × 1 = 1. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 2: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: n = 10 * Output: 36 * Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Constraints: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * 2 \u0026lt;= n \u0026lt;= 58 * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Related Topics Math Dynamic Programming 👍 5093 👎 447 */ /* 2024-07-03 22:19:36 Integer Break Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (60.32%)\t5093\t447 Tags math | dynamic-programming Companies Unknown Given an integer n, break it into the sum of k positive integers, where k \u0026gt;= 2, and maximize the product of those integers. Return the maximum product you can get. */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //leetcode submit region begin(Prohibit modification and deletion) class Solution1 { //dp : 时间复杂度 0(n2) , 空间复杂度o(n) // 数学结论是：一个数n,拆成m个接近相同的数，可以得到最大乘积值 // 定义dp[i]数组为 整数i可拆为的最大的乘积 //用最小数j去试着遍历i, 那么i拆成 j * (i-j),即可以理解为拆成2个数j 和 i-j, // 同时也可以用dp数组表示为 j*dp[i-j]， 即最小尝试单元数j(无需再拆分) 和对 i-j的拆分 dp[i-j] // 那么可得到dp数组的的递推公式 dp[i] = max(dp[i], max(j * (i-j), j*dp[i-j])); // 注意：需对 用j遍历i的内层for循环得到的多个dp[i] 也进行max比较，从而求最大值 public int integerBreak(int n) { int[] dp = new int[n + 1]; dp[2] = 1; for (int i = 3; i \u0026lt;= n; i++) { //由题目条件可推出，dp[0],dp[1]无法拆分，没有实际意义 //dp[2] =1, 那么j = 3 - 2,所以j从1开始，由前面拆分最大乘积的数学结论，那么j的边界条件可以优化为j \u0026lt; i/2 // for (int j = 1; j \u0026lt; i; j++) {} //对于i的最大值，内层for循环会得出多个dp[i],所以dp[i]也需要参与和Math.max(j, dp[i - j])比较来求最值 for (int j = 1; j \u0026lt;= i / 2; j++) { dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j])); } } return dp[n]; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class IntegerBreak { public static void main(String[] args) { Solution solution = new IntegerBreak().new Solution(); } class Solution { // 数学结论是：一个数n,拆成m个接近相同的数，可以得到最大乘积值 // greedy algorithm: 时间复杂度 0(n) , 空间复杂度o(1) // 根据上面数学结论 局部以10为例子，334为最大， // 那么局部最优推导整体最优， 对整数n 则按照每次拆成m个3，如果剩下的为4，则保留4，然后相乘 public int integerBreak(int n) { if (n == 2) { return 1; } if (n == 3) { return 2; } int maxProduct = 1; while (n \u0026gt; 4) { maxProduct *= 3; n -= 3; } maxProduct *= n; return maxProduct; } } //leetcode submit region end(Prohibit modification and deletion) } ","date":"2024-07-03T00:00:00Z","permalink":"https://kris0325.github.io/p/343.-integerbreak/","title":"343.IntegerBreak"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /** * Given an integer n, return the number of structurally unique BST\u0026#39;s (binary * search trees) which has exactly n nodes of unique values from 1 to n. * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 1: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: n = 3 * Output: 5 * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Example 2: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Input: n = 1 * Output: 1 * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Constraints: * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * 1 \u0026lt;= n \u0026lt;= 19 * \u0026lt;p\u0026gt; * \u0026lt;p\u0026gt; * Related Topics Math Dynamic Programming Tree Binary Search Tree Binary Tree 👍 * 10311 👎 403 */ /* 2024-07-03 23:45:03 Unique Binary Search Trees Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (61.00%)\t10311\t403 Tags dynamic-programming | tree Companies snapchat Given an integer n, return the number of structurally unique BST\u0026#39;s (binary search trees) which has exactly n nodes of unique values from 1 to n. */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 //leetcode submit region begin(Prohibit modification and deletion) class Solution { // dp : //1.确定dp数组（dp table）以及下标的含义 //dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]。 //画图分析以每个j为根节点root，可以画出多少种BST // 画图 n = 1, 2, 3的情况，找规律，分析递推关系, //2.确定递推公式 //在上面的分析中，其实已经看出其递推关系， dp[i] += dp[以j为头节点左子树节点的搜素树数量] * dp[以j为头节点右子树节点的搜素树数量] //整个树 是 左右子树的不同组合，所以是左子树的组合数量 * 右子树的组合数量 //j 相当于头节点的元素，j是从1遍历到i为止 //i 是从前到后遍历到n, 所以求dp[n] 需要累加dp[i] //所以递推公式：dp[i] += dp[j-1] * dp[i-j] //3.初始化 //dp[0]=1 (假设空树case), dp[1] =1 public int numTrees(int n) { int[] dp = new int[n + 1]; dp[0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= i; j++) { //对于第i个节点，需要考虑1作为根节点直到i作为根节点的情况，所以需要累加 dp[i] += dp[j-1] * dp[i - j]; } } return dp[n]; } } //leetcode submit region end(Prohibit modification and deletion) ","date":"2024-07-03T00:00:00Z","permalink":"https://kris0325.github.io/p/96.uniquebinarysearchtrees/","title":"96.UniqueBinarySearchTrees"},{"content":" # 什么是动态规划 动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。 所以动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的，\n动态规划的解题步骤 做动规题目的时候，很多同学会陷入一个误区，就是以为把状态转移公式背下来，照葫芦画瓢改改，就开始写代码，甚至把题目AC之后，都不太清楚dp[i]表示的是什么。\n这就是一种朦胧的状态，然后就把题给过了，遇到稍稍难一点的，可能直接就不会了，然后看题解，然后继续照葫芦画瓢陷入这种恶性循环中。\n状态转移公式（递推公式）是很重要，但动规不仅仅只有递推公式。\n对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！\n1. 确定dp数组（dp table）以及下标的含义\n2. 确定递推公式\n3. dp数组如何初始化\n4. 确定遍历顺序\n5. 举例推导dp数组\n一些同学可能想为什么要先确定递推公式，然后在考虑初始化呢？\n因为一些情况是递推公式决定了dp数组要如何初始化！\n后面的讲解中我都是围绕着这五点来进行讲解。\n可能刷过动态规划题目的同学可能都知道递推公式的重要性，感觉确定了递推公式这道题目就解出来了。\n其实 确定递推公式 仅仅是解题里的一步而已！\n一些同学知道递推公式，但搞不清楚dp数组应该如何初始化，或者正确的遍历顺序，以至于记下来公式，但写的程序怎么改都通过不了。\n后序的讲解的大家就会慢慢感受到这五步的重要性了。\n动态规划应该如何debug 相信动规的题目，很大部分同学都是这样做的。\n看一下题解，感觉看懂了，然后照葫芦画瓢，如果能正好画对了，万事大吉，一旦要是没通过，就怎么改都通过不了，对 dp数组的初始化，递推公式，遍历顺序，处于一种黑盒的理解状态。\n写动规题目，代码出问题很正常！\n找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！\nDP Questions List 509.fibonacci-number 斐波那契數列\n70. Climbing Stairs 70. 爬楼梯\n746. Min Cost Climbing Stairs 746.使用最小花费爬楼梯\n62. Unique Paths 不同路徑 63. Unique Paths II 不同路徑II 343.IntegerBreak 343. 整数拆分\n96.UniqueBinarySearchTrees 96.不同的二叉搜索树\n416.PartitionEqualSubsetSum 416. 分割等和子集\n1049.LastStoneWeight II 1049.最后一块石头的重量II\n494. TargetSum 494. 目标和\n213.HouseRobberII 213.打家劫舍II\n198.HouseRobber 198.打家劫舍\n121.BestTimeToBuyAndSellStock 121.買賣股票的最佳時機\n122.BestTimeToBuyAndSellStockII 122.買賣股票的最佳時機II\n","date":"2024-07-03T00:00:00Z","image":"https://kris0325.github.io/p/dynamic-programming/dynamicProgramming_huef16b088f6663f16aad49f65a4302927_8860844_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/dynamic-programming/","title":"dynamic programming"},{"content":" 什么是贪心 贪心的本质是选择每一阶段的局部最优，从而达到全局最优。\n贪心的套路（什么时候用贪心） 很多同学做贪心的题目的时候，想不出来是贪心，想知道有没有什么套路可以一看就看出来是贪心。\n说实话贪心算法并没有固定的套路。\n所以唯一的难点就是如何通过局部最优，推出整体最优。\n那么如何能看出局部最优是否能推出整体最优呢？有没有什么固定策略或者套路呢？\n不好意思，也没有！ 靠自己手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可行，可能需要动态规划。\n有同学问了如何验证可不可以用贪心算法呢？\n最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧。\n手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心。\n贪心一般解题步骤 贪心算法一般分为如下四步：\n1. 将问题分解为若干个子问题\n2. 找出适合的贪心策略\n3. 求解每一个子问题的最优解\n4. 将局部最优解堆叠成全局最优解\n这个四步其实过于理论化了，我们平时在做贪心类的题目 很难去按照这四步去思考，真是有点“鸡肋”。\n做题的时候，只要想清楚 局部最优 是什么，如果推导出全局最优，其实就够了。\n总结 本篇给出了什么是贪心以及大家关心的贪心算法固定套路。\n不好意思了，贪心没有套路，说白了就是常识性推导加上举反例。\n最后给出贪心的一般解题步骤，大家可以发现这个解题步骤也是比较抽象的，不像是二叉树，回溯算法，给出了那么具体的解题套路和模板。\n","date":"2024-07-03T00:00:00Z","image":"https://kris0325.github.io/p/greedy-algorithm/greedy_huf17606b724e43b217f3a4ea57cac8886_13293263_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/greedy-algorithm/","title":"greedy algorithm"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 Find Mode in Binary Search Tree Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (56.06%)\t3878\t782 Tags tree Companies google Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it. If the tree has more than one mode, return them in any order. Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than or equal to the node\u0026#39;s key. The right subtree of a node contains only nodes with keys greater than or equal to the node\u0026#39;s key. Both the left and right subtrees must also be binary search trees. Example 1: Input: root = [1,null,2,2] Output: [2] Example 2: Input: root = [0] Output: [0] Constraints: The number of nodes in the tree is in the range [1, 104]. -105 \u0026lt;= Node.val \u0026lt;= 105 Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution1 { //1. tree to Hashmap \u0026lt;node.val, frequent\u0026gt; hashmap //2. sort hashmap by frequent, get max //3.traverse hashmap to collect node.vals by max HashMap\u0026lt;Integer, Integer\u0026gt; val2frequent = new HashMap\u0026lt;\u0026gt;(); public int[] findMode(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); inorderTraverse(root); List\u0026lt;Integer\u0026gt;frequentList = new ArrayList\u0026lt;\u0026gt;(); for(Integer frequent :val2frequent.values()){ frequentList.add(frequent); } Integer max = frequentList.stream().max(Integer::compareTo).get(); for(Map.Entry\u0026lt;Integer, Integer\u0026gt; entry: val2frequent.entrySet()){ if(entry.getValue() == max){ result.add(entry.getKey()); } } return result.stream().mapToInt(Integer::intValue).toArray(); } public void inorderTraverse(TreeNode root){ if(null == root){ return; } inorderTraverse(root.left); val2frequent.put(root.val, val2frequent.getOrDefault(root.val,0)+1); inorderTraverse(root.right); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { // inorder traverse tree, and count frequent TreeNode pre = null; int maxfrequent = 0; int currentfrequent = 0; List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public int[] findMode(TreeNode root) { inorder(root); return result.stream().mapToInt(Integer::intValue).toArray(); } public void inorder(TreeNode root){ if(null == root){ return; } inorder(root.left); //第一个节点 if(pre == null ){ currentfrequent = 1; } else if(pre.val == root.val) { //与前一个节点值相同 currentfrequent++; } else { //与前一个节点值不相同的新节点 currentfrequent = 1; } if(currentfrequent \u0026gt; maxfrequent){ //更新 result.clear(); result.add(root.val); maxfrequent = currentfrequent; } else if(currentfrequent == maxfrequent){ //添加 result.add(root.val); } //更新pre节点 pre = root; inorder(root.right); } } ","date":"2024-06-24T00:00:00Z","image":"https://kris0325.github.io/p/501.find-mode-in-binary-search-tree.java/501_hu11dc35441c190efdf181813b27f857eb_5072802_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/501.find-mode-in-binary-search-tree.java/","title":"501.find-mode-in-binary-search-tree.java"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 Construct Binary Tree from Preorder and Inorder Traversal Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (63.84%)\t14871\t503 Tags array | tree | depth-first-search Companies bloomberg Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree. Example 1: Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] Output: [3,9,20,null,null,15,7] Example 2: Input: preorder = [-1], inorder = [-1] Output: [-1] Constraints: 1 \u0026lt;= preorder.length \u0026lt;= 3000 inorder.length == preorder.length -3000 \u0026lt;= preorder[i], inorder[i] \u0026lt;= 3000 preorder and inorder consist of unique values. Each value of inorder also appears in preorder. preorder is guaranteed to be the preorder traversal of the tree. inorder is guaranteed to be the inorder traversal of the tree. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { return buildTreeHelp(preorder, 0, preorder.length , inorder, 0, inorder.length); } public TreeNode buildTreeHelp(int[] preorder, int preorderBegin, int preorderEnd , int[] inorder , int inorderBegin, int inorderEnd){ //edge case if(preorderBegin - preorderEnd == 0){ return null; } //1.rootVal int rootVal = preorder[preorderBegin]; TreeNode root = new TreeNode(rootVal); //edge case if(preorder.length ==1){ return root; } //2.get splitIndex by rootVal int splitIndex; for(splitIndex = inorderBegin; splitIndex\u0026lt; inorderEnd; splitIndex++){ if(inorder[splitIndex] == rootVal){ break; } } //3.split inorder to left and right int inorderLeftBegin = inorderBegin; int inorderLeftEnd = splitIndex; int inorderRightBegin = splitIndex+1; int inorderRightEnd = inorderEnd; //3.split preorder to left and right int preorderLeftBegin = preorderBegin+1; int preorderLeftEnd = preorderLeftBegin + (inorderLeftEnd - inorderLeftBegin); int preorderRightBegin = preorderLeftEnd; int preorderRightEnd = preorderEnd; //4. recursive traverse left and right root.left = buildTreeHelp(preorder, preorderLeftBegin, preorderLeftEnd , inorder, inorderLeftBegin, inorderLeftEnd); root.right = buildTreeHelp(preorder, preorderRightBegin, preorderRightEnd , inorder, inorderRightBegin, inorderRightEnd); //5. return root return root; } } ","date":"2024-06-23T00:00:00Z","permalink":"https://kris0325.github.io/p/105.construct-binary-tree-from-preorder-and-inorder-traversal.java/","title":"105.construct-binary-tree-from-preorder-and-inorder-traversal.java"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 Construct Binary Tree from Inorder and Postorder Traversal Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (62.77%)\t7967\t130 Tags array | tree | depth-first-search Companies microsoft Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree. Example 1: Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3] Output: [3,9,20,null,null,15,7] Example 2: Input: inorder = [-1], postorder = [-1] Output: [-1] Constraints: 1 \u0026lt;= inorder.length \u0026lt;= 3000 postorder.length == inorder.length -3000 \u0026lt;= inorder[i], postorder[i] \u0026lt;= 3000 inorder and postorder consist of unique values. Each value of postorder also appears in inorder. inorder is guaranteed to be the inorder traversal of the tree. postorder is guaranteed to be the postorder traversal of the tree. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Solution1 { // recursive //1.rootval == postorder[postorder.length-1] , constractor Root node //2.splite indorder into left array and right array by rootval //3.splite postorder into left array and right array by indorder left array //4.recursive root.left = buildTree( indorder left and postorder left), //root.left = buildTree( indorder right and postorder right) //5. return root public TreeNode buildTree(int[] inorder, int[] postorder) { //edge case 注意处理递归调用中的边界条件 if(0 == inorder.length || postorder.length == 0){ return null; } //1.rootval int rootVal = postorder[postorder.length-1]; TreeNode root = new TreeNode(rootVal); if(inorder.length == 1){ return root; } //2.splite indorder into left array and right array by rootval int spliteIndex; for(spliteIndex = 0; spliteIndex \u0026lt; inorder.length; spliteIndex++){ if(inorder[spliteIndex] == rootVal){ break; } } int[] indorderLeft = IntStream.range(0, spliteIndex) .map(i -\u0026gt; inorder[i]) .toArray(); int[] indorderRight = IntStream.range(spliteIndex+1, inorder.length) .map(i -\u0026gt; inorder[i]) .toArray(); //3.splite postorder into left array and right array by indorder left array int[] postorderLeft = IntStream.range(0, spliteIndex) .map(i -\u0026gt; postorder[i]) .toArray(); int[] postorderRight = IntStream.range(spliteIndex, postorder.length-1) .map(i -\u0026gt; postorder[i]) .toArray(); //4.recursive root.left = buildTree( indorder left and postorder left), //root.left = buildTree( indorder right and postorder right) root.left = buildTree(indorderLeft, postorderLeft); root.right = buildTree(indorderRight, postorderRight); //5. return root return root; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class Solution { // solution2: 优化时间、空间复杂度，不需要new array, 直接使用数组下标index操作 // recursive //1.rootval == postorder[postorder.length-1] , constractor Root node //2.splite indorder into left array and right array by rootval //3.splite postorder into left array and right array by indorder left array //4.recursive root.left = buildTree( indorder left and postorder left), //root.left = buildTree( indorder right and postorder right) //5. return root public TreeNode buildTree(int[] inorder, int[] postorder) { if(inorder.length ==0 || postorder.length ==0){ return null; } return buildTreeRecursive(inorder, 0, inorder.length , postorder, 0, postorder.length); } public TreeNode buildTreeRecursive(int[] inorder, int inorderBegin,int inorderEnd ,int[] postorder, int postorderBegin,int postorderEnd){ if(inorderEnd - inorderBegin == 0){ return null; } int rootVal = postorder[postorderEnd-1]; TreeNode root = new TreeNode(rootVal); if(inorderEnd - inorderBegin == 1){ return root; } int spliteIndex; for(spliteIndex =inorderBegin; spliteIndex \u0026lt;inorderEnd; spliteIndex++){ if(rootVal == inorder[spliteIndex]){ break; } } //split inorder 左开右闭 int inorderLeftBegin = inorderBegin; int inorderLeftEnd = spliteIndex; //jump rootVal == inorder[spliteIndex] int inorderRightBegin = spliteIndex+1; int inorderRightEnd = inorderEnd; //split postorder 左开右闭 int postorderLeftBegin = postorderBegin; //终止位置是 需要 postorderBegin 加上 中序区间的大小size，即加上左子树的节点个数 int postorderLeftEnd = postorderBegin + (spliteIndex - inorderBegin); //不能用直接使用spliteIndex, 因为spliteIndex是inorder的索引下标，不能直接用于postorder， //必须使用左子树节点个数（二者左子树节点个数相同） // int postorderLeftEnd = spliteIndex; int postorderRightBegin = postorderLeftEnd; //jump rootVal int postorderRightEnd = postorderEnd-1; root.left = buildTreeRecursive(inorder, inorderLeftBegin, inorderLeftEnd ,postorder, postorderLeftBegin,postorderLeftEnd); root.right = buildTreeRecursive(inorder, inorderRightBegin, inorderRightEnd , postorder, postorderRightBegin, postorderRightEnd); return root; } } ","date":"2024-06-23T00:00:00Z","permalink":"https://kris0325.github.io/p/106.construct-binary-tree-from-inorder-and-postorder-traversal.java/","title":"106.construct-binary-tree-from-inorder-and-postorder-traversal.java"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 Convert Sorted Array to Binary Search Tree Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (71.65%)\t10921\t556 Tags tree | depth-first-search Companies airbnb Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree. Example 1: Input: nums = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5] Explanation: [0,-10,5,null,-3,null,9] is also accepted: Example 2: Input: nums = [1,3] Output: [3,1] Explanation: [1,null,3] and [3,1] are both height-balanced BSTs. Constraints: 1 \u0026lt;= nums.length \u0026lt;= 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums is sorted in a strictly increasing order. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { // 二分法，获取有序数组中间节点为根节点，以中间节点作为切割点，然后再递归左数组，右数组 public TreeNode sortedArrayToBST(int[] nums) { return sortedArrayToBST(nums, 0, nums.length - 1); } public TreeNode sortedArrayToBST(int[] nums, int left, int right) { if (left \u0026gt; right) return null; int mid = left + (right - left) / 2; TreeNode current = new TreeNode(nums[mid]); current.left = sortedArrayToBST(nums, left, mid - 1); current.right = sortedArrayToBST(nums, mid + 1, right); return current; } } ","date":"2024-06-23T00:00:00Z","permalink":"https://kris0325.github.io/p/108.convert-sorted-array-to-binary-search-tree.java/","title":"108.convert-sorted-array-to-binary-search-tree.java"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 Path Sum Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (50.33%)\t9628\t1101 Tags tree | depth-first-search Companies microsoft Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children. Example 1: Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 Output: true Explanation: The root-to-leaf path with the target sum is shown. Example 2: Input: root = [1,2,3], targetSum = 5 Output: false Explanation: There two root-to-leaf paths in the tree: (1 --\u0026gt; 2): The sum is 3. (1 --\u0026gt; 3): The sum is 4. There is no root-to-leaf path with sum = 5. Example 3: Input: root = [], targetSum = 0 Output: false Explanation: Since the tree is empty, there are no root-to-leaf paths. Constraints: The number of nodes in the tree is in the range [0, 5000]. -1000 \u0026lt;= Node.val \u0026lt;= 1000 -1000 \u0026lt;= targetSum \u0026lt;= 1000 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution{ public boolean hasPathSum(TreeNode root, int targetSum) { //Leaf node , current path is not we want , then return if(null == root){ return false; } //assert child node is the need path if(root.left == null \u0026amp;\u0026amp; root.right == null \u0026amp;\u0026amp; targetSum == root.val ){ return true; } return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution1 { //solution1: recursive traverse root Integer pathVal =0; public boolean hasPathSum(TreeNode root, int targetSum) { if(null == root){ return false; } return backtracking(root,0,targetSum); } public boolean backtracking(TreeNode node, int pathVal, int targetSum){ //在递归调用中，通过逻辑或 (||) 操作符组合返回值的原因是， //逻辑或运算的特性使得只要任意一个操作数为 true，整个表达式的值就为 true。具体来说， //A || B 只有在 A 和 B 都为 false 时才返回 false，否则返回 true。 /* *当递归调用返回 false 时，这仅意味着当前路径不满足条件。 但由于递归检查了所有可能的路径，如果有任意一条路径满足条件，则最终结果会返回 true。 通过逻辑或 (||) 操作符组合返回值， 确保只要存在一条满足条件的路径，最终结果就会是 true */ //terminate condition if(null == node){ //这仅意味着当前路径不满足条件 return false; } pathVal += node.val; if(node.left == null \u0026amp;\u0026amp; node.right == null){ if(pathVal == targetSum){ return true; } } return backtracking(node.left,pathVal, targetSum) || backtracking(node.right,pathVal, targetSum); } } ","date":"2024-06-23T00:00:00Z","permalink":"https://kris0325.github.io/p/112.path-sum.java/","title":"112.path-sum.java"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 Path Sum II Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (58.45%)\t7918\t154 Tags tree | depth-first-search Companies bloomberg Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references. A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children. Example 1: Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: [[5,4,11,2],[5,8,4,5]] Explanation: There are two paths whose sum equals targetSum: 5 + 4 + 11 + 2 = 22 5 + 8 + 4 + 5 = 22 Example 2: Input: root = [1,2,3], targetSum = 5 Output: [] Example 3: Input: root = [1,2], targetSum = 0 Output: [] Constraints: The number of nodes in the tree is in the range [0, 5000]. -1000 \u0026lt;= Node.val \u0026lt;= 1000 -1000 \u0026lt;= targetSum \u0026lt;= 1000 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; pathSum(TreeNode root, int targetSum) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; pathList = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); if(null == root){ return pathList; } backtracking(root, targetSum, pathList, path); return pathList; } public void backtracking(TreeNode node , int targetSum, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; pathList , List\u0026lt;Integer\u0026gt; path){ //添加当前节点 path.add(node.val); // leaf node if(node.left == null \u0026amp;\u0026amp; node.right == null){ if(path.stream() .mapToInt(Integer::intValue) .sum() == targetSum){ //path是应用对象，所以不能直接pathList.add(path)，需要拷贝后再add pathList.add(new ArrayList\u0026lt;\u0026gt;(path)); } //回溯 path.remove(path.size()-1); //返回上一层调用 return; } /** * 遍历左右2个节点 * for(int i =0； i\u0026lt;2; i++ ) * 遍历完后，再回溯 */ //遍历left if(null != node.left){ backtracking(node.left, targetSum, pathList, path); } //遍历right if(null != node.right){ backtracking(node.right, targetSum, pathList, path); } //在处理完当前节点的左右子节点后进行回溯 path.remove(path.size()-1); } } ","date":"2024-06-23T00:00:00Z","permalink":"https://kris0325.github.io/p/113.path-sum-ii.java/","title":"113.path-sum-ii.java"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 Lowest Common Ancestor of a Binary Tree Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (62.14%)\t16387\t409 Tags tree Companies amazon | apple | facebook | linkedin | microsoft Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3. Example 2: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Example 3: Input: root = [1,2], p = 1, q = 2 Output: 1 Constraints: The number of nodes in the tree is in the range [2, 105]. -109 \u0026lt;= Node.val \u0026lt;= 109 All Node.val are unique. p != q p and q will exist in the tree. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null || root == p || root == q) { // 递归结束条件 return root; } // 后序遍历 TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if(left == null \u0026amp;\u0026amp; right == null) { // 若未找到节点 p 或 q return null; }else if(left == null \u0026amp;\u0026amp; right != null) { // 若找到一个节点 return right; }else if(left != null \u0026amp;\u0026amp; right == null) { // 若找到一个节点 return left; }else { // 若找到两个节点 return root; } } } ","date":"2024-06-23T00:00:00Z","permalink":"https://kris0325.github.io/p/236.lowest-common-ancestor-of-a-binary-tree.java/","title":"236.lowest-common-ancestor-of-a-binary-tree.java"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 Delete Node in a BST Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (51.20%)\t9042\t276 Tags Companies uber Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages: Search for a node to remove. If the node is found, delete the node. Example 1: Input: root = [5,3,6,2,4,null,7], key = 3 Output: [5,4,6,2,null,null,7] Explanation: Given key to delete is 3. So we find the node with value 3 and delete it. One valid answer is [5,4,6,2,null,null,7], shown in the above BST. Please notice that another valid answer is [5,2,6,null,4,null,7] and it\u0026#39;s also accepted. Example 2: Input: root = [5,3,6,2,4,null,7], key = 0 Output: [5,3,6,2,4,null,7] Explanation: The tree does not contain a node with value = 0. Example 3: Input: root = [], key = 0 Output: [] Constraints: The number of nodes in the tree is in the range [0, 104]. -105 \u0026lt;= Node.val \u0026lt;= 105 Each node has a unique value. root is a valid binary search tree. -105 \u0026lt;= key \u0026lt;= 105 Follow up: Could you solve it with time complexity O(height of tree)? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { //solution:.简化版递归 //1).确定终止条件：if(root == null), return root; //2).单层递归逻辑 //case1. 没找到要删除的目标节点，遍历到空节点，直接return null //找到要删除的目标节点,处理当前节点: //case2. 当前节点左，右孩子都为null, 直接删除当前节点，return null //case3. 当前节点左孩子为null cur.left == null, 则返回右孩子return cur.right //case4. 当前节点右孩子为null cur.right == null, 则返回左孩子return cur.left //case5. 当前节点左，右孩子都不为null, //1 先遍历当前节点的右孩子cur.right 的最左边的“最左叶子节点”，将单前节点的左孩子cur.left放在“最左叶子节点”的左孩子位置 //2 再将则返回当前节点的右孩子cur.right //key \u0026lt; root.val,递归处理左边节点（如过有左节点的话，处理后用左节点接住返回的结果 //key \u0026gt; root.val,递归处理右边节点（如果有的话，处理后用左节点接住返回的结果 //return root public TreeNode deleteNode(TreeNode root, int key) { if (root == null) { return null; } if (root.val == key) { // case1. 和case5. 可以合并为 else 来处理 // if (root.left == null \u0026amp;\u0026amp; root.right == null) { // return null; // } else if (root.left == null) { return root.right; } else if (root.right == null) { return root.left; } else { TreeNode cur = root.right; while (cur.left != null) { cur = cur.left; } cur.left = root.left; root = root.right; return root; } } if (key \u0026lt; root.val) { root.left = deleteNode(root.left, key); } if (key \u0026gt; root.val) { root.right = deleteNode(root.right, key); } return root; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class Solution2 { //solution:2.递归 public TreeNode deleteNode(TreeNode root, int key) { if (root == null) { return null; } TreeNode parrent = null; TreeNode current = root; while (current != null) { if (current.val \u0026lt; key){ // right tree parrent = current; current = current.right; } else if (current.val \u0026gt; key) { //left tree parrent = current; current = current.left; }else { //find the key node break; } //以下代码有BUG: 全部情况只有==，\u0026gt;, \u0026lt;3种case， 每种情况是互斥的，但是每个if之间少了else，执行完一种case判断后，应该直接跳到while（current != null）开头进行判断， // 但少了else， // 就继续往下执行了，所以是有问题的，而且 parrent没有及时更新，而且可能出现 null空指针异常， // test case [5,3,8,null，null,6,10], key == 7的情况，是会报null空指针异常的 // if (current.val == key) { // // find the key node // break; // } // parrent = current; // if (current.val \u0026lt; key) { // current = current.right; // } // if (current.val \u0026gt; key) { // current = current.left; // } } //BSF只有一个节点 if (parrent == null) { return deletOneNode(current); } // key 在 left if (parrent.left != null \u0026amp;\u0026amp; key == parrent.left.val) { parrent.left = deletOneNode(current); } //key 在 right if (parrent.right != null \u0026amp;\u0026amp; key == parrent.right.val) { parrent.right = deletOneNode(current); } //return root 也包含了 没找BSF does not contain key,此时 ,current == null jump out while loop // if (current == null) { // return root; // } return root; } //delete node current //删除目标根节点（要删除的节点），如果目标根节点的左，右子树都不为null時，根据BSF的特性 // 1. 将目标节点的左子树，放在右子树的左子树的最左边的叶子节点的左孩子位置上 // 2. 将目标节点的右孩子作为新的根节点返回 public TreeNode deletOneNode(TreeNode target) { if (target == null) { return null; } // if (target.left == null) { // return target.right; // } if (target.right == null) { return target.left; } //左，右节点都不为空 TreeNode cur = target.right; while (cur.left != null) { cur = cur.left; } cur.left = target.left; return target.right; } } ","date":"2024-06-23T00:00:00Z","permalink":"https://kris0325.github.io/p/450.delete-node-in-a-bst.java/","title":"450.delete-node-in-a-bst.java"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 Unique Paths Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (64.26%)\t16533\t440 Tags array | dynamic-programming Companies bloomberg There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. The test cases are generated so that the answer will be less than or equal to 2 * 109. Example 1: Input: m = 3, n = 7 Output: 28 Example 2: Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -\u0026gt; Down -\u0026gt; Down 2. Down -\u0026gt; Down -\u0026gt; Right 3. Down -\u0026gt; Right -\u0026gt; Down Constraints: 1 \u0026lt;= m, n \u0026lt;= 100 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { //1.define dp[i][j]数组 为到每个坐标的可能的路径 //2.推导 recursion formula, dp[m][n] = dp左边+dp上边 //3.initial dp[i][j]，第一行，第一列初始化：dp[i][0] = 1;dp[0][j] = 1; //4.traverse order遍历顺序 //5.推导结果result public int uniquePaths(int m, int n) { int[][]dp = new int[m][n]; //第一列，首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条， //同理，第一行，dp[0][j]一定都是1，因为从(0, 0)的位置到(0, j)的路径只有一条 for(int i= 0; i\u0026lt;m; i++){dp[i][0] = 1;} for(int j= 0; j\u0026lt;n;j++){dp[0][j] = 1;} for(int i= 1; i\u0026lt;m; i++){ for(int j= 1; j\u0026lt;n;j++){ dp[i][j] = dp[i-1][j] +dp[i][j-1]; } } return dp[m-1][n-1]; } } ","date":"2024-06-22T00:00:00Z","image":"https://kris0325.github.io/p/62.-unique-paths/62_hu217c66c1c10e19fd24d7a426241716ed_6307148_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/62.-unique-paths/","title":"62. Unique Paths"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 /* * @lc app=leetcode id=63 lang=java * * [63] Unique Paths II * * https://leetcode.com/problems/unique-paths-ii/description/ * * algorithms * Medium (41.53%) * Likes: 8687 * Dislikes: 508 * Total Accepted: 953.9K * Total Submissions: 2.3M * Testcase Example: \u0026#39;[[0,0,0],[0,1,0],[0,0,0]]\u0026#39; * * You are given an m x n integer array grid. There is a robot initially * located at the top-left corner (i.e., grid[0][0]). The robot tries to move * to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only * move either down or right at any point in time. * * An obstacle and space are marked as 1 or 0 respectively in grid. A path that * the robot takes cannot include any square that is an obstacle. * * Return the number of possible unique paths that the robot can take to reach * the bottom-right corner. * * The testcases are generated so that the answer will be less than or equal to * 2 * 10^9. * * * Example 1: * * * Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] * Output: 2 * Explanation: There is one obstacle in the middle of the 3x3 grid above. * There are two ways to reach the bottom-right corner: * 1. Right -\u0026gt; Right -\u0026gt; Down -\u0026gt; Down * 2. Down -\u0026gt; Down -\u0026gt; Right -\u0026gt; Right * * * Example 2: * * * Input: obstacleGrid = [[0,1],[0,0]] * Output: 1 * * * * Constraints: * * * m == obstacleGrid.length * n == obstacleGrid[i].length * 1 \u0026lt;= m, n \u0026lt;= 100 * obstacleGrid[i][j] is 0 or 1. * * */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // @lc code=start class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { //1.dp[i][j] 达到db[i][j]坐标的路径数 //2. recursive math dp[i][j] = dp[i-1][j] +dp[i][j-1] //3. itnitial if(obstacleGrid[] != 1) dp[0][j] = 1 dp[i][0] = 1 //4. print //5. return 结果 int m = obstacleGrid.length; int n = obstacleGrid[0].length; if(obstacleGrid[0][0] ==1 \u0026amp;\u0026amp; obstacleGrid[m-1][n-1] ==1){ return 0; } int[][] dp = new int[m][n]; for(int i=0; i\u0026lt; m \u0026amp;\u0026amp; obstacleGrid[i][0] == 0;i++ ){ dp[i][0]=1; } for(int j=0; j\u0026lt; n \u0026amp;\u0026amp; obstacleGrid[0][j] == 0;j++ ){ dp[0][j]=1; } for(int i= 1; i\u0026lt; m;i++ ){ for(int j=1; j\u0026lt; n;j++ ){ //如果当前坐标obstacleGrid[i][j]上有障碍物，则所有路径都无法达到单前坐标，所以dp[i][j] =0 dp[i][j] = obstacleGrid[i][j] == 1? 0 : dp[i-1][j] + dp[i][j-1]; } } return dp[m-1][n-1]; } } // @lc code=end ","date":"2024-06-22T00:00:00Z","permalink":"https://kris0325.github.io/p/63.-unique-paths-ii/","title":"63. Unique Paths II"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 /* * @lc app=leetcode id=93 lang=java * * [93] Restore IP Addresses * * https://leetcode.com/problems/restore-ip-addresses/description/ * * algorithms * Medium (49.82%) * Likes: 5190 * Dislikes: 789 * Total Accepted: 464.3K * Total Submissions: 923.5K * Testcase Example: \u0026#39;\u0026#34;25525511135\u0026#34;\u0026#39; * * A valid IP address consists of exactly four integers separated by single * dots. Each integer is between 0 and 255 (inclusive) and cannot have leading * zeros. * * * For example, \u0026#34;0.1.2.201\u0026#34; and \u0026#34;192.168.1.1\u0026#34; are valid IP addresses, but * \u0026#34;0.011.255.245\u0026#34;, \u0026#34;192.168.1.312\u0026#34; and \u0026#34;192.168@1.1\u0026#34; are invalid IP * addresses. * * * Given a string s containing only digits, return all possible valid IP * addresses that can be formed by inserting dots into s. You are not allowed * to reorder or remove any digits in s. You may return the valid IP addresses * in any order. * * * Example 1: * * * Input: s = \u0026#34;25525511135\u0026#34; * Output: [\u0026#34;255.255.11.135\u0026#34;,\u0026#34;255.255.111.35\u0026#34;] * * * Example 2: * * * Input: s = \u0026#34;0000\u0026#34; * Output: [\u0026#34;0.0.0.0\u0026#34;] * * * Example 3: * * * Input: s = \u0026#34;101023\u0026#34; * Output: [\u0026#34;1.0.10.23\u0026#34;,\u0026#34;1.0.102.3\u0026#34;,\u0026#34;10.1.0.23\u0026#34;,\u0026#34;10.10.2.3\u0026#34;,\u0026#34;101.0.2.3\u0026#34;] * * * * Constraints: * * * 1 \u0026lt;= s.length \u0026lt;= 20 * s consists of digits only. * * */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 import java.util.List; class Solution { public List\u0026lt;String\u0026gt; restoreIpAddresses(String s) { //backtrack to solve it // collect valid ip List\u0026lt;String\u0026gt; validIps = new ArrayList\u0026lt;\u0026gt;(); //1. not valid string if( s.length()\u0026lt; 4 || s.length()\u0026gt; 12 ){ return validIps; } int segament = 0; String currentIPString = \u0026#34;\u0026#34;; int startIndex = 0; backtrack(s, validIps, 0, currentIPString, segament); return validIps; } // backtrack public void backtrack(String s,List\u0026lt;String\u0026gt; validIps, int startIndex, String currentIPString, int segament ){ // return condition if(segament == 4 \u0026amp;\u0026amp; startIndex == s.length()){ validIps.add(currentIPString); return; } //trm if(segament ==4 || startIndex == s.length()){ return; } // iterative current string from 1 to 3 for(int len = 1; len\u0026lt;=3; len++){ if(startIndex + len \u0026gt;s.length()){ break; } String segamentIP = s.substring(startIndex, startIndex+len); if(validSegamentIP(segamentIP, len)){ String newcurrentIPString = segament == 0 ? segamentIP : currentIPString + \u0026#34;.\u0026#34; + segamentIP; backtrack(s,validIps,startIndex+len, newcurrentIPString, segament+1); } } } //validSegamentIP public boolean validSegamentIP(String segamentIP, int len){ // invalid SegamentIP 01 || 256 etc. if((segamentIP.startsWith(\u0026#34;0\u0026#34;) \u0026amp;\u0026amp; len \u0026gt; 1) || (!segamentIP.startsWith(\u0026#34;0\u0026#34;) \u0026amp;\u0026amp; Integer.valueOf(segamentIP) \u0026gt; 255)){ return false; } return true; } } ","date":"2024-06-21T00:00:00Z","image":"https://kris0325.github.io/p/93.-restore-ip-addresses/93_hucd08571b687ba28d79d57df2cab6e02d_13845230_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/93.-restore-ip-addresses/","title":"93. Restore IP Addresses"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 Binary Tree Level Order Traversal Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (67.15%)\t15149\t309 Tags tree | breadth-first-search Companies amazon | apple | bloomberg | facebook | linkedin | microsoft Given the root of a binary tree, return the level order traversal of its nodes\u0026#39; values. (i.e., from left to right, level by level). Example 1: Input: root = [3,9,20,null,null,15,7] Output: [[3],[9,20],[15,7]] Example 2: Input: root = [1] Output: [[1]] Example 3: Input: root = [] Output: [] Constraints: The number of nodes in the tree is in the range [0, 2000]. -1000 \u0026lt;= Node.val \u0026lt;= 1000 https://leetcode.com/problems/binary-tree-level-order-traversal/description/ * /* * 思路：二叉树层序遍历，借助queue辅助数据结构来实现 * */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { if(null == root) { return result; } Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.add(root); while (!queue.isEmpty()) { //收集当前level的节点元素 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); //记录当前节点数量 int len = queue.size(); //遍历当前level for(int i = 0; i \u0026lt; len;i++){ TreeNode node = queue.poll(); list.add(node.val); if(node.left != null){ queue.offer(node.left); } if(node.right != null){ queue.offer(node.right); } } result.add(list); } return result; } } ","date":"2024-06-09T00:00:00Z","image":"https://kris0325.github.io/p/102.-binary-tree-level-order-traversal/102_hu9bf809a008d6edb44fb307c7b2936237_7785777_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/102.-binary-tree-level-order-traversal/","title":"102. Binary Tree Level Order Traversal"},{"content":"https://leetcode.com/problems/binary-tree-postorder-traversal/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 /* * @lc app=leetcode id=144 lang=java * * [144] Binary Tree Preorder Traversal * * https://leetcode.com/problems/binary-tree-preorder-traversal/description/ * * algorithms * Easy (69.46%) * Likes: 7911 * Dislikes: 209 * Total Accepted: 1.6M * Total Submissions: 2.3M * Testcase Example: \u0026#39;[1,null,2,3]\u0026#39; * * Given the root of a binary tree, return the preorder traversal of its nodes\u0026#39; * values. * * * Example 1: * * * Input: root = [1,null,2,3] * Output: [1,2,3] * * * Example 2: * * * Input: root = [] * Output: [] * * * Example 3: * * * Input: root = [1] * Output: [1] * * * * Constraints: * * * The number of nodes in the tree is in the range [0, 100]. * -100 \u0026lt;= Node.val \u0026lt;= 100 * * * * Follow up: Recursive solution is trivial, could you do it iteratively? * */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /* * 思路：遞歸實現 */ class Solution1 { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { if(null == root){ return result; } result.add(root.val); preorderTraversal(root.left); preorderTraversal(root.right); return result; } } /* * 思路：迭代實現 */ class Solution { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { if (null == root) { return result; } Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); result.add(node.val); if (node.right != null) { stack.push(node.right); } if (node.left != null) { stack.push(node.left); } } return result; } } // @lc code=end ","date":"2024-06-08T00:00:00Z","image":"https://kris0325.github.io/p/144.binary-tree-preorder-traversal.java/144_hub3d0262241a7411e47a00bfd6996676e_5504694_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/144.binary-tree-preorder-traversal.java/","title":"144.binary-tree-preorder-traversal.java"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 /* * @lc app=leetcode id=145 lang=java * * [145] Binary Tree Postorder Traversal * * https://leetcode.com/problems/binary-tree-postorder-traversal/description/ * * algorithms * Easy (70.88%) * Likes: 6835 * Dislikes: 189 * Total Accepted: 1.2M * Total Submissions: 1.7M * Testcase Example: \u0026#39;[1,null,2,3]\u0026#39; * * Given the root of a binary tree, return the postorder traversal of its * nodes\u0026#39; values. * * * Example 1: * * * Input: root = [1,null,2,3] * Output: [3,2,1] * * * Example 2: * * * Input: root = [] * Output: [] * * * Example 3: * * * Input: root = [1] * Output: [1] * * * * Constraints: * * * The number of the nodes in the tree is in the range [0, 100]. * -100 \u0026lt;= Node.val \u0026lt;= 100 * * * * Follow up: Recursive solution is trivial, could you do it iteratively? */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 /* * 思路1：递归实现后序遍历 */ // class Solution1 { // List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); // public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { // if(null == root){ // return result; // } // postorderTraversal(root.left); // postorderTraversal(root.right); // result.add(root.val); // return result; // } // } /* * 思路2：stack递归实现后序遍历，使用一个额外的栈反转节点 */ class Solution2 { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { if(root == null){ return result; } Stack\u0026lt;TreeNode\u0026gt; stack1 = new Stack\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack2 = new Stack\u0026lt;\u0026gt;(); stack1.push(root); while (!stack1.isEmpty()) { TreeNode node = stack1.pop(); stack2.push(node); if(node.left != null){ stack1.push(node.left); } if(node.right != null){ stack1.push(node.right); } } while (!stack2.isEmpty()) { result.add(stack2.pop().val); } return result; } } /* * 思路3：stack递归实现后序遍历，借鉴谦虚遍历，稍微调整下入栈顺序即可 */ class Solution { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { if(root == null){ return result; } Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); result.add(node.val); if(root.left != null){ stack.push(root.left); } if(root.right != null){ stack.push(root.left); } } result.reversed(); return result; } } ","date":"2024-06-08T00:00:00Z","image":"https://kris0325.github.io/p/145.binary-tree-postorder-traversal.java/145_hu119d3ec452b8ab1a47872fc0a598407f_11674299_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/145.binary-tree-postorder-traversal.java/","title":"145.binary-tree-postorder-traversal.java"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 /* * @lc app=leetcode id=94 lang=java * * [94] Binary Tree Inorder Traversal * * https://leetcode.com/problems/binary-tree-inorder-traversal/description/ * * algorithms * Easy (76.08%) * Likes: 13350 * Dislikes: 776 * Total Accepted: 2.5M * Total Submissions: 3.3M * Testcase Example: \u0026#39;[1,null,2,3]\u0026#39; * * Given the root of a binary tree, return the inorder traversal of its nodes\u0026#39; * values. * * * Example 1: * * * Input: root = [1,null,2,3] * Output: [1,3,2] * * * Example 2: * * * Input: root = [] * Output: [] * * * Example 3: * * * Input: root = [1] * Output: [1] * * * * Constraints: * * * The number of nodes in the tree is in the range [0, 100]. * -100 \u0026lt;= Node.val \u0026lt;= 100 * * * * Follow up: Recursive solution is trivial, could you do it iteratively? */ // @lc code=start import java.util.ArrayList; /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /* * 思路：遞歸實現中序遍歷 * */ class Solution1 { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { if (null == root) { return result; } if(root.left != null){ inorderTraversal(root.left); } result.add(root.val); if(root.right != null){ inorderTraversal(root.right); } return result; } } /* * 思路：迭代實現中序遍歷 * */ class Solution { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); TreeNode cur = root; while(cur != null || !stack.isEmpty()){ while(cur!= null){ stack.push(cur); cur = cur.left; } cur = stack.pop(); result.add(cur.val); cur = cur.right; } return result; } } ","date":"2024-06-08T00:00:00Z","image":"https://kris0325.github.io/p/94.binary-tree-inorder-traversal.java/94_hu02245ee8d9a8c4ec85434334539ca1da_2844357_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/94.binary-tree-inorder-traversal.java/","title":"94.binary-tree-inorder-traversal.java"},{"content":"https://leetcode.com/problems/top-k-frequent-elements/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 Top K Frequent Elements Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (62.76%)\t17113\t647 Tags hash-table | heap Companies pocketgems | yelp Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] Constraints: 1 \u0026lt;= nums.length \u0026lt;= 105 -104 \u0026lt;= nums[i] \u0026lt;= 104 k is in the range [1, the number of unique elements in the array]. It is guaranteed that the answer is unique. Follow up: Your algorithm\u0026#39;s time complexity must be better than O(n log n), where n is the array\u0026#39;s size. 1 2 3 4 5 6 7 8 /* * 思路：最小堆（小顶堆） * 1.haspmap 存每个元素的值与对应频率； * 2.PriorityQueue实现构建一个最小堆，然后遍历hashmap，将所有\u0026lt;元素，频率\u0026gt; pair 都推入到堆中， * 同时维护堆的大小为k,即如果堆大小超过k时，就将堆顶元素弹出，并推入当前元素 * 3.遍历完后，PriorityQueue的元素即为所求 * * */i 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import java.util.HashMap; import java.util.Map; import java.util.PriorityQueue; class Solution { public int[] topKFrequent(int[] nums, int k) { Map\u0026lt;Integer, Integer\u0026gt; num2Frequent = new HashMap\u0026lt;\u0026gt;(); for(int num : nums){ num2Frequent.put(num, num2Frequent.getOrDefault(num, 0)+1); } //构建最小堆的优先级队列 //优先队列的存储的元素为一个int[2], 即一个pair\u0026lt;num, cnt\u0026gt; num为数字，cnt为对应频率 PriorityQueue\u0026lt;int[]\u0026gt; priorityQueue = new java.util.PriorityQueue\u0026lt;\u0026gt;((pair1,pair2) -\u0026gt; pair1[1]-pair2[1]); for(Map.Entry\u0026lt;Integer, Integer\u0026gt; entry : num2Frequent.entrySet() ){ if(priorityQueue.size()\u0026lt;k){ priorityQueue.add(new int[]{entry.getKey(), entry.getValue()}); } else { //当前元素出现频率大于最小堆堆顶元素对应的频率 if(entry.getValue() \u0026gt; priorityQueue.peek()[1]){ //弹出最小堆堆顶元素 priorityQueue.poll(); //将当前元素推入队列 priorityQueue.add(new int[]{entry.getKey(), entry.getValue()}); } } } int[] result = new int[k]; for(int i = 0; i\u0026lt;k ; i++){ result[i] = priorityQueue.poll()[0]; } return result; } } ","date":"2024-05-27T00:00:00Z","image":"https://kris0325.github.io/p/347.-top-k-frequent-elements/347_hu2a8b01894b50d3180429ee23f2799d90_10071556_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/347.-top-k-frequent-elements/","title":"347. Top K Frequent Elements"},{"content":"https://leetcode.com/problems/sliding-window-maximum/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 Sliding Window Maximum Category\tDifficulty\tLikes\tDislikes algorithms\tHard (46.57%)\t17988\t666 Tags heap | sliding-window Companies amazon | google | zenefits You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example 1: Input: nums = [1,3,-1,-3,5,3,6,7], k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Example 2: Input: nums = [1], k = 1 Output: [1] Constraints: 1 \u0026lt;= nums.length \u0026lt;= 105 -104 \u0026lt;= nums[i] \u0026lt;= 104 1 \u0026lt;= k \u0026lt;= nums.length 1 2 3 4 5 6 /** * 思路：队列实现 1.用一个单调递增队列维护滑动窗口，队列最前面一个元素即为当前窗口的最大值，收集到数组； 2.每次移动窗口，则添加当前元素入队列，那么队列最前面一个元素即为当前最大值，收集到数组； 3.直到移动到目标数组的末尾，return收集最大值的数组 **/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class MyQueue{ Deque\u0026lt;Integer\u0026gt; myDeque = new LinkedList\u0026lt;\u0026gt;(); //将当前值推入队列（队尾），并移除所有比当前值小的元素 public void push (int value){ while(!myDeque.isEmpty() \u0026amp;\u0026amp; value \u0026gt; myDeque.getLast()){ myDeque.removeLast(); } /* 错误入队列，这个方法是stack实现的队列，相当于将当前值推入队列（队首）了 myDeque.push(value); **/ myDeque.addLast(value); } //如果队列首部元素等于给定值，则移除它 public void pop(int value){ if(!myDeque.isEmpty() \u0026amp;\u0026amp; myDeque.peekFirst() == value){ myDeque.removeFirst(); } } //返回队列首部元素，即当前窗口的最大值 public Integer peek(){ return myDeque.peekFirst(); } } class Solution { public int[] maxSlidingWindow(int[] nums, int k) { MyQueue myDeque = new MyQueue(); int[] result = new int[nums.length-k+1]; int num = 0; //初始化第一个滑动窗口 for(int i = 0; i\u0026lt; k; i++){ //初始化滑动窗口入队列，并且构建的是单调队列，队列并不需要维护所有滑动窗口内的元素， //只需维护可能为最大值的元素，即保证队列从队尾到对首是单调递增即可 myDeque.push(nums[i]); } result[num++] = myDeque.peek(); // 处理滑动窗口 for(int i= k; i \u0026lt; nums.length;i++){ myDeque.pop(nums[i-k]); myDeque.push(nums[i]); result[num++] = myDeque.peek(); } return result; } } // @lc code=end ","date":"2024-05-26T00:00:00Z","image":"https://kris0325.github.io/p/239.-sliding-window-maximum/239_hu0f7fa2ed191dbc8425b52f20b76cf327_7206809_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/239.-sliding-window-maximum/","title":"239. Sliding Window Maximum"},{"content":"https://leetcode.com/problems/evaluate-reverse-polish-notation/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 Evaluate Reverse Polish Notation Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (51.37%)\t7556\t1069 Tags stack Companies linkedin You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation. Evaluate the expression. Return an integer that represents the value of the expression. Note that: The valid operators are \u0026#39;+\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;*\u0026#39;, and \u0026#39;/\u0026#39;. Each operand may be an integer or another expression. The division between two integers always truncates toward zero. There will not be any division by zero. The input represents a valid arithmetic expression in a reverse polish notation. The answer and all the intermediate calculations can be represented in a 32-bit integer. Example 1: Input: tokens = [\u0026#34;2\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;+\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;*\u0026#34;] Output: 9 Explanation: ((2 + 1) * 3) = 9 Example 2: Input: tokens = [\u0026#34;4\u0026#34;,\u0026#34;13\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;/\u0026#34;,\u0026#34;+\u0026#34;] Output: 6 Explanation: (4 + (13 / 5)) = 6 Example 3: Input: tokens = [\u0026#34;10\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;+\u0026#34;,\u0026#34;-11\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;/\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;17\u0026#34;,\u0026#34;+\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;+\u0026#34;] Output: 22 Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 Constraints: 1 \u0026lt;= tokens.length \u0026lt;= 104 tokens[i] is either an operator: \u0026#34;+\u0026#34;, \u0026#34;-\u0026#34;, \u0026#34;*\u0026#34;, or \u0026#34;/\u0026#34;, or an integer in the range [-200, 200]. 1 2 3 /** * 思路：栈实现你波兰表达式（后缀表示法） */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int evalRPN(String[] tokens) { Stack\u0026lt;Integer\u0026gt; stackRPN = new Stack\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; operators = Arrays.asList( \u0026#34;+\u0026#34;,\u0026#34;-\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;/\u0026#34;); for(int i = 0; i\u0026lt; tokens.length; i++){ if(!operators.contains(tokens[i])){ stackRPN.push(Integer.valueOf(tokens[i])); } else{ int right= Integer.valueOf(stackRPN.pop()) ; int left = Integer.valueOf(stackRPN.pop()); if(\u0026#34;+\u0026#34;.equals(tokens[i]))stackRPN.push(left + right); if(\u0026#34;-\u0026#34;.equals(tokens[i]))stackRPN.push(left - right); if(\u0026#34;*\u0026#34;.equals(tokens[i]))stackRPN.push(left * right); if(\u0026#34;/\u0026#34;.equals(tokens[i]))stackRPN.push(left / right); } } return stackRPN.pop(); } } ","date":"2024-05-24T00:00:00Z","image":"https://kris0325.github.io/p/150.-evaluate-reverse-polish-notation/150_hu643fe10fc5d8a8cac53007a5b54442bc_7091430_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/150.-evaluate-reverse-polish-notation/","title":"150. Evaluate Reverse Polish Notation"},{"content":"https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Solved Easy Topics Stack | Queue |String Companies You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them. We repeatedly make duplicate removals on s until we no longer can. Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique. Example 1: Input: s = \u0026#34;abbaca\u0026#34; Output: \u0026#34;ca\u0026#34; Explanation: For example, in \u0026#34;abbaca\u0026#34; we could remove \u0026#34;bb\u0026#34; since the letters are adjacent and equal, and this is the only possible move. The result of this move is that the string is \u0026#34;aaca\u0026#34;, of which only \u0026#34;aa\u0026#34; is possible, so the final string is \u0026#34;ca\u0026#34;. Example 2: Input: s = \u0026#34;azxxzy\u0026#34; Output: \u0026#34;ay\u0026#34; Constraints: 1 \u0026lt;= s.length \u0026lt;= 105 s consists of lowercase English letters. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* * 思路： solution1: 队列实现 遍历字符串，并存入栈， 当当前元素和队列第一个元素相同时，跳过此次循环i++，同时弹出队列第一个元素； 否则将当前元素存入队列； 遍历完后，遍历弹出队列元素组成新字符串即可 solution2: in-place 将字符串当栈使用 solution3: 双指针实现 solution4: 栈实现 遍历字符串，并存入栈， 当当前元素和栈顶元素相同时，跳过此次循环i++，同时弹出栈顶元素； 否则将当前元素存入栈； 遍历完后，遍历弹出栈内元素组成新字符串，并反转字符串即可 */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import java.sql.Array; import java.util.ArrayDeque; class Solution1 { public String removeDuplicates(String s) { ArrayDeque deque = new ArrayDeque\u0026lt;\u0026gt;(); for(int i =0;i\u0026lt;s.length();i++){ if(deque.isEmpty() || (char) deque.peek() != s.charAt(i)){ deque.push(s.charAt(i)); } else{ deque.pop(); } } String newS = \u0026#34;\u0026#34;; while (!deque.isEmpty()) { newS = deque.pop()+ newS; } return newS; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public String removeDuplicates(String s) { char[] charS = s.toCharArray(); int fast = 0; int slow = 0; while (fast \u0026lt; charS.length) { // Use the fast pointer to overwrite the value at the slow pointer // When encountering the same value before and after, the slow pointer retreats, // and the same value will be overwritten by the fast pointer in the next loop if(slow \u0026gt; 0 \u0026amp;\u0026amp; charS[slow-1] == charS[fast]){ slow--; } else{ charS[slow++] = charS[fast]; } //每次循环都需要移动fast fast++; } return new String(charS,0,slow); } } ","date":"2024-05-19T00:00:00Z","image":"https://kris0325.github.io/p/1047.-remove-all-adjacent-duplicates-in-string/1047_hua62bcbcf9a79dfe26d0875c8d67438b3_11777398_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/1047.-remove-all-adjacent-duplicates-in-string/","title":"1047. Remove All Adjacent Duplicates In String"},{"content":"https://leetcode.com/problems/valid-parentheses/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 Valid Parentheses Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (40.56%)\t23735\t1719 Tags string | stack Companies airbnb | amazon | bloomberg | facebook | google | microsoft | twitter | zenefits Given a string s containing just the characters \u0026#39;(\u0026#39;, \u0026#39;)\u0026#39;, \u0026#39;{\u0026#39;, \u0026#39;}\u0026#39;, \u0026#39;[\u0026#39; and \u0026#39;]\u0026#39;, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type. Example 1: Input: s = \u0026#34;()\u0026#34; Output: true Example 2: Input: s = \u0026#34;()[]{}\u0026#34; Output: true Example 3: Input: s = \u0026#34;(]\u0026#34; Output: false Constraints: 1 \u0026lt;= s.length \u0026lt;= 104 s consists of parentheses only \u0026#39;()[]{}\u0026#39;. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 思路：用栈实现 先来分析一下 这里有三种不匹配的情况， 第一种情况，字符串里左方向的括号多余了 ，所以不匹配。 第二种情况，括号没有多余，但是 括号的类型没有匹配上。 第三种情况，字符串里右方向的括号多余了，所以不匹配。 第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false 第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return false 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号return false 那么什么时候说明左括号和右括号全都匹配了呢，就是字符串遍历完之后，栈是空的，就说明全都匹配了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // @lc code=start import java.util.Stack; class Solution { public boolean isValid(String s) { Stack\u0026lt;Character\u0026gt; stackS = new Stack\u0026lt;\u0026gt;(); for(int i=0; i\u0026lt; s.length(); i++){ if(\u0026#39;(\u0026#39; == s.charAt(i)){ stackS.push(\u0026#39;)\u0026#39;); } else if(\u0026#39;{\u0026#39; == s.charAt(i)){ stackS.push(\u0026#39;}\u0026#39;); } else if(\u0026#39;[\u0026#39; == s.charAt(i)){ stackS.push(\u0026#39;]\u0026#39;); } //第三种情况：遍历字符串匹配的过程中，栈已经空了，右边还有没匹配的字符，说明右括号没有找到对应的左括号，return false; //第二种情况：遍历字符串匹配的过程中，发现栈里没有匹配的字符，说明括号类型没匹配上，return false; else if(stackS.isEmpty() || stackS.peek() != s.charAt(i) ){ return false; } //右括号与栈顶元素匹配，则pop(), 进行下一次操作 else { stackS.pop(); } } //第一种情况：此时已遍历完字符串，栈不为空，说明左括号多了，没有对应的右括号来匹配，return false, 否则return true; return stackS.isEmpty(); } } // @lc code=end ","date":"2024-05-18T00:00:00Z","image":"https://kris0325.github.io/p/20.-valid-parentheses/20_hue3151d51445e528ddb008b90055ab5f3_4973423_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/20.-valid-parentheses/","title":"20. Valid Parentheses"},{"content":"https://leetcode.com/problems/implement-stack-using-queues/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 Implement Stack using Queues Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (63.63%)\t5965\t1199 Tags stack | design Companies bloomberg Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty). Implement the MyStack class: void push(int x) Pushes element x to the top of the stack. int pop() Removes the element on the top of the stack and returns it. int top() Returns the element on the top of the stack. boolean empty() Returns true if the stack is empty, false otherwise. Notes: You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid. Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue\u0026#39;s standard operations. Example 1: Input [\u0026#34;MyStack\u0026#34;, \u0026#34;push\u0026#34;, \u0026#34;push\u0026#34;, \u0026#34;top\u0026#34;, \u0026#34;pop\u0026#34;, \u0026#34;empty\u0026#34;] [[], [1], [2], [], [], []] Output [null, null, null, 2, 2, false] Explanation MyStack myStack = new MyStack(); myStack.push(1); myStack.push(2); myStack.top(); // return 2 myStack.pop(); // return 2 myStack.empty(); // return False Constraints: 1 \u0026lt;= x \u0026lt;= 9 At most 100 calls will be made to push, pop, top, and empty. All the calls to pop and top are valid. Follow-up: Can you implement the stack using only one queue? 1 2 3 4 5 6 /* * 思路：2个队列实现栈，一个栈push时模拟stack的存储顺序，另一一个队列完全当作备份用 * * * * ***/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import java.util.LinkedList; import java.util.Queue; class MyStack { Queue\u0026lt;Integer\u0026gt; queue; Queue\u0026lt;Integer\u0026gt; queueBackup; public MyStack() { queue = new LinkedList\u0026lt;\u0026gt;(); queueBackup = new LinkedList\u0026lt;\u0026gt;(); } //加入元素时，即用queue模拟栈stack的存储顺序，将 queue依次压入queueBackup， //再将queueBackup的元素依次压入queue，这样保证x位于queue的第一个位置，即类似栈顶 public void push(int x) { while (queue.size()\u0026gt;0) { queueBackup.add(queue.poll()); } queue.add(x); while (queueBackup.size()\u0026gt;0) { queue.add(queueBackup.poll()); } } public int pop() { return queue.poll(); } public int top() { return queue.peek(); } public boolean empty() { return queue.isEmpty(); } } ","date":"2024-05-18T00:00:00Z","image":"https://kris0325.github.io/p/225.-implement-stack-using-queues/225_hu134691ec6495076548774a62268f84fa_12731442_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/225.-implement-stack-using-queues/","title":"225. Implement Stack using Queues"},{"content":"\u0026lt; https://leetcode.com/problems/implement-queue-using-stacks/description/\u003e\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 Implement Queue using Stacks Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (66.20%)\t7520\t423 Tags stack | design Companies bloomberg | microsoft Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class: void push(int x) Pushes element x to the back of the queue. int pop() Removes the element from the front of the queue and returns it. int peek() Returns the element at the front of the queue. boolean empty() Returns true if the queue is empty, false otherwise. Notes: You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack\u0026#39;s standard operations. Example 1: Input [\u0026#34;MyQueue\u0026#34;, \u0026#34;push\u0026#34;, \u0026#34;push\u0026#34;, \u0026#34;peek\u0026#34;, \u0026#34;pop\u0026#34;, \u0026#34;empty\u0026#34;] [[], [1], [2], [], [], []] Output [null, null, null, 1, 1, false] Explanation MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false Constraints: 1 \u0026lt;= x \u0026lt;= 9 At most 100 calls will be made to push, pop, peek, and empty. All the calls to pop and peek are valid. Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity? In other words, performing n operations will take overall O(n) time even if one of those operations may take longer. 1 2 3 4 /* ** 思路：两个stack实现FIFO queue * * * */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import java.util.Stack; class MyQueue { Stack\u0026lt;Integer\u0026gt; stackIn; Stack\u0026lt;Integer\u0026gt; stackOut; public MyQueue() { stackIn = new Stack\u0026lt;\u0026gt;(); stackOut = new Stack\u0026lt;\u0026gt;(); } public void push(int x) { stackIn.push(x); } public int pop() { dumpStackIn(); return stackOut.pop(); } public int peek() { dumpStackIn(); return stackOut.peek(); } public boolean empty() { return stackIn.isEmpty() \u0026amp;\u0026amp; stackOut.isEmpty(); } public void dumpStackIn(){ if(!stackOut.isEmpty()) return; while (!stackIn.isEmpty()) { stackOut.push(stackIn.pop()); } } } ","date":"2024-05-18T00:00:00Z","image":"https://kris0325.github.io/p/232.-implement-queue-using-stacks/232_hu3f630662af572599871cfc0a7997cf15_15449336_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/232.-implement-queue-using-stacks/","title":"232. Implement Queue using Stacks"},{"content":"https://leetcode.com/problems/reverse-words-in-a-string/description/\n相同類型： 344. Reverse String https://leetcode.com/problems/reverse-string/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 Reverse Words in a String Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (42.13%)\t8216\t5116 Tags string Companies apple | bloomberg | microsoft | snapchat | yelp Given an input string s, reverse the order of the words. A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space. Return a string of the words in reverse order concatenated by a single space. Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces. Example 1: Input: s = \u0026#34;the sky is blue\u0026#34; Output: \u0026#34;blue is sky the\u0026#34; Example 2: Input: s = \u0026#34; hello world \u0026#34; Output: \u0026#34;world hello\u0026#34; Explanation: Your reversed string should not contain leading or trailing spaces. Example 3: Input: s = \u0026#34;a good example\u0026#34; Output: \u0026#34;example good a\u0026#34; Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string. Constraints: 1 \u0026lt;= s.length \u0026lt;= 104 s contains English letters (upper-case and lower-case), digits, and spaces \u0026#39; \u0026#39;. There is at least one word in s. Follow-up: If the string data type is mutable in your language, can you solve it in-place with O(1) extra space? 1 2 3 4 5 6 7 /* * 思路: solution1: stack實現reverse * 1，先遍歷字符串數組，剪切掉space，取出word按順序存入stack； * 2，stack pop出world，加上space拼接成字符串 * */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // @lc code=start import java.util.ArrayList; import java.util.List; import java.util.Stack; class Solution { public String reverseWords(String s) { //通过在分割字符串之前使用trim()去除首尾空格 //，并使用正则表达式\u0026#34;\\\\s+\u0026#34;匹配多个空格，可以避免空字符串的问题 String [] spStrings = s.trim().split(\u0026#34;\\\\s+\u0026#34;); Stack\u0026lt;String\u0026gt; stackString = new Stack(); for(int i =0; i\u0026lt; spStrings.length; i++){ stackString.push(spStrings[i]); } List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); while (!stackString.empty()) { list.add(stackString.pop()); } return String.join(\u0026#34; \u0026#34;, list); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* * Follow-up: If the string data type is mutable in your language, can you * solve it in-place with O(1) extra space? * * 思路：雙指針法 * 與344. Reverse String思路一致， * 1.先剪切首尾空格與中間多餘空格 2.先反轉字符串，這時單詞也被反轉了 3.再反轉單詞 注意：處理// 反转最后一个单词 * * * * * * */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Solution { public String reverseWords(String s) { // 将字符串转换为字符数组 char[] schar = s.toCharArray(); // 字符数组的长度 int length = schar.length; // 去除首尾和中间多余的空格 int slow = 0; // 慢指针，记录新字符串的长度 int fast = 0; // 快指针，遍历原始字符串 while (fast \u0026lt; length) { // 跳过前导空格 while (fast \u0026lt; length \u0026amp;\u0026amp; schar[fast] == \u0026#39; \u0026#39;) fast++; // 将非空字符移到慢指针位置 if (slow \u0026gt; 0 \u0026amp;\u0026amp; fast \u0026lt; length) { schar[slow++] = \u0026#39; \u0026#39;; } // 将单词复制到新字符串 while (fast \u0026lt; length \u0026amp;\u0026amp; schar[fast] != \u0026#39; \u0026#39;) { schar[slow++] = schar[fast++]; } } // 反转整个字符串 reverseString(schar, 0, slow - 1); // 反转各个单词 int start = 0; // 单词起始位置 for (int i = 0; i \u0026lt; slow; i++) { if (schar[i] == \u0026#39; \u0026#39;) { // 反转单词 reverseString(schar, start, i - 1); // 更新单词起始位置 start = i + 1; } } // 反转最后一个单词 reverseString(schar, start, slow - 1); // 将字符数组转换为字符串 return new String(schar, 0, slow); } // 反转字符数组的指定区间 public void reverseString(char[] schar, int start, int end) { while (start \u0026lt; end) { char tmp = schar[start]; schar[start] = schar[end]; schar[end] = tmp; start++; end--; } } } // @lc code=end ","date":"2024-05-15T00:00:00Z","image":"https://kris0325.github.io/p/151.-reverse-words-in-a-string/151_hua62bcbcf9a79dfe26d0875c8d67438b3_8789011_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/151.-reverse-words-in-a-string/","title":"151. Reverse Words in a String"},{"content":"https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 Find the Index of the First Occurrence in a String Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (42.25%)\t5645\t390 Tags two-pointers | string Companies apple | facebook | microsoft | pocketgems Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = \u0026#34;sadbutsad\u0026#34;, needle = \u0026#34;sad\u0026#34; Output: 0 Explanation: \u0026#34;sad\u0026#34; occurs at index 0 and 6. The first occurrence is at index 0, so we return 0. Example 2: Input: haystack = \u0026#34;leetcode\u0026#34;, needle = \u0026#34;leeto\u0026#34; Output: -1 Explanation: \u0026#34;leeto\u0026#34; did not occur in \u0026#34;leetcode\u0026#34;, so we return -1. Constraints: 1 \u0026lt;= haystack.length, needle.length \u0026lt;= 104 haystack and needle consist of only lowercase English characters. 1 2 3 4 5 6 7 8 9 /** * 思路：滑動窗口 / 雙指針法， 只是左右指針同步移動，haystack.substring(i, i+needle.length()) 1.needle.length \u0026gt; haystack,直接return -1; 2.從haystack的起始位置i=0開始,取needle.length長度子字符串與needle比較， 字符串不相同，則滑動needle.length長度繼續比較，直到i到達haystack.length-needle.length位置， 字符串相同，則return 位置i; **/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // @lc code=start class Solution { public int strStr(String haystack, String needle) { if(haystack.length()\u0026lt;needle.length()){ return -1; } for(int i = 0; i \u0026lt;= haystack.length()-needle.length();i++ ){ if(needle.equals(haystack.substring(i, i+needle.length()))){ return i; } } return -1; } } // @lc code=end ","date":"2024-05-15T00:00:00Z","image":"https://kris0325.github.io/p/28.-find-the-index-of-the-first-occurrence-in-a-string/28_hud97b491a9f638fe86f3a609aa163e872_18321669_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/28.-find-the-index-of-the-first-occurrence-in-a-string/","title":"28. Find the Index of the First Occurrence in a String"},{"content":"https://leetcode.com/problems/reverse-string/description/\n1 2 3 4 5 6 7 8 9 /** * 思路：双指针算法 本题要求使用原地算法 in-place算法 with O(1) extra memory，不能使用额外内存，所以考虑使用双指针算法， left,right指针分别指向数组首尾， 使用临时变量tmp暂存 s[left]，然后交换首尾元素， 然后左右指针收缩。 扩展：本题如果不要求使用in-place算法，可以通过stack先进后出的数据结构实现求解 */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // @lc code=start class Solution { public void reverseString(char[] s) { int left = 0; int right = s.length-1; while (left \u0026lt; right) { char tmp = s[left]; s[left] = s[right]; s[right] = tmp; left++; right--; } } } // @lc code=end ","date":"2024-05-14T00:00:00Z","image":"https://kris0325.github.io/p/344.-reverse-string/344_hua62bcbcf9a79dfe26d0875c8d67438b3_6409887_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/344.-reverse-string/","title":"344. Reverse String"},{"content":"https://leetcode.com/problems/4sum/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 4Sum Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (36.24%)\t11135\t1367 Tags array | hash-table | two-pointers Companies linkedin Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that: 0 \u0026lt;= a, b, c, d \u0026lt; n a, b, c, and d are distinct. nums[a] + nums[b] + nums[c] + nums[d] == target You may return the answer in any order. Example 1: Input: nums = [1,0,-1,0,-2,2], target = 0 Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] Example 2: Input: nums = [2,2,2,2,2], target = 8 Output: [[2,2,2,2]] Constraints: 1 \u0026lt;= nums.length \u0026lt;= 200 -109 \u0026lt;= nums[i] \u0026lt;= 109 -109 \u0026lt;= target \u0026lt;= 109 思路： 与15.3sum 很像，也是使用双指针，只需再加一成for循环即可. 另外，需要注意剪枝，与去重 https://leetcode.com/problems/3sum/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // @lc code=start import java.util.ArrayList; import java.util.Arrays; class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; fourSum(int[] nums, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); for(int i = 0; i\u0026lt; nums.length; i++){ //剪枝 if(nums[i]\u0026gt;target \u0026amp;\u0026amp; nums[i]\u0026gt;=0 ) { break; } //nums[i]去重 if(i\u0026gt;0 \u0026amp;\u0026amp; nums[i] == nums[i-1]){ continue; } for(int j = i+1; j \u0026lt; nums.length; j++){ //剪枝 if(nums[i] + nums[j]\u0026gt;target \u0026amp;\u0026amp; nums[j]\u0026gt;=0 ) { break; } //nums[i]去重 if(j\u0026gt;i+1 \u0026amp;\u0026amp; nums[j]==nums[j-1]){ continue; } int left = j+1; int right = nums.length-1; while (left \u0026lt; right) { int sum = nums[i]+nums[j]+nums[left]+nums[right]; int longTarget = target; //在Java中，int类型的最大值可以通过Integer.MAX_VALUE常量来表示，具体数值为2147483647，即$2^{31}-1， // 所以 nums[i]+nums[j]+nums[left]+nums[right]不会溢出 // Long sum = Long.valueOf(nums[i]+nums[j]+nums[left]+nums[right]) ; // Long longTarget = Long.valueOf(target) ; if (sum \u0026lt; longTarget) { left++; } else if (sum \u0026gt; longTarget) { right--; } else { //收集答案 result.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right])); //对nums[left]去重 while(right \u0026gt; left \u0026amp;\u0026amp; nums[left] == nums[left+1]){ left++; } //nums[right]去重 while (right \u0026gt; left \u0026amp;\u0026amp; nums[right] == nums[right-1]) { right--; } //双指针同时收缩 right--; left++; } } } } return result; } } // @lc code=end ","date":"2024-05-13T00:00:00Z","image":"https://kris0325.github.io/p/18.-4sum/18_hua62bcbcf9a79dfe26d0875c8d67438b3_5204973_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/18.-4sum/","title":"18. 4Sum"},{"content":"https://leetcode.com/problems/reverse-string-ii/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 Reverse String II Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (50.66%)\t1944\t3753 Tags string Companies google Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string. If there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and leave the other as original. Example 1: Input: s = \u0026#34;abcdefg\u0026#34;, k = 2 Output: \u0026#34;bacdfeg\u0026#34; Example 2: Input: s = \u0026#34;abcd\u0026#34;, k = 2 Output: \u0026#34;bacd\u0026#34; Constraints: 1 \u0026lt;= s.length \u0026lt;= 104 s consists of only lowercase English letters. 1 \u0026lt;= k \u0026lt;= 104 思路：双指针法 本题与344.Reverse String解法思路相同，都是用双指针法， 按照规律， 1.可以将字符串s 每2k间段进行切分，每段都是reverse前k个字符， 2.然后考虑边界条件，即末尾分情况讨论： 2.1 末尾剩余长度lenth满足 k \u0026lt;lenth \u0026lt; 2k, 即 pos+k \u0026lt; s.length, 则反转前k个字符，其实操作和第1.步一样, 即 reverse(ch, pos, pos+k-1)； 2.2 末尾剩余长度lenth满足 lenth \u0026lt; k, 即pos+k \u0026gt; s.length, 则反转所有剩余字符，即 reverse(ch, pos, ch.length-1); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public String reverseStr(String s, int k) { char[]s2char = s.toCharArray(); for(int pos = 0; pos \u0026lt; s.length(); pos += 2*k){ if(pos+k \u0026lt; s.length()){ reverse(s2char, pos, pos+k-1); } else { reverse(s2char, pos, s2char.length-1); } } return new String(s2char); } public void reverse(char[] str, int leftPos, int rightPos){ while(leftPos \u0026lt; rightPos){ char tmp = str[leftPos]; str[leftPos] = str[rightPos]; str[rightPos] = tmp; leftPos++; rightPos--; } } } ","date":"2024-05-13T00:00:00Z","image":"https://kris0325.github.io/p/541.-reverse-string-ii/541_hua62bcbcf9a79dfe26d0875c8d67438b3_5193231_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/541.-reverse-string-ii/","title":"541. Reverse String II"},{"content":"https://leetcode.com/problems/3sum/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 3Sum Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (34.46%)\t30399\t2815 Tags array | two-pointers Companies adobe | amazon | bloomberg | facebook | microsoft Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets. Example 1: Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0. nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0. The distinct triplets are [-1,0,1] and [-1,-1,2]. Notice that the order of the output and the order of the triplets does not matter. Example 2: Input: nums = [0,1,1] Output: [] Explanation: The only possible triplet does not sum up to 0. Example 3: Input: nums = [0,0,0] Output: [[0,0,0]] Explanation: The only possible triplet sums up to 0. Constraints: 3 \u0026lt;= nums.length \u0026lt;= 3000 -105 \u0026lt;= nums[i] \u0026lt;= 105 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* 思路：solution1雙指針法 Notice that the solution set must not contain duplicate triplets.需要去重複,雙指針法比哈希表算法更簡單 1.排序 2.i去重複 i\u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1],(三元數組內部元素可以重複，所以需要用後一個數與前一個數進行比較， 並且從第二個數i=1開始，比如case[-1,-1,0], 所以不能使用條件nums[i] == nums[i+1]判斷，或漏掉， 也就是說三元數組不能重複，但三元數組內部元素可以重複) 3. i遍歷數組， 每次循環left= i+1; right = nums.length()-1, 4. when( left \u0026lt; right), nums[i] + nums[j] + nums[k] \u0026lt; 0 , 將left指針右移， nums[i] + nums[j] + nums[k] \u0026gt; 0 , 將right指針左移， 5. 直到找到三元數組，滿足 nums[i] + nums[j] + nums[k] == 0， 6. 然後left | right 去重複 nums[left] == nums[left+1], left++; nums[right] == nums[right-1], right--; solution2 哈希表法 **/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 import java.util.ArrayList; import java.util.List; class Solution1 { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); for (int i = 0; i \u0026lt; nums.length; i++) { //剪枝， 排序後，第一個數大於零，則無法滿足條件，可以直接return if (nums[i] \u0026gt; 0) { return result; } // nums[i]去重 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } int left = i + 1; int right = nums.length - 1; while (right \u0026gt; left) { if (nums[i] + nums[left] + nums[right] \u0026lt; 0) { left++; } else if (nums[i] + nums[left] + nums[right] \u0026gt; 0) { right--; } else if (nums[i] + nums[left] + nums[right] == 0) { //收集滿足條件的三元數組 result.add(Arrays.asList(nums[i], nums[left], nums[right])); // left指針去重複 while (right \u0026gt; left \u0026amp;\u0026amp; nums[left] == nums[left + 1]) { left++; } // right右指針去重複 while (right \u0026gt; left \u0026amp;\u0026amp; nums[right] == nums[right - 1]) { right--; } left++; right--; } } } return result; } } class Solution2 { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); for (int i = 0; i \u0026lt; nums.length; i++) { // 如果第一个元素大于零，不可能凑成三元组 if (nums[i] \u0026gt; 0) { return result; } // 三元组元素a去重 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } HashSet\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (int j = i + 1; j \u0026lt; nums.length; j++) { // 三元组元素b去重 /** 注意:元素b取去重時，需要考慮只有當當前元素nums[j]， 與之前第一個元素nums[j-1]，之前第2個元素都相同時， 也就是前三個元素都相同時，才需要考慮去重跳過。 否則，只考慮 nums[j] == nums[j - 1]，會出現過度去重，漏掉正確答案。 根本原因在於,三元組數組之間不能重複，但時單個三元組內部元素可以重複。 例如： /** * if (j \u0026gt; i + 2 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) { continue; } * * Wrong Answer: Input nums = [-2,0,1,1,2] Output [[-2,2,0]] Expected [[-2,0,2],[-2,1,1]] */ if (j \u0026gt; i + 2 \u0026amp;\u0026amp; nums[j] == nums[j - 1]\u0026amp;\u0026amp; nums[j - 1] == nums[j - 2] ) { continue; } int c = -nums[i] - nums[j]; if (set.contains(c)) { result.add(Arrays.asList(nums[i], nums[j], c)); set.remove(c); // 三元组元素c去重 } else { set.add(nums[j]); } } } return result; } } // @lc code=end ","date":"2024-05-12T00:00:00Z","image":"https://kris0325.github.io/p/15.-3sum/15_hua62bcbcf9a79dfe26d0875c8d67438b3_12225185_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/15.-3sum/","title":"15. 3Sum"},{"content":"https://leetcode.com/problems/ransom-note/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 Ransom Note Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (61.30%)\t4905\t496 Tags string Companies apple Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise. Each letter in magazine can only be used once in ransomNote. Example 1: Input: ransomNote = \u0026#34;a\u0026#34;, magazine = \u0026#34;b\u0026#34; Output: false Example 2: Input: ransomNote = \u0026#34;aa\u0026#34;, magazine = \u0026#34;ab\u0026#34; Output: false Example 3: Input: ransomNote = \u0026#34;aa\u0026#34;, magazine = \u0026#34;aab\u0026#34; Output: true Constraints: 1 \u0026lt;= ransomNote.length, magazine.length \u0026lt;= 105 ransomNote and magazine consist of lowercase English letters. 1 2 3 4 5 6 7 8 9 10 /* * 思路：哈希表 Solution1： 分别使用hashMap收集ransomNote, magazine的letter数量， key-\u0026gt; letter, value-\u0026gt;nums, 再遍歷hashmap，當Each letter in magazine對應的value必須大於等於ransomNote對應的hashmap， return true, 否則false Solution2： 本题与 242. Valid Anagram 242.有效的字母异位词很像, 可以使用哈希数组 */i 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // @lc code=start import java.util.HashMap; import java.util.Map; class Solution1 { public boolean canConstruct(String ransomNote, String magazine) { HashMap\u0026lt;Character, Integer\u0026gt; ransomNoteMap = new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;Character, Integer\u0026gt; magazineMap = new HashMap\u0026lt;\u0026gt;(); for(int i = 0; i\u0026lt; ransomNote.length(); i++){ Character letter = ransomNote.charAt(i); ransomNoteMap.put(letter, ransomNoteMap.getOrDefault(letter,0)+1); } for(int i = 0; i\u0026lt; magazine.length(); i++ ){ Character letter = magazine.charAt(i); magazineMap.put(letter, magazineMap.getOrDefault(letter,0)+1); } for(Map.Entry\u0026lt;Character, Integer\u0026gt; entry : ransomNoteMap.entrySet()){ if(!magazineMap.containsKey(entry.getKey()) || (magazineMap.containsKey(entry.getKey()) \u0026amp;\u0026amp; magazineMap.get(entry.getKey()) \u0026lt; entry.getValue())){ return false; } } return true; } } class Solution2 { public boolean canConstruct(String ransomNote, String magazine) { // shortcut if (ransomNote.length() \u0026gt; magazine.length()) { return false; } // 定义一个哈希映射数组 int[] record = new int[26]; // 遍历 for(char c : magazine.toCharArray()){ record[c - \u0026#39;a\u0026#39;] += 1; } for(char c : ransomNote.toCharArray()){ record[c - \u0026#39;a\u0026#39;] -= 1; } // 如果数组中存在负数，说明ransomNote字符串总存在magazine中没有的字符 for(int i : record){ if(i \u0026lt; 0){ return false; } } return true; } } // @lc code=end 1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* * 时间复杂度, 空间复杂度分析 Solution1的时间复杂度为O(m + n)，其中m为ransomNote字符串的长度，n为magazine字符串的长度。在该解决方案中，首先需要遍历ransomNote和magazine字符串各一次，然后需要遍历ransomNoteMap中的键值对，因此总的时间复杂度为O(m + n)。 Solution2的时间复杂度也为O(m + n)，其中m为ransomNote字符串的长度，n为magazine字符串的长度。在该解决方案中，首先需要遍历magazine字符串和ransomNote字符串各一次，然后遍历record数组，因此总的时间复杂度为O(m + n)。 对于空间复杂度，Solution1使用了两个HashMap来存储ransomNote和magazine字符串中字符出现的次数，因此空间复杂度为O(m + n)，其中m和n分别为ransomNote和magazine字符串的长度。 而Solution2使用了一个长度为26的数组record来记录magazine字符串中各个字符出现的次数，因此空间复杂度为O(1)，与字符串的长度无关。 在面试中，Solution2更好一些。因为它不需要额外的HashMap数据结构，只需要一个固定大小的数组即可完成任务，节省了空间，并且时间复杂度也相同。此外，Solution2的实现更加简洁明了，易于理解和维护。 * * */ ","date":"2024-05-12T00:00:00Z","image":"https://kris0325.github.io/p/383.-ransom-note/383_hua62bcbcf9a79dfe26d0875c8d67438b3_6347894_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/383.-ransom-note/","title":"383. Ransom Note"},{"content":"https://leetcode.com/problems/two-sum/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 1. Two Sum Easy Topics Companies Hint Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Example 1: Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]. Example 2: Input: nums = [3,2,4], target = 6 Output: [1,2] Example 3: Input: nums = [3,3], target = 6 Output: [0,1] Constraints: 2 \u0026lt;= nums.length \u0026lt;= 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 -109 \u0026lt;= target \u0026lt;= 109 Only one valid answer exists. Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int[] twoSum(int[] nums, int target) { int[] result = new int[2]; //利用HashMap 优化时间复杂度到o(n) Map\u0026lt;Integer, Integer\u0026gt; tmpMap = new HashMap\u0026lt;\u0026gt;(); for(int i =0; i \u0026lt; nums.length ; i ++ ){ if(tmpMap.containsKey(target - nums[i])){ result[0] = tmpMap.get(target - nums[i]); result[1] = i; return result; } tmpMap.put(nums[i],i); } return result; } } ","date":"2024-05-11T00:00:00Z","image":"https://kris0325.github.io/p/1.-two-sum/1_hua62bcbcf9a79dfe26d0875c8d67438b3_9401146_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/1.-two-sum/","title":"1. Two Sum"},{"content":"https://leetcode.com/problems/4sum-ii/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 4Sum II Category\tDifficulty\tLikes\tDislikes algorithms\tMedium (57.24%)\t4879\t140 Tags hash-table | binary-search Companies Unknown Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that: 0 \u0026lt;= i, j, k, l \u0026lt; n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 Example 1: Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2] Output: 2 Explanation: The two tuples are: 1. (0, 0, 0, 1) -\u0026gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -\u0026gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0 Example 2: Input: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0] Output: 1 Constraints: n == nums1.length n == nums2.length n == nums3.length n == nums4.length 1 \u0026lt;= n \u0026lt;= 200 -228 \u0026lt;= nums1[i], nums2[i], nums3[i], nums4[i] \u0026lt;= 228 1 2 3 4 5 6 /** * 思路：哈希表 條件 nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0， 可以拆分為 (nums1[i] + nums2[j] )+ (nums2[j] + nums3[k]) == 0, 还是 1. Two Sum（1.两数之和问题) */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // @lc code=start class Solution { public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) { HashMap\u0026lt;Integer, Integer\u0026gt; fourSum = new HashMap\u0026lt;\u0026gt;(); int count = 0; for(int i : nums1){ for(int j : nums2){ int sum = i +j; fourSum.put(sum, fourSum.getOrDefault(sum,0)+1); } } for(int k : nums3){ for(int l : nums4){ count += fourSum.getOrDefault((0-(k+l)), 0); } } return count; } } // @lc code=end ","date":"2024-05-11T00:00:00Z","image":"https://kris0325.github.io/p/454.-4sum-ii/454_hua62bcbcf9a79dfe26d0875c8d67438b3_7993144_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/454.-4sum-ii/","title":"454. 4Sum II"},{"content":"https://leetcode.com/problems/happy-number/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 Happy Number Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (56.07%)\t10182\t1411 Tags hash-table | math Companies airbnb | twitter | uber Write an algorithm to determine if a number n is happy. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy. Return true if n is a happy number, and false if not. Example 1: Input: n = 19 Output: true Explanation: 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 Example 2: Input: n = 2 Output: false 1 2 3 4 5 6 7 /* * 思路：哈希表 or it loops endlessly in a cycle which does not include 1, 即表明n is happy时, 無限循環，那麼可以推斷，只要紀錄每次循環的sum，總有sum會發生重複， 因此可以使用hashset收集每次循環的sum，然後判斷是否存在重複的值 * */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // @lc code=start import java.util.HashSet; class Solution { public boolean isHappy(int n) { HashSet\u0026lt;Integer\u0026gt; sumsSet = new HashSet\u0026lt;\u0026gt;(); // ishappy n == 1 , is not happy, sum會重複即 sumsSet.contains(n)，跳出 while (n != 1 \u0026amp;\u0026amp; !sumsSet.contains(n)) { sumsSet.add(n); n = getSum(n); } return n == 1; } int getSum(int n){ int sum = 0; while (n \u0026gt; 0) { //先獲取最左邊低位數值 int low = n % 10; sum += low *low; //去掉最左邊低位數值 n = n / 10; } return sum; } } // @lc code=end ","date":"2024-05-10T00:00:00Z","image":"https://kris0325.github.io/p/202.-happy-number/202_hua62bcbcf9a79dfe26d0875c8d67438b3_9400923_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/202.-happy-number/","title":"202. Happy Number"},{"content":" https://leetcode.com/problems/intersection-of-two-arrays/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Intersection of Two Arrays Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (74.44%)\t5958\t2289 Tags hash-table | two-pointers | binary-search | sort Companies twosigma Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2] Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4] Explanation: [4,9] is also accepted. Constraints: 1 \u0026lt;= nums1.length, nums2.length \u0026lt;= 1000 0 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 1000 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* 思路：哈希表 使用hashset存nums1的元素, 再遍历nums2收集intersection * */ // @lc code=start import java.util.ArrayList; import java.util.HashSet; class Solution { public int[] intersection(int[] nums1, int[] nums2) { HashSet\u0026lt;Integer\u0026gt; setNums1 = new HashSet\u0026lt;\u0026gt;(); HashSet\u0026lt;Integer\u0026gt; setNums = new HashSet\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt; nums1.length ; i++){ setNums1.add(nums1[i]); } for(int i = 0; i \u0026lt; nums2.length; i++){ if (setNums1.contains(nums2[i])) { setNums.add(nums2[i]); } } // int [] nums = new int[setNums.size()]; // int index = 0; // for (int num : setNums) { // nums[index++] = num; // } // return nums; return setNums.stream().mapToInt(i -\u0026gt; i).toArray(); } } // @lc code=end ","date":"2024-05-10T00:00:00Z","image":"https://kris0325.github.io/p/349.-intersection-of-two-arrays/349_hu8e35c18113cfb820c0efc87111a50e50_9589620_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/349.-intersection-of-two-arrays/","title":"349. Intersection of Two Arrays"},{"content":"https://leetcode.com/problems/valid-anagram/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 Category\tDifficulty\tLikes\tDislikes algorithms\tEasy (64.48%)\t11937\t394 Tags hash-table | sort Companies amazon | uber | yelp Given two strings s and t, return true if t is an anagram of s, and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Example 1: Input: s = \u0026#34;anagram\u0026#34;, t = \u0026#34;nagaram\u0026#34; Output: true Example 2: Input: s = \u0026#34;rat\u0026#34;, t = \u0026#34;car\u0026#34; Output: false Constraints: 1 \u0026lt;= s.length, t.length \u0026lt;= 5 * 104 s and t consist of lowercase English letters. Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case? /* 思路：哈希表 * 异位词，即两个单词/短语s1, s2互为重排，其充要条件是 * 1字符串的字符总数量， * 2以及每个字符对应的数量相同。 * 因此可以使用哈希表分别统计字符串中各个字符数量 key:字符，value:数量， * 统计s1时，value+1， 统计s2时value-1， * 当最终哈希表中所有字符对应的统计数值为0，则互为重排。 */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // @lc code=start import java.util.HashMap; class Solution { public boolean isAnagram(String s, String t) { HashMap\u0026lt;Character, Integer\u0026gt; dic = new HashMap\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt;s.length(); i++){ dic.put(s.charAt(i), dic.getOrDefault(s.charAt(i), 0)+1); } for(int i = 0; i \u0026lt; t.length(); i++){ dic.put(t.charAt(i), dic.getOrDefault(t.charAt(i), 0)-1); } for(int val : dic.values()){ if(val !=0){ return false; } } return true; } } // @lc code=end ","date":"2024-05-09T00:00:00Z","image":"https://kris0325.github.io/p/242.-valid-anagram/242_hua62bcbcf9a79dfe26d0875c8d67438b3_3686299_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/242.-valid-anagram/","title":"242. Valid Anagram"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 /* * @lc app=leetcode id=142 lang=java * * [142] Linked List Cycle II * * https://leetcode.com/problems/linked-list-cycle-ii/description/ * * algorithms * Medium (51.25%) * Likes: 13392 * Dislikes: 937 * Total Accepted: 1.3M * Total Submissions: 2.5M * Testcase Example: \u0026#39;[3,2,0,-4]\\n1\u0026#39; * * Given the head of a linked list, return the node where the cycle begins. If * there is no cycle, return null. * * There is a cycle in a linked list if there is some node in the list that can * be reached again by continuously following the next pointer. Internally, pos * is used to denote the index of the node that tail\u0026#39;s next pointer is * connected to (0-indexed). It is -1 if there is no cycle. Note that pos is * not passed as a parameter. * * Do not modify the linked list. * * * Example 1: * * * Input: head = [3,2,0,-4], pos = 1 * Output: tail connects to node index 1 * Explanation: There is a cycle in the linked list, where tail connects to the * second node. * * * Example 2: * * * Input: head = [1,2], pos = 0 * Output: tail connects to node index 0 * Explanation: There is a cycle in the linked list, where tail connects to the * first node. * * * Example 3: * * * Input: head = [1], pos = -1 * Output: no cycle * Explanation: There is no cycle in the linked list. * * * * Constraints: * * * The number of the nodes in the list is in the range [0, 10^4]. * -10^5 \u0026lt;= Node.val \u0026lt;= 10^5 * pos is -1 or a valid index in the linked-list. * * * * Follow up: Can you solve it using O(1) (i.e. constant) memory? * */ // @lc code=start /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } * * 思路：使用弗洛伊德判圈算法，即快慢指針， * 畫圖輔助， * 1若快慢指針能相遇，則存在環， * 2然後設置2個新指針，一個從頭節點開始，另一個指針從相遇節點開始，當兩指針相遇處即為環的入口節點 * 再 * * 使用快慢指针检测链表中循环的原理是一种常见且高效的算法，也被称为Floyd\u0026#39;s Tortoise and Hare Algorithm（弗洛伊德的乌龟和兔子算法）。这种算法通过使用两个指针，一个快指针和一个慢指针，来检测链表中是否存在循环，并找到循环的起始节点。 快慢指针的原理是，快指针每次移动两步，慢指针每次移动一步。如果链表中存在循环，快指针最终会追上慢指针。这是因为快指针的速度是慢指针的两倍，所以在循环中，快指针会绕圈追赶慢指针，最终相遇。 当快慢指针相遇时，我们可以得出以下结论： 链表中存在循环。 通过数学推导，可以确定链表中循环的起始节点。 具体来说，假设链表头到循环起始节点的距离为A，循环起始节点到快慢指针相遇点的距离为B。根据快慢指针的移动规律，可以得出以下等式：快指针走过的距离 = 2 * 慢指针走过的距离。根据这个等式，可以推导出A = C，即链表头到循环起始节点的距离等于相遇点到循环起始节点的距离。 因此，当快慢指针相遇后，我们可以设置一个新的指针从链表头开始，与相遇点的指针同时移动，它们相遇的节点就是循环的起始节点。 通过这种方法，我们可以高效地检测链表中的循环，并找到循环的起始节点，而且算法的时间复杂度为O(N)，空间复杂度为O(1)。 */ public class Solution { public ListNode detectCycle(ListNode head) { ListNode fast = head; ListNode slow = head; //需要确保快指针與快指針的下一个节点不为空，以避免空指针异常 while (fast != null \u0026amp;\u0026amp; fast.next !=null) { fast = fast.next.next; slow = slow.next; //相遇則存在環 if(slow == fast){ ListNode index1 = fast; //在检测到快慢指针相遇时，需要重新设置一个新的指针从头节点开始，以找到循环的入口点 ListNode index2 = head; while (index1 != index2) { index1 = index1.next; index2 = index2.next; } //index1與index2在環的入口處相遇 return index1; } } return null; } } // @lc code=end ","date":"2024-05-07T00:00:00Z","image":"https://kris0325.github.io/p/142.-linked-list-cycle-ii/142_hua62bcbcf9a79dfe26d0875c8d67438b3_10854839_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/142.-linked-list-cycle-ii/","title":"142. Linked List Cycle II"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 /* * @lc app=leetcode id=19 lang=java * * [19] Remove Nth Node From End of List * * https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/ * * algorithms * Medium (45.25%) * Likes: 18583 * Dislikes: 785 * Total Accepted: 2.7M * Total Submissions: 6M * Testcase Example: \u0026#39;[1,2,3,4,5]\\n2\u0026#39; * * Given the head of a linked list, remove the n^th node from the end of the * list and return its head. * * * Example 1: * * * Input: head = [1,2,3,4,5], n = 2 * Output: [1,2,3,5] * * * Example 2: * * * Input: head = [1], n = 1 * Output: [] * * * Example 3: * * * Input: head = [1,2], n = 1 * Output: [1] * * * * Constraints: * * * The number of nodes in the list is sz. * 1 \u0026lt;= sz \u0026lt;= 30 * 0 \u0026lt;= Node.val \u0026lt;= 100 * 1 \u0026lt;= n \u0026lt;= sz * * * * Follow up: Could you do this in one pass? * */ // @lc code=start /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } * * 思路：快慢指针 * 快指针先走步长n，然后慢指针后走，当快指针走到末尾， * 慢指针即指向倒数第n个节点the n^th node from the end of the. * 注意：邊界條件 * * solution優化：使用虛擬头節點dumyNode更方便，可以覆蓋邊界條件，不用特殊考慮 * * * * * * * list，remove即可 */ class Solution1 { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode fast = head; ListNode slow = head; //specil case: only one node if(slow.next == null){ return null; } for(int i = 0; i \u0026lt;n; i++){ fast = fast.next; } //specil case: when n == size of the list, the fast pointer is null, it means we need remove the head node if(fast == null){ return head.next; } while (fast.next != null) { fast = fast.next; slow = slow.next; } //At this point, the slow pointer is n nodes behind the fast pointer //, which means it\u0026#39;s pointing to the node just before the node we want to remove. //delete the n^th node from the end of the list slow.next = slow.next.next; return head; } } class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { //新建一个虚拟头节点指向head ListNode dummyNode = new ListNode(0); dummyNode.next = head; //快慢指针指向虚拟头节点 ListNode fastIndex = dummyNode; ListNode slowIndex = dummyNode; // 只要快慢指针相差 n 个结点即可 for (int i = 0; i \u0026lt;= n; i++) { fastIndex = fastIndex.next; } while (fastIndex != null) { fastIndex = fastIndex.next; slowIndex = slowIndex.next; } // 此时 slowIndex 的位置就是待删除元素的前一个位置。 // 具体情况可自己画一个链表长度为 3 的图来模拟代码来理解 // 检查 slowIndex.next 是否为 null，以避免空指针异常 if (slowIndex.next != null) { slowIndex.next = slowIndex.next.next; } return dummyNode.next; } } // @lc code=end ","date":"2024-05-06T00:00:00Z","image":"https://kris0325.github.io/p/19.-remove-nth-node-from-end-of-list/19_hua62bcbcf9a79dfe26d0875c8d67438b3_13769621_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/19.-remove-nth-node-from-end-of-list/","title":"19. Remove Nth Node From End of List"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 /* * @lc app=leetcode id=160 lang=java * * [160] Intersection of Two Linked Lists * * https://leetcode.com/problems/intersection-of-two-linked-lists/description/ * * algorithms * Easy (57.40%) * Likes: 14737 * Dislikes: 1327 * Total Accepted: 1.5M * Total Submissions: 2.7M * Testcase Example: \u0026#39;8\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n2\\n3\u0026#39; * * Given the heads of two singly linked-lists headA and headB, return the node * at which the two lists intersect. If the two linked lists have no * intersection at all, return null. * * For example, the following two linked lists begin to intersect at node c1: * * The test cases are generated such that there are no cycles anywhere in the * entire linked structure. * * Note that the linked lists must retain their original structure after the * function returns. * * Custom Judge: * * The inputs to the judge are given as follows (your program is not given * these inputs): * * * intersectVal - The value of the node where the intersection occurs. This is * 0 if there is no intersected node. * listA - The first linked list. * listB - The second linked list. * skipA - The number of nodes to skip ahead in listA (starting from the head) * to get to the intersected node. * skipB - The number of nodes to skip ahead in listB (starting from the head) * to get to the intersected node. * * * The judge will then create the linked structure based on these inputs and * pass the two heads, headA and headB to your program. If you correctly return * the intersected node, then your solution will be accepted. * * * Example 1: * * * Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = * 2, skipB = 3 * Output: Intersected at \u0026#39;8\u0026#39; * Explanation: The intersected node\u0026#39;s value is 8 (note that this must not be 0 * if the two lists intersect). * From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as * [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are * 3 nodes before the intersected node in B. * - Note that the intersected node\u0026#39;s value is not 1 because the nodes with * value 1 in A and B (2^nd node in A and 3^rd node in B) are different node * references. In other words, they point to two different locations in memory, * while the nodes with value 8 in A and B (3^rd node in A and 4^th node in B) * point to the same location in memory. * * * Example 2: * * * Input: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, * skipB = 1 * Output: Intersected at \u0026#39;2\u0026#39; * Explanation: The intersected node\u0026#39;s value is 2 (note that this must not be 0 * if the two lists intersect). * From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as * [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 * node before the intersected node in B. * * * Example 3: * * * Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = * 2 * Output: No intersection * Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it * reads as [1,5]. Since the two lists do not intersect, intersectVal must be * 0, while skipA and skipB can be arbitrary values. * Explanation: The two lists do not intersect, so return null. * * * * Constraints: * * * The number of nodes of listA is in the m. * The number of nodes of listB is in the n. * 1 \u0026lt;= m, n \u0026lt;= 3 * 10^4 * 1 \u0026lt;= Node.val \u0026lt;= 10^5 * 0 \u0026lt;= skipA \u0026lt; m * 0 \u0026lt;= skipB \u0026lt; n * intersectVal is 0 if listA and listB do not intersect. * intersectVal == listA[skipA] == listB[skipB] if listA and listB * intersect. * * * * Follow up: Could you write a solution that runs in O(m + n) time and use * only O(1) memory? */ // @lc code=start /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } * * 思路1：两个链表若有交点，从链表末尾向前看，必有一段公共节点，因此， * 先求出2个链表长度差gap, 长链表指针先走gap步长，直到长短两个链表位置对齐， * 同时移动长短链表的指针，直到两个指针相等，return， * 否则return null * */ // public class Solution { // public ListNode getIntersectionNode(ListNode headA, ListNode headB) { // int lenA =0; // int lenB =0; // ListNode nodeA = headA; // ListNode nodeB = headB; // while (nodeA != null) { // nodeA = nodeA.next; // lenA +=1; // } // while (nodeB != null) { // nodeB = nodeB.next; // lenB +=1; // } // nodeA = headA; // nodeB = headB; // if(lenB \u0026gt; lenA){ // int tmplen = lenA; // lenA = lenB; // lenB = tmplen; // ListNode nodetmp = nodeA; // nodeA = nodeB; // nodeB = nodetmp; // } // int gap = lenA -lenB; // while (gap-- \u0026gt; 0) { // nodeA = nodeA.next; // } // while (nodeA != null) { // if(nodeA == nodeB){ // return nodeA; // } // nodeA = nodeA.next; // nodeB = nodeB.next; // } // return null; // } // } /* 思路2：合并链表，同步移动指针寻找公共节点 本质上和思路1是一样的，就是指向短链表的快指针先走， 直到走完（两个链表长度之差）gap步长后， 这时快慢指针同步移动，再寻找公共节点 * * */ public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode pA = headA; ListNode pB = headB; while(pA != pB){ if(pA == null){ //指针pA走一步，直到走到a链表末尾，则转到b链表 pA = headB; } else { pA = pA.next; } //指针pB走一步，直到走到B链表末尾，则转到A链表 if(pB == null){ pB = headA; } else{ pB = pB.next; } } return pA; } } // @lc code=end ","date":"2024-05-03T00:00:00Z","image":"https://kris0325.github.io/p/160.-intersection-of-two-linked-lists/160_hua62bcbcf9a79dfe26d0875c8d67438b3_9016474_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/160.-intersection-of-two-linked-lists/","title":"160. Intersection of Two Linked Lists"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 /* * @lc app=leetcode id=24 lang=java * * [24] Swap Nodes in Pairs * * https://leetcode.com/problems/swap-nodes-in-pairs/description/ * * algorithms * Medium (64.32%) * Likes: 11816 * Dislikes: 436 * Total Accepted: 1.4M * Total Submissions: 2.1M * Testcase Example: \u0026#39;[1,2,3,4]\u0026#39; * * Given a linked list, swap every two adjacent nodes and return its head. You * must solve the problem without modifying the values in the list\u0026#39;s nodes * (i.e., only nodes themselves may be changed.) * * * Example 1: * * * Input: head = [1,2,3,4] * Output: [2,1,4,3] * * * Example 2: * * * Input: head = [] * Output: [] * * * Example 3: * * * Input: head = [1] * Output: [1] * * * * Constraints: * * * The number of nodes in the list is in the range [0, 100]. * 0 \u0026lt;= Node.val \u0026lt;= 100 * * */ // @lc code=start /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } 思路：正常模拟就行，注意断开指针的顺序 */ class Solution { public ListNode swapPairs(ListNode head) { //设置一个虚拟头节点 ListNode dumyHead = new ListNode(0); //将虚拟头结点指向head，这样方便后面操作 dumyHead.next = head; ListNode cur = dumyHead; //临时节点，保存两个节点之中的第一个节点 ListNode firstNode ; // 临时节点，保存两个节点之中的第二个节点 ListNode secondeNode ; while (cur.next != null \u0026amp;\u0026amp; cur.next.next != null) { // tmpNode = cur.next.next.next; firstNode = cur.next; secondeNode = cur.next.next; //1 cur指针next指向第2个节点 cur.next = secondeNode; //2 第一个节点指针next指向第三个节点 firstNode.next = secondeNode.next; //3 第二个节点指针next指向第一个节点 secondeNode.next = firstNode; //移动cur指针，准备下一轮交换 cur = cur.next.next; } return dumyHead.next; } } // @lc code=end ","date":"2024-05-03T00:00:00Z","image":"https://kris0325.github.io/p/24.-swap-nodes-in-pairs/24_hua62bcbcf9a79dfe26d0875c8d67438b3_9882202_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/24.-swap-nodes-in-pairs/","title":"24. Swap Nodes in Pairs"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 /* * @lc app=leetcode.cn id=707 lang=java * * [707] 设计链表 * * https://leetcode.cn/problems/design-linked-list/description/ * * algorithms * Medium (34.47%) * Likes: 1013 * Dislikes: 0 * Total Accepted: 302.8K * Total Submissions: 879.7K * Testcase Example: \u0026#39;[\u0026#34;MyLinkedList\u0026#34;,\u0026#34;addAtHead\u0026#34;,\u0026#34;addAtTail\u0026#34;,\u0026#34;addAtIndex\u0026#34;,\u0026#34;get\u0026#34;,\u0026#34;deleteAtIndex\u0026#34;,\u0026#34;get\u0026#34;]\\n\u0026#39; + \u0026#39;[[],[1],[3],[1,2],[1],[1],[1]]\u0026#39; * * 你可以选择使用单链表或者双链表，设计并实现自己的链表。 * * 单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。 * * 如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。 * * 实现 MyLinkedList 类： * * * MyLinkedList() 初始化 MyLinkedList 对象。 * int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。 * void addAtHead(int val) 将一个值为 val * 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。 * void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。 * void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 * index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。 * void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。 * * * * * 示例： * * * 输入 * [\u0026#34;MyLinkedList\u0026#34;, \u0026#34;addAtHead\u0026#34;, \u0026#34;addAtTail\u0026#34;, \u0026#34;addAtIndex\u0026#34;, \u0026#34;get\u0026#34;, * \u0026#34;deleteAtIndex\u0026#34;, \u0026#34;get\u0026#34;] * [[], [1], [3], [1, 2], [1], [1], [1]] * 输出 * [null, null, null, null, 2, null, 3] * * 解释 * MyLinkedList myLinkedList = new MyLinkedList(); * myLinkedList.addAtHead(1); * myLinkedList.addAtTail(3); * myLinkedList.addAtIndex(1, 2); // 链表变为 1-\u0026gt;2-\u0026gt;3 * myLinkedList.get(1); // 返回 2 * myLinkedList.deleteAtIndex(1); // 现在，链表变为 1-\u0026gt;3 * myLinkedList.get(1); // 返回 3 * * * * * 提示： * * * 0 \u0026lt;= index, val \u0026lt;= 1000 * 请不要使用内置的 LinkedList 库。 * 调用 get、addAtHead、addAtTail、addAtIndex 和 deleteAtIndex 的次数不超过 2000 。 * * */ // @lc code=start class ListNode { int val; ListNode next; ListNode(){}; ListNode(int val){ this.val = val; }; } class MyLinkedList { int size; ListNode head; public MyLinkedList() { size = 0; head = new ListNode(0); } public int get(int index) { if(index \u0026lt; 0 || index \u0026gt;= size){ return -1; } ListNode cur = head; for(int i = 0; i \u0026lt;= index; i++){ cur = cur.next; } return cur.val; } public void addAtHead(int val) { addAtIndex(0, val); } public void addAtTail(int val) { addAtIndex(size, val); } public void addAtIndex(int index, int val) { if(index \u0026gt; size){ return; } if(index \u0026lt; 0){ index = 0; } size++; //寻找到要插入节点的前驱 ListNode pre = head; for(int i = 0; i\u0026lt;index; i++){ pre = pre.next; } ListNode target = new ListNode(val); target.next = pre.next; pre.next = target; } //删除第index节点 public void deleteAtIndex(int index) { if(index \u0026gt;= size || index \u0026lt;0){ return; } size--; ListNode pre = head; for(int i =0; i\u0026lt;index;i++ ){ pre = pre.next; } pre.next = pre.next.next; } } /** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList obj = new MyLinkedList(); * int param_1 = obj.get(index); * obj.addAtHead(val); * obj.addAtTail(val); * obj.addAtIndex(index,val); * obj.deleteAtIndex(index); */ // @lc code=end ","date":"2024-04-14T00:00:00Z","image":"https://kris0325.github.io/p/707.-design-linked-list/707_hu5477be140e37c38e9e48439fae2f6b6b_3708872_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/707.-design-linked-list/","title":"707. Design Linked List"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 /* * @lc app=leetcode.cn id=206 lang=java * * [206] 反转链表 * * https://leetcode.cn/problems/reverse-linked-list/description/ * * algorithms * Easy (74.06%) * Likes: 3545 * Dislikes: 0 * Total Accepted: 1.8M * Total Submissions: 2.5M * Testcase Example: \u0026#39;[1,2,3,4,5]\u0026#39; * * 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 * * * * * 示例 1： * * * 输入：head = [1,2,3,4,5] * 输出：[5,4,3,2,1] * * * 示例 2： * * * 输入：head = [1,2] * 输出：[2,1] * * * 示例 3： * * * 输入：head = [] * 输出：[] * * * * * 提示： * * * 链表中节点的数目范围是 [0, 5000] * -5000 * * * * * 进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？ * * * */ // @lc code=start /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } * * 思路：双指针，迭代翻转链表 */ class Solution { public ListNode reverseList(ListNode head) { ListNode pre = null; ListNode cur = head; while (cur!= null) { //保存下一个节点 ListNode tmp = cur.next; //翻转操作，即断开当前指针并指向前一个指针 cur.next = pre; //向后移动 pre, cur指针 pre = cur; cur = tmp; } return pre; } } // @lc code=end ","date":"2024-04-06T00:00:00Z","image":"https://kris0325.github.io/p/206.-reverse-linked-list/206_hu5477be140e37c38e9e48439fae2f6b6b_11654075_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/206.-reverse-linked-list/","title":"206. Reverse Linked List"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 /* * @lc app=leetcode.cn id=203 lang=java * * [203] 移除链表元素 * * https://leetcode.cn/problems/remove-linked-list-elements/description/ * * algorithms * Easy (56.20%) * Likes: 1404 * Dislikes: 0 * Total Accepted: 706.2K * Total Submissions: 1.3M * Testcase Example: \u0026#39;[1,2,6,3,4,5,6]\\n6\u0026#39; * * 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 * * * 示例 1： * * * 输入：head = [1,2,6,3,4,5,6], val = 6 * 输出：[1,2,3,4,5] * * * 示例 2： * * * 输入：head = [], val = 1 * 输出：[] * * * 示例 3： * * * 输入：head = [7,7,7,7], val = 7 * 输出：[] * * * * * 提示： * * * 列表中的节点数目在范围 [0, 10^4] 内 * 1 * 0 * * */ // @lc code=start /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeElements(ListNode head, int val) { // 头节点 是满足 Node.val == val 的节点，删除头节点, // 但是next节点的值可能也相等，所以循环遍历 while(head != null \u0026amp;\u0026amp; head.val == val){ head = head.next; } if (head == null) { return head; } ListNode cur = head; while (cur.next != null) { if(cur.next.val == val){ cur.next = cur.next.next; } else { cur = cur.next; } } return head; } } // class Solution { // public ListNode removeElements(ListNode head, int val) { // ListNode dummy = new ListNode(0); // dummy.next = head; // ListNode prev = dummy; // ListNode cur = head; // while (cur != null) { // if (cur.val == val) { // prev.next = cur.next; // } else { // prev = cur; // } // cur = cur.next; // } // return dummy.next; // } // } // @lc code=end ","date":"2024-03-30T00:00:00Z","image":"https://kris0325.github.io/p/203.-remove-linked-list-elements/203_hu5477be140e37c38e9e48439fae2f6b6b_10247729_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/203.-remove-linked-list-elements/","title":"203. Remove Linked List Elements"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 /* * @lc app=leetcode.cn id=59 lang=java * * [59] 螺旋矩阵 II * * https://leetcode.cn/problems/spiral-matrix-ii/description/ * * algorithms * Medium (71.30%) * Likes: 1271 * Dislikes: 0 * Total Accepted: 407.8K * Total Submissions: 573.1K * Testcase Example: \u0026#39;3\u0026#39; * * 给你一个正整数 n ，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 * * * * 示例 1： * * * 输入：n = 3 * 输出：[[1,2,3],[8,9,4],[7,6,5]] * * * 示例 2： * * * 输入：n = 1 * 输出：[[1]] * * * * * 提示： * * * 1 * * * 思路：初始化一个n*n的矩阵matrix，然后模拟整个由内向外螺旋填入数字的过程： * 1.定义当前左右上下边界l,r,t,b。 * 计数赋值的初始值num=1,迭代终止值为 target = n*n; * 2.当num \u0026lt; target时，始终按照从左到右，从上到下，从右到左，从下到上填入顺序循环， * 每次填入后执行： * i.执行num +=1 ,即得到下一个待填入数值 * ii.更新边界, 每次循环前都需向内收缩，避免重复：例如从左到右填入后，上边界需要 t+=1，相当于上边界向内缩1 * 3.使用 num \u0026lt; target, 而不是l\u0026lt;r||t\u0026lt;b作为迭代条件，是为解决当n为奇数时， * 矩阵中心数字无法在迭代过程中被填充的问题。 * 4.最终返回matrix即可。 * * * */ // @lc code=start class Solution { public int[][] generateMatrix(int n) { int [][] matrix = new int[n][n]; int left =0, right = n-1, top = 0, bottom = n-1; int target = n * n, num = 1; while (num \u0026lt;= target ) { //从左到右遍历，行不变为t for(int l = left; l \u0026lt;=right; l++){ matrix[top][l] = num++; } //准备进入下一次循环，从上到下遍历，所以t加一， top++; //列不变为r for(int t = top; t\u0026lt;=bottom; t++){ matrix[t][right] = num++; } //准备下次循环，所以从右到左遍历，所以r减一， right--; //行不变为b for(int r = right; r\u0026gt;=left;r--){ matrix[bottom][r] = num++; } //准备进入下一次循环，从下到上遍历，所以b减一 bottom--; //列不变为l for(int b = bottom; b\u0026gt;=top; b--){ matrix[b][left] = num++; } //准备进入下一次循环，从左到右遍历，所以l加一 left++; } return matrix; } } // @lc code=end ","date":"2024-03-26T00:00:00Z","image":"https://kris0325.github.io/p/59.-spiral-matrix-ii/59_hu5477be140e37c38e9e48439fae2f6b6b_6958036_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/59.-spiral-matrix-ii/","title":"59. Spiral Matrix II"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 /* * @lc app=leetcode.cn id=209 lang=java * * [209] 长度最小的子数组 * * https://leetcode.cn/problems/minimum-size-subarray-sum/description/ * * algorithms * Medium (46.41%) * Likes: 2088 * Dislikes: 0 * Total Accepted: 727.9K * Total Submissions: 1.6M * Testcase Example: \u0026#39;7\\n[2,3,1,2,4,3]\u0026#39; * * 给定一个含有 n 个正整数的数组和一个正整数 target 。 * * 找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] * ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 * * * * 示例 1： * * * 输入：target = 7, nums = [2,3,1,2,4,3] * 输出：2 * 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 * * * 示例 2： * * * 输入：target = 4, nums = [1,4,4] * 输出：1 * * * 示例 3： * * * 输入：target = 11, nums = [1,1,1,1,1,1,1,1] * 输出：0 * * * * * 提示： * * * 1 \u0026lt;= target \u0026lt;= 10^9 * 1 \u0026lt;= nums.length \u0026lt;= 10^5 * 1 \u0026lt;= nums[i] \u0026lt;= 10^5 * * * * * 进阶： * * * 如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。 * * * * 思路：滑动窗口 * 快慢指针移动形成滑动窗口，进行判断窗口值之和是否满足条件，再通过快慢指针移动推动滑动窗口 */ // @lc code=start class Solution { public int minSubArrayLen(int target, int[] nums) { int reslut = Integer.MAX_VALUE; //滑动窗口数组值之和 int sum = 0; //左边慢指针即滑动窗口起始位置 int slow = 0; //滑动窗口的长度 int subLength =0; //右边快指针即滑动窗口结束位置 for(int fast = 0; fast \u0026lt; nums.length;fast++){ sum += nums[fast]; //当每次循环判断滑动窗口的截断出的数组值之和sum满足条件时， 进行比较并更新滑动窗口长度 subLength， //然后下一次循环，先更新sum，后更新向右移动慢指针， while (sum \u0026gt;= target) { subLength = fast -slow + 1; reslut = Math.min(reslut, subLength ); // sum -= nums[slow++]; //sum -= nums[slow++];注意顺序，即： sum -= nums[slow]; slow ++; } } return reslut == Integer.MAX_VALUE? 0 : reslut; } } // @lc code=end ","date":"2024-03-25T00:00:00Z","image":"https://kris0325.github.io/p/209.-minimum-size-subarray-sum/209_hu5477be140e37c38e9e48439fae2f6b6b_7955808_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/209.-minimum-size-subarray-sum/","title":"209. Minimum Size Subarray Sum"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 /* * @lc app=leetcode.cn id=977 lang=java * * [977] 有序数组的平方 * * https://leetcode.cn/problems/squares-of-a-sorted-array/description/ * * algorithms * Easy (67.88%) * Likes: 973 * Dislikes: 0 * Total Accepted: 653.4K * Total Submissions: 962.3K * Testcase Example: \u0026#39;[-4,-1,0,3,10]\u0026#39; * * 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 * * * * * * * 示例 1： * * * 输入：nums = [-4,-1,0,3,10] * 输出：[0,1,9,16,100] * 解释：平方后，数组变为 [16,1,0,9,100] * 排序后，数组变为 [0,1,9,16,100] * * 示例 2： * * * 输入：nums = [-7,-3,2,3,11] * 输出：[4,9,9,49,121] * * * * * 提示： * * * 1 10^4 * -10^4 * nums 已按 非递减顺序 排序 * * * * * 进阶： * * * 请你设计时间复杂度为 O(n) 的算法解决本问题 * * 思路： * 相像双指针， * 1.对原数组元素进行平方，同时新建一个数组用于存放结果值 * 2.左指针与右指针对应的元素比较大小，将较大值放入新数组的末尾， * （即每次将比较后较大值放入新数组的末尾并移动新数组下标） * 3.同时将较大值对应的指针向中间方向移动，直到到两个指针相遇 */ // @lc code=start class Solution { public int[] sortedSquares(int[] nums) { int [] reslut = new int[nums.length]; int left = 0; int right = nums.length -1; int index = nums.length -1; //square for(int i =0; i\u0026lt;= right;i++ ){ nums[i] = nums[i] * nums[i]; } //左右相向双指针，比较对应元素大小 while (left \u0026lt;= right) { if (nums[left] \u0026lt;= nums[right]) { reslut[index--] =nums[right]; right--; } else if(nums[left] \u0026gt; nums[right]){ reslut[index--] =nums[left]; left++; } } return reslut; } } // @lc code=end ","date":"2024-03-25T00:00:00Z","image":"https://kris0325.github.io/p/977.-squares-of-a-sorted-array/977_hu5477be140e37c38e9e48439fae2f6b6b_10703687_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/977.-squares-of-a-sorted-array/","title":"977. Squares of a Sorted Array"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 /* * @lc app=leetcode.cn id=27 lang=java * * [27] 移除元素 * * https://leetcode.cn/problems/remove-element/description/ * * algorithms * Easy (59.34%) * Likes: 2181 * Dislikes: 0 * Total Accepted: 1.4M * Total Submissions: 2.4M * Testcase Example: \u0026#39;[3,2,2,3]\\n3\u0026#39; * * 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 * * 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 * * 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 * * * * 说明: * * 为什么返回数值是整数，但输出的答案是数组呢? * * 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 * * 你可以想象内部操作如下: * * * // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 * int len = removeElement(nums, val); * * // 在函数里修改输入数组对于调用者是可见的。 * // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 * for (int i = 0; i \u0026lt; len; i++) { * print(nums[i]); * } * * * * * 示例 1： * * * 输入：nums = [3,2,2,3], val = 3 * 输出：2, nums = [2,2] * 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 * nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 * * * 示例 2： * * * 输入：nums = [0,1,2,2,3,0,4,2], val = 2 * 输出：5, nums = [0,1,3,0,4] * 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, * 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 * * * * * 提示： * * * 0 \u0026lt;= nums.length \u0026lt;= 100 * 0 \u0026lt;= nums[i] \u0026lt;= 50 * 0 \u0026lt;= val \u0026lt;= 100 * * 思路：in-palce原地移出数组元素， * 方法1.考虑使用相向双指针 * 方法2.考虑使用快慢双指针 */ // @lc code=start class Solution11 { public int removeElement(int[] nums, int val) { int left = 0; int right =nums.length -1; int tmp = 0; while (left \u0026lt;= right) { if(nums[left] == val){ tmp = nums[left]; nums[left] = nums[right]; nums[right] = tmp; right--; } else { left++; } } return left; } } class Solution12 { public int removeElement(int[] nums, int val) { int left = 0; int right =nums.length -1; // int tmp = 0; while (left \u0026lt;= right) { if(nums[left] == val){ // tmp = nums[left]; //直接用右边的值覆盖左边的值 nums[left] = nums[right]; // nums[right] = tmp; right--; } else { left++; } } return left; } } class Solution { public int removeElement(int[] nums, int val) { //快指针: 寻找新数组的元素，新数组就是不含有目标元素的数组，所以一直先右移动，遇到相同元素时，继续走； // 遇到不同元素时， 交换快慢指针对应数组的元素，从而实现将新元素向左移动 //慢指针: 用于收集新元素，指向更新 新数组下标的位置，所以遇到相同元素时，不移动； // 遇到不同元素时右移一步 int slowPointer = 0; for(int fastPointer = 0; fastPointer\u0026lt; nums.length; fastPointer++){ if(nums[fastPointer] != val){ nums[slowPointer] = nums[fastPointer]; slowPointer++; } } return slowPointer; } } // @lc code=end ","date":"2024-03-23T00:00:00Z","image":"https://kris0325.github.io/p/27.-remove-element/27_hu5477be140e37c38e9e48439fae2f6b6b_9247318_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/27.-remove-element/","title":"27. Remove Element"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 /* * @lc app=leetcode.cn id=704 lang=java * * [704] 二分查找 * * https://leetcode.cn/problems/binary-search/description/ * * algorithms * Easy (55.14%) * Likes: 1551 * Dislikes: 0 * Total Accepted: 1.2M * Total Submissions: 2.2M * Testcase Example: \u0026#39;[-1,0,3,5,9,12]\\n9\u0026#39; * * 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 * target，如果目标值存在返回下标，否则返回 -1。 * * * 示例 1: * * 输入: nums = [-1,0,3,5,9,12], target = 9 * 输出: 4 * 解释: 9 出现在 nums 中并且下标为 4 * * * 示例 2: * * 输入: nums = [-1,0,3,5,9,12], target = 2 * 输出: -1 * 解释: 2 不存在 nums 中因此返回 -1 * * * * * 提示： * * * 你可以假设 nums 中的所有元素是不重复的。 * n 将在 [1, 10000]之间。 * nums 的每个元素都将在 [-9999, 9999]之间。 * * 思路：排序数组找target，可以使用单指针进行二分搜索 */ // @lc code=start class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.length -1; while (left \u0026lt;= right) { int middle = left + (right -left)/2; //target在左区间 if(target \u0026lt; nums[middle]){ //middle指针下标需要向左边移动时，避免2个元素数组的case下标不移动，所以需要-1 right = middle -1; } else if(target \u0026gt; nums[middle]){ //target在右区间 //同理，middle指针向右移动时，下标需要+1， left = middle +1; } else{ return middle; } } return -1; } } // @lc code=end ","date":"2024-03-23T00:00:00Z","image":"https://kris0325.github.io/p/704.-binary-search/704_hu5477be140e37c38e9e48439fae2f6b6b_6288324_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/704.-binary-search/","title":"704. Binary Search"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 /* * @lc app=leetcode.cn id=509 lang=java * * [509] 斐波那契数 * * https://leetcode.cn/problems/fibonacci-number/description/ * * algorithms * Easy (65.98%) * Likes: 745 * Dislikes: 0 * Total Accepted: 674.9K * Total Submissions: 1M * Testcase Example: \u0026#39;2\u0026#39; * * 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： * * * F(0) = 0，F(1) = 1 * F(n) = F(n - 1) + F(n - 2)，其中 n \u0026gt; 1 * * * 给定 n ，请计算 F(n) 。 * * * * 示例 1： * * * 输入：n = 2 * 输出：1 * 解释：F(2) = F(1) + F(0) = 1 + 0 = 1 * * * 示例 2： * * * 输入：n = 3 * 输出：2 * 解释：F(3) = F(2) + F(1) = 1 + 1 = 2 * * * 示例 3： * * * 输入：n = 4 * 输出：3 * 解释：F(4) = F(3) + F(2) = 2 + 1 = 3 * * * * * 提示： * * * 0 \u0026lt;= n \u0026lt;= 30 * * * 思路：动态规划， * 1.定义dp数组 * 2.初始化dp数组的初始值， * 3.写出递推公式 * 4.选择递推顺序 * 5.打印递推数组 * * 注意：n\u0026lt;2的边界条件需要额外处理 */ // @lc code=start class Solution { public int fib(int n) { //注意处理边界条件 if(n\u0026lt;2) return n; int[] fib = new int[n+1]; fib[0]= 0; fib[1]= 1; for(int i =2; i \u0026lt;=n ;i++){ fib[i] = fib[i-1]+fib[i-2]; // System.out.println(\u0026#34;fib[n]:\u0026#34;+fib[n]); } return fib[n]; } } // @lc code=end ","date":"2024-03-22T00:00:00Z","image":"https://kris0325.github.io/p/509.-fibonacci-number/509_hu5477be140e37c38e9e48439fae2f6b6b_9999474_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/509.-fibonacci-number/","title":"509. Fibonacci Number"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 /* * @lc app=leetcode.cn id=70 lang=java * * [70] 爬楼梯 * * https://leetcode.cn/problems/climbing-stairs/description/ * * algorithms * Easy (54.41%) * Likes: 3474 * Dislikes: 0 * Total Accepted: 1.4M * Total Submissions: 2.6M * Testcase Example: \u0026#39;2\u0026#39; * * 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 * * 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ * * * * 示例 1： * * * 输入：n = 2 * 输出：2 * 解释：有两种方法可以爬到楼顶。 * 1. 1 阶 + 1 阶 * 2. 2 阶 * * 示例 2： * * * 输入：n = 3 * 输出：3 * 解释：有三种方法可以爬到楼顶。 * 1. 1 阶 + 1 阶 + 1 阶 * 2. 1 阶 + 2 阶 * 3. 2 阶 + 1 阶 * * * * * 提示： * * * 1 \u0026lt;= n \u0026lt;= 45 * * */ // @lc code=start class Solution { public int climbStairs(int n) { if(n\u0026lt;=2){ return n; } int []dp = new int[n +1]; dp[1]= 1; dp[2]= 2; //注意下标index开始于i=3 for(int i =3; i\u0026lt;=n; i++){ dp[i] = dp[i-2] +dp[i-1]; // System.out.println(\u0026#34;dp[i]\u0026#34;+ \u0026#34;i:\u0026#34;+ i+\u0026#34;:\u0026#34;+dp[i]); } return dp[n]; } } // @lc code=end ","date":"2024-03-22T00:00:00Z","image":"https://kris0325.github.io/p/70.-climbing-stairs/70_hu5477be140e37c38e9e48439fae2f6b6b_10700263_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/70.-climbing-stairs/","title":"70. Climbing Stairs"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 /* * @lc app=leetcode.cn id=746 lang=java * * [746] 使用最小花费爬楼梯 * * https://leetcode.cn/problems/min-cost-climbing-stairs/description/ * * algorithms * Easy (66.29%) * Likes: 1455 * Dislikes: 0 * Total Accepted: 416K * Total Submissions: 626.5K * Testcase Example: \u0026#39;[10,15,20]\u0026#39; * * 给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。 * * 你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。 * * 请你计算并返回达到楼梯顶部的最低花费。 * * * * 示例 1： * * * 输入：cost = [10,15,20] * 输出：15 * 解释：你将从下标为 1 的台阶开始。 * - 支付 15 ，向上爬两个台阶，到达楼梯顶部。 * 总花费为 15 。 * * * 示例 2： * * * 输入：cost = [1,100,1,1,1,100,1,1,100,1] * 输出：6 * 解释：你将从下标为 0 的台阶开始。 * - 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。 * - 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。 * - 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。 * - 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。 * - 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。 * - 支付 1 ，向上爬一个台阶，到达楼梯顶部。 * 总花费为 6 。 * * * * * 提示： * * * 2 \u0026lt;= cost.length \u0026lt;= 1000 * 0 \u0026lt;= cost[i] \u0026lt;= 999 * * * * 思路：动态规划， * 先1.定义dp数组 * 2.初始化dp数组的初始值， * 3.写出递推公式 * 4.选择递推顺序 * 5.打印递推数组 */ // @lc code=start class Solution { public int minCostClimbingStairs(int[] cost) { //定义dp数组 int[] dp = new int [cost.length +1]; //初始化dp初始值，可以下标为0或1的台阶开始，因此初始值均为0 dp[0]= 0; dp[1]= 0; //1.写出递推公式dp[i] = Math.min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2]); //2.选择递推顺序，进行循环递推求解 for(int i = 2; i\u0026lt;= cost.length; i++){ dp[i] = Math.min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2]); //打印递推值 // System.out.println(dp[i]); } return dp[cost.length]; } } // @lc code=end ","date":"2024-03-22T00:00:00Z","image":"https://kris0325.github.io/p/746.-min-cost-climbing-stairs/746_hu3d8040dde552413e254984f4d0fd0a1d_11887603_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/746.-min-cost-climbing-stairs/","title":"746. Min Cost Climbing Stairs"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 /* * @lc app=leetcode id=784 lang=java * * [784] Letter Case Permutation * * https://leetcode.com/problems/letter-case-permutation/description/ * * algorithms * Medium (74.08%) * Likes: 4588 * Dislikes: 154 * Total Accepted: 294.9K * Total Submissions: 397.8K * Testcase Example: \u0026#39;\u0026#34;a1b2\u0026#34;\u0026#39; * * Given a string s, you can transform every letter individually to be * lowercase or uppercase to create another string. * * Return a list of all possible strings we could create. Return the output in * any order. * * * Example 1: * * * Input: s = \u0026#34;a1b2\u0026#34; * Output: [\u0026#34;a1b2\u0026#34;,\u0026#34;a1B2\u0026#34;,\u0026#34;A1b2\u0026#34;,\u0026#34;A1B2\u0026#34;] * * * Example 2: * * * Input: s = \u0026#34;3z4\u0026#34; * Output: [\u0026#34;3z4\u0026#34;,\u0026#34;3Z4\u0026#34;] * * * * Constraints: * * * 1 \u0026lt;= s.length \u0026lt;= 12 * s consists of lowercase English letters, uppercase English letters, and * digits. * * * \u0026gt;思路分析： 这一类搜索问题是在一个隐式的树上进行的搜索问题，即「树形问题」。解决这一类问题， 先画出递归树是十分重要的，可以帮助打开思路 ，然后看着图形把代码写出来； 这个问题所求的解，是这棵树的叶子结点上的值。因此，可以使用深度优先遍历，收集 所有 叶子结点的值，深度优先遍历用于搜索也叫回溯算法； 回溯算法因为有回头的过程，因此其显著特征是 状态重置。回溯算法的入门问题是「力扣」第 46 题：全排列）。 由于集合元素字母只有大写，小写之分，那么结果树为二叉树，所以不需要用for循环去遍历集合元素 大小写转换： 我们发现大写字符与其对应的小写字符的 ASCII 的差为 32，32 这个值如果敏感的话，它是 2^5 ，在编程语言中，可以表示为 1 \u0026lt;\u0026lt; 5。而 变换大小写这件事等价于： 如果字符是小写字符，减去 32 得到大写字符； 如果字符是大写字符，加上 32 得到小写字符。 而这两者合并起来，就是给这个字符做一次不进位的加法，即异或上 1 \u0026lt;\u0026lt; 5。 */ // @lc code=start import java.util.ArrayList; class Solution { public List\u0026lt;String\u0026gt; letterCasePermutation(String s) { List\u0026lt;String\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); char[]charArray = s.toCharArray(); backTrack(charArray,0,result); return result; } public void backTrack(char[]charArray, Integer index,List\u0026lt;String\u0026gt; result ){ if(charArray.length == index){ result.add(new String(charArray)); return; } backTrack(charArray, index+1, result); if(Character.isLetter(charArray[index])){ /* 大小寫轉換 注意：char[]charArray 是基本数据类型，所以是值传递，即传递的是副本 ，所以数组中的某个元素进行大小写转换后，并不会影响原始数组的值， 实际上每一层是由系统调用栈保存的，那么就不用再写额外的常规的“状态重置”操作 **/ charArray[index] ^= 1\u0026lt;\u0026lt;5; backTrack(charArray, index+1,result); } } } // @lc code=end ","date":"2024-03-06T00:00:00Z","image":"https://kris0325.github.io/p/784.letter-case-permutation/784_hu606ca62585253a2e41ef4f76e0603ca2_5079664_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/784.letter-case-permutation/","title":"784.Letter Case Permutation"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 /* * @lc app=leetcode id=46 lang=java * * [46] Permutations * * https://leetcode.com/problems/permutations/description/ * * algorithms * Medium (77.71%) * Likes: 18602 * Dislikes: 313 * Total Accepted: 2M * Total Submissions: 2.5M * Testcase Example: \u0026#39;[1,2,3]\u0026#39; * * Given an array nums of distinct integers, return all the possible * permutations. You can return the answer in any order. * * * Example 1: * Input: nums = [1,2,3] * Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] * Example 2: * Input: nums = [0,1] * Output: [[0,1],[1,0]] * Example 3: * Input: nums = [1] * Output: [[1]] * * * Constraints: * * * 1 \u0026lt;= nums.length \u0026lt;= 6 * -10 \u0026lt;= nums[i] \u0026lt;= 10 * All the integers of nums are unique. * * */ // @lc code=start import java.util.ArrayList; import java.util.List; class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); backTrack(nums, path); return result; } public void backTrack(int[] nums, List\u0026lt;Integer\u0026gt; path){ if(nums.length == path.size()){ result.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } for(int i = 0 ; i \u0026lt; nums.length; i++){ if(!path.contains(nums[i])){ path.add(nums[i]); backTrack(nums, path); path.removeLast(); } } } } // class Solution { // List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); // public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { // List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); // int len = nums.length; // boolean [] used = new boolean[len]; // backTrack(nums, path, used); // return result; // } // public void backTrack(int[] nums, // List\u0026lt;Integer\u0026gt; path,boolean [] used ){ // if(nums.length == path.size()){ // result.add(new ArrayList\u0026lt;\u0026gt;(path)); // return; // } // for(int i = 0 ; i \u0026lt; nums.length; i++){ // if(!used[i]){ // path.add(nums[i]); // used[i] = true; // backTrack(nums, path, used); // used[i] = false; // path.removeLast(); // } // } // } // } // class Main { // public static void main(String[] args) { // // Create a new Solution instance // Solution solution = new Solution(); // // Create a test case // int[] nums = {1, 2, 3}; // // Get the answer // boolean answer = solution.permute(nums); // // Print the answer // System.out.println(answer); // } // } // @lc code=end ","date":"2024-03-05T00:00:00Z","image":"https://kris0325.github.io/p/46.permutations/46_hu53d701c2791f7bf43c897940a94a4d78_6016204_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/46.permutations/","title":"46.Permutations"},{"content":" 思路：这个解决方案结合了Permutations和Subsets II的思想。当输入数组中存在重复元素时，我们首先对输入数组进行排序，然后只有在以下情况下选择元素：它是第一个要选择的元素，它与前一个元素不同，或者它与前一个元素相同，但前一个元素也已经被选择。其余的解决方案遵循与没有重复元素的排列相同的逻辑，具有相同的时间和空间复杂度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 /* * @lc app=leetcode id=47 lang=java * * [47] Permutations II * * https://leetcode.com/problems/permutations-ii/description/ * * algorithms * Medium (58.51%) * Likes: 8373 * Dislikes: 139 * Total Accepted: 893.1K * Total Submissions: 1.5M * Testcase Example: \u0026#39;[1,1,2]\u0026#39; * Given a collection of numbers, nums, that might contain duplicates, return * all possible unique permutations in any order. * * * Example 1: * * * Input: nums = [1,1,2] * Output: * [[1,1,2], * ⁠[1,2,1], * ⁠[2,1,1]] * * * Example 2: * * * Input: nums = [1,2,3] * Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] * * * * Constraints: * * * 1 \u0026lt;= nums.length \u0026lt;= 8 * -10 \u0026lt;= nums[i] \u0026lt;= 10 * * */ // @lc code=start import java.util.Arrays; class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permuteUnique(int[] nums) { List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); int len = nums.length; Arrays.sort(nums); boolean [] used = new boolean[len]; backTrack(nums, path, used); return result; } public void backTrack(int[] nums, List\u0026lt;Integer\u0026gt; path,boolean [] used ){ if(nums.length == path.size()){ result.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } for(int i = 0 ; i \u0026lt; nums.length; i++){ //然后只有在以下情况下选择元素：它沒被選擇過。它是第一个要选择的元素，它与前一个元素不同，或者它与前一个元素相同，但前一个元素也已经被选择。 if(!used[i] \u0026amp;\u0026amp; (i==0 || nums[i] != nums[i-1] || used[i-1])){ path.add(nums[i]); used[i] = true; backTrack(nums, path, used); used[i] = false; path.removeLast(); } } } } // class Solution2 { // List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); // public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permuteUnique(int[] nums) { // List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); // int len = nums.length; // boolean [] used = new boolean[len]; // backTrack(nums, path, used); // List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; deduped = result.stream() // .distinct() // .toList(); // return deduped; // } // public void backTrack(int[] nums, // List\u0026lt;Integer\u0026gt; path,boolean [] used ){ // if(nums.length == path.size()){ // result.add(new ArrayList\u0026lt;\u0026gt;(path)); // return; // } // for(int i = 0 ; i \u0026lt; nums.length; i++){ // if(!used[i]){ // path.add(nums[i]); // used[i] = true; // backTrack(nums, path, used); // used[i] = false; // path.removeLast(); // } // } // } // } // @lc code=end ","date":"2024-03-05T00:00:00Z","image":"https://kris0325.github.io/p/47.permutations-ii/47_hu5477be140e37c38e9e48439fae2f6b6b_9032782_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/47.permutations-ii/","title":"47.Permutations-ii"},{"content":"時隔四年，故地重游。\n到達東京成田國際機場後，直奔國立西洋藝術博物館，幸運的事趕在閉館的前一天看到了豐富的藏品 博物館的創建者松方幸次郎先生的畫像。松方先生慷慨地捐贈了大量藝術藏品給博物館 為能登半島募捐 逛完博物館出來，夜幕降臨，皓月當空 ","date":"2024-03-05T00:00:00Z","image":"https://kris0325.github.io/p/%E6%95%85%E5%9C%B0%E9%87%8D%E6%B8%B8/The%20National%20Museum%20of%20Western%20Art_hu209af62a5c347621b358fca369c6201f_4823951_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/%E6%95%85%E5%9C%B0%E9%87%8D%E6%B8%B8/","title":"故地重游"},{"content":"/*\n@lc app=leetcode id=216 lang=java [216] Combination Sum III https://leetcode.com/problems/combination-sum-iii/description/ algorithms Medium (69.07%) Likes: 5799 Dislikes: 107 Total Accepted: 485.5K Total Submissions: 700.5K Testcase Example: \u0026lsquo;3\\n7\u0026rsquo; Find all valid combinations of k numbers that sum up to n such that the following conditions are true: Only numbers 1 through 9 are used. Each number is used at most once. Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order. Example 1: Input: k = 3, n = 7 Output: [[1,2,4]] Explanation: 1 + 2 + 4 = 7 There are no other valid combinations. Example 2: Input: k = 3, n = 9 Output: [[1,2,6],[1,3,5],[2,3,4]] Explanation: 1 + 2 + 6 = 9 1 + 3 + 5 = 9 2 + 3 + 4 = 9 There are no other valid combinations. Example 3: Input: k = 4, n = 1 Output: [] Explanation: There are no valid combinations. Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 \u0026gt; 1, there are no valid combination. Constraints: 2 \u0026lt;= k \u0026lt;= 9 1 \u0026lt;= n \u0026lt;= 60 */\n思路： 本题就是在[1,2,3,4,5,6,7,8,9]这个集合中找到和为n的k个数的组合。 相对于77. 组合，无非就是多了一个限制，本题是要找到和为n的k个数的组合，而整个集合已经是固定的了[1,\u0026hellip;,9]。 想到这一点了，做过77. 组合之后，本题是简单一些了。 本题k相当于树的深度，9（因为整个集合就是9个数）就是树的宽度。 例如 k = 2，n = 4的话，就是在集合[1,2,3,4,5,6,7,8,9]中求 k（个数） = 2, n（和） = 4的组合。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // @lc code=start import java.util.ArrayList; import java.util.LinkedList; import java.util.ArrayList; import java.util.LinkedList; class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); LinkedList\u0026lt;Integer\u0026gt; path = new LinkedList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum3(int k, int n) { backTrack( n , k,1,0 ); return result; } public void backTrack(Integer sumTarget, int k, int begin, int sum ){ //剪枝 if(sum \u0026gt; sumTarget){ return; } if(path.size() == k \u0026amp;\u0026amp; sum == sumTarget ){ result.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } //剪枝 i \u0026lt;= 9 - (k -path.size()) +1 for(int i = begin; i \u0026lt;= 9 - (k -path.size()) +1 ; i++){ path.add(i); sum += i; backTrack(sumTarget,k, i+1, sum); path.removeLast(); sum -= i; } } } // @lc code=end ","date":"2024-02-27T00:00:00Z","image":"https://kris0325.github.io/p/216.combination-sum-iii/216_huee336b0bcb2a7652cd11fea2dee339d9_1429265_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/216.combination-sum-iii/","title":"216.Combination Sum III"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 /* * @lc app=leetcode id=17 lang=java * * [17] Letter Combinations of a Phone Number */ // @lc code=start import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; /* * DFS 深度优先搜素算法 */ // class Solution { // public List\u0026lt;String\u0026gt; letterCombinations(String digits) { // // List\u0026lt;String\u0026gt; phoneNum2String = new ArrayList\u0026lt;String\u0026gt;(Arrays.asList(\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;abc\u0026#34;,\u0026#34;def\u0026#34;,\u0026#34;ghi\u0026#34;,\u0026#34;jkl\u0026#34;,\u0026#34;mno\u0026#34;,\u0026#34;pqrs\u0026#34;,\u0026#34;tuv\u0026#34;,\u0026#34;wxyz\u0026#34;)); // //使用hashMap 可应对异常边界条件，比如输入0,1或者非数字 // Map\u0026lt;Character,String\u0026gt; phoneNum2String = new HashMap\u0026lt;\u0026gt;(){{ // put(\u0026#39;0\u0026#39;, \u0026#34;\u0026#34;); // put(\u0026#39;1\u0026#39;, \u0026#34;\u0026#34;); // put(\u0026#39;2\u0026#39;, \u0026#34;abc\u0026#34;); // put(\u0026#39;3\u0026#39;, \u0026#34;def\u0026#34;); // put(\u0026#39;4\u0026#39;, \u0026#34;ghi\u0026#34;); // put(\u0026#39;5\u0026#39;, \u0026#34;jkl\u0026#34;); // put(\u0026#39;6\u0026#39;, \u0026#34;mno\u0026#34;); // put(\u0026#39;7\u0026#39;, \u0026#34;pqrs\u0026#34;); // put(\u0026#39;8\u0026#39;, \u0026#34;tuv\u0026#34;); // put(\u0026#39;9\u0026#39;, \u0026#34;wxyz\u0026#34;); // }}; // List\u0026lt;String\u0026gt; combinations = new ArrayList\u0026lt;\u0026gt;(); // int index = 0; // //存当前字符串 // StringBuffer current = new StringBuffer(); // //算法：DFS深度优先搜索 / 回溯 实现搜索， // findCombinationsBacktrack(phoneNum2String,combinations,0,digits,current); // return combinations; // } // public void findCombinationsBacktrack(Map\u0026lt;Character,String\u0026gt; phoneNum2String, List\u0026lt;String\u0026gt; combinations ,int index, String digits,StringBuffer current){ // if(index == digits.length()){ // if(index == 0){ // return; // } // combinations.add(current.toString()); // return; // } // String alphaString = phoneNum2String.get(digits.charAt(index)); // for(int i = 0; i\u0026lt;alphaString.length();i++){ // current.append(alphaString.charAt(i)); // findCombinationsBacktrack(phoneNum2String,combinations,index+1,digits,current); // current.deleteCharAt(index); // } // } // } /* * BFS 广度优先搜素算法 */ class Solution { public List\u0026lt;String\u0026gt; letterCombinationsBSF(String digits) { if (digits.length() == 0) return new ArrayList\u0026lt;String\u0026gt;(); String[] d = new String[]{\u0026#34; \u0026#34;, \u0026#34;\u0026#34;, \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;, \u0026#34;wxyz\u0026#34;}; List\u0026lt;String\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); ans.add(\u0026#34;\u0026#34;); for (char digit : digits.toCharArray()) { List\u0026lt;String\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); for (String t : ans) { String s = d[Character.getNumericValue(digit)]; for (int i = 0; i \u0026lt; s.length(); ++i) tmp.add(t + s.charAt(i)); } ans = tmp; } return ans; } } /* * debug */ class Main{ public static void main(String[] args) { // Create a new Solution instance Solution solution = new Solution(); // Create a test case String testCase = \u0026#34;23\u0026#34;; // Get the answer List\u0026lt;String\u0026gt; result = solution.letterCombinationsBSF(testCase); // Print the answer System.out.println(result); } } // @lc code=end ","date":"2024-01-25T00:00:00Z","image":"https://kris0325.github.io/p/17.letter-combinations-of-a-phone-number/17_hua62bcbcf9a79dfe26d0875c8d67438b3_4738208_120x120_fill_box_smart1_3.png","permalink":"https://kris0325.github.io/p/17.letter-combinations-of-a-phone-number/","title":"17.letter-combinations-of-a-phone-number"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 /* * @lc app=leetcode id=39 lang=java * * [39] Combination Sum * * https://leetcode.com/problems/combination-sum/description/ * * algorithms * Medium (70.32%) * Likes: 17899 * Dislikes: 367 * Total Accepted: 1.7M * Total Submissions: 2.4M * Testcase Example: \u0026#39;[2,3,6,7]\\n7\u0026#39; * * Given an array of distinct integers candidates and a target integer target, * return a list of all unique combinations of candidates where the chosen * numbers sum to target. You may return the combinations in any order. * * The same number may be chosen from candidates an unlimited number of times. * Two combinations are unique if the frequency of at least one of the chosen * numbers is different. * * The test cases are generated such that the number of unique combinations * that sum up to target is less than 150 combinations for the given input. * * * Example 1: * * * Input: candidates = [2,3,6,7], target = 7 * Output: [[2,2,3],[7]] * Explanation: * 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple * times. * 7 is a candidate, and 7 = 7. * These are the only two combinations. * * * Example 2: * * * Input: candidates = [2,3,5], target = 8 * Output: [[2,2,2,2],[2,3,3],[3,5]] * * * Example 3: * * * Input: candidates = [2], target = 1 * Output: [] * * * * Constraints: * * * 1 \u0026lt;= candidates.length \u0026lt;= 30 * 2 \u0026lt;= candidates[i] \u0026lt;= 40 * All elements of candidates are distinct. * 1 \u0026lt;= target \u0026lt;= 40 * * * * @param candidates 候选数组 * @param begin 搜索起点 * @param len 冗余变量，是 candidates 里的属性，可以不传 * @param target 每减去一个元素，目标值变小 * @param cur 从根结点到叶子结点的路径，是一个栈 * @param res 结果集列表 参考链接：https://leetcode.cn/problems/combination-sum/solutions/14697/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/ * * 对于所有搜素可行解类型的问题，都可以尝试 “搜索回溯”的方法求解 * solution1 * 深度优先搜索算法 * * * 剪枝提速 根据上面画树形图的经验，如果 target 减去一个数得到负数，那么减去一个更大的树依然是负数，同样搜索不到结果。基于这个想法，我们可以对输入数组进行排序，添加相关逻辑达到进一步剪枝的目的； 排序是为了提高搜索速度，对于解决这个问题来说非必要。但是搜索问题一般复杂度较高，能剪枝就尽量剪枝。实际工作中如果遇到两种方案拿捏不准的情况，都试一下。 * solution2 * 1 先排序，剪枝 * 2 再使用深度优先搜索算法 */ // @lc code=start import java.lang.reflect.Array; import java.util.ArrayList; import java.util.Arrays; import java.util.Deque; class Solution1 { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinations = new ArrayList\u0026lt;\u0026gt;(); int length = candidates.length; Deque\u0026lt;Integer\u0026gt; cur = new ArrayDeque\u0026lt;\u0026gt;(); if(length==0){ return combinations; } dfs(candidates,target,0,length,combinations,cur); return combinations; } public void dfs(int[] candidates, int target, int begin, int length, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinations, Deque\u0026lt;Integer\u0026gt; cur ){ if(target \u0026lt;0){ return; } if(target == 0){ combinations.add(new ArrayList(cur)); return; } // 重点理解这里从 begin 开始搜索的语意 for (int i = begin; i \u0026lt; length; i++){ cur.addLast(candidates[i]); // 注意：由于每一个元素可以重复使用，下一轮搜索的起点依然是 i，而不是i+1，这里非常容易弄错 dfs(candidates,target-candidates[i], i, length,combinations,cur); // 状态重置 cur.removeLast(); } } } class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinations = new ArrayList\u0026lt;\u0026gt;(); int length = candidates.length; // 排序是剪枝的前提 Arrays.sort(candidates); Deque\u0026lt;Integer\u0026gt; cur = new ArrayDeque\u0026lt;\u0026gt;(); if(length==0){ return combinations; } dfs(candidates,target, 0, length,combinations,cur); return combinations; } public void dfs(int[] candidates, int target, int begin, int length, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinations, Deque\u0026lt;Integer\u0026gt; cur ){ // 由于进入更深层的时候，小于 0 的部分被剪枝，因此递归终止条件值只判断等于 0 的情况 if(target == 0){ combinations.add(new ArrayList(cur)); return; } for (int i = begin; i \u0026lt; length; i++){ if(target \u0026lt; candidates[i]) { break; } cur.addLast(candidates[i]); dfs(candidates,target-candidates[i], i, length,combinations,cur); cur.removeLast(); } } } // @lc code=end ","date":"2024-01-25T00:00:00Z","permalink":"https://kris0325.github.io/p/39.combination-sum/","title":"39.combination-sum"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 /* * @lc app=leetcode id=40 lang=java * * [40] Combination Sum II * * https://leetcode.com/problems/combination-sum-ii/description/ * * algorithms * Medium (53.88%) * Likes: 9859 * Dislikes: 261 * Total Accepted: 861.2K * Total Submissions: 1.6M * Testcase Example: \u0026#39;[10,1,2,7,6,1,5]\\n8\u0026#39; * * Given a collection of candidate numbers (candidates) and a target number * (target), find all unique combinations in candidates where the candidate * numbers sum to target. * * Each number in candidates may only be used once in the combination. * * Note: The solution set must not contain duplicate combinations. * * * Example 1: * * * Input: candidates = [10,1,2,7,6,1,5], target = 8 * Output: * [ * [1,1,6], * [1,2,5], * [1,7], * [2,6] * ] * * * Example 2: * * * Input: candidates = [2,5,2,1,2], target = 5 * Output: * [ * [1,2,2], * [5] * ] * * * * Constraints: * * * 1 \u0026lt;= candidates.length \u0026lt;= 100 * 1 \u0026lt;= candidates[i] \u0026lt;= 50 * 1 \u0026lt;= target \u0026lt;= 30 * * * * * solution: * * * @param candidates 候选数组 * @param begin 从候选数组的 begin 位置开始搜索 * @param target 表示剩余，这个值一开始等于 target，基于题目中说明的\u0026#34;所有数字（包括目标数）都是正整数\u0026#34;这个条件 * @param cur 从根结点到叶子结点的路径 * @param combination 最终的所有组合 参考链接：https://leetcode.cn/problems/combination-sum-ii/solutions/14753/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/ * * 深度优先搜素 * 注意去重 * */ // @lc code=start import java.util.ArrayList; import java.util.Arrays; import java.util.List; class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum2(int[] candidates, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combination = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; cur = new ArrayList\u0026lt;\u0026gt;(); if(candidates.length == 0){ return combination; } Arrays.sort(candidates); dfs(candidates, target, 0, combination, cur); return combination; } public void dfs(int[] candidates, int target, int begin,List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combination, List\u0026lt;Integer\u0026gt; cur){ if(target==0){ combination.add(new ArrayList\u0026lt;\u0026gt;(cur)); return; } for(int i = begin; i\u0026lt; candidates.length;i++){ //大剪枝，减去 target比candidates[i]小的 if(target\u0026lt;candidates[i]){ return; } //小剪枝，排序后，同一层，相同元素，会产生重复组合，所以进行跳过去重 if(i\u0026gt;begin \u0026amp;\u0026amp; candidates[i] == candidates[i-1] ){ continue; } cur.add(candidates[i]); //注意元素不能重复使用，所以下一层搜索begin从i+1开始搜索 dfs(candidates,target - candidates[i],i+1,combination,cur); cur.remove(cur.size() -1); } } } // @lc code=end ","date":"2024-01-25T00:00:00Z","permalink":"https://kris0325.github.io/p/40.combination-sum-ii/","title":"40.combination-sum-ii"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 /* * @lc app=leetcode id=77 lang=java * * [77] Combinations * * https://leetcode.com/problems/combinations/description/ * * algorithms * Medium (69.56%) * Likes: 7886 * Dislikes: 206 * Total Accepted: 822.7K * Total Submissions: 1.2M * Testcase Example: \u0026#39;4\\n2\u0026#39; * * Given two integers n and k, return all possible combinations of k numbers * chosen from the range [1, n]. * * You may return the answer in any order. * * * Example 1: * * * Input: n = 4, k = 2 * Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]] * Explanation: There are 4 choose 2 = 6 total combinations. * Note that combinations are unordered, i.e., [1,2] and [2,1] are considered * to be the same combination. * * * Example 2: * * * Input: n = 1, k = 1 * Output: [[1]] * Explanation: There is 1 choose 1 = 1 total combination. * * * * Constraints: * * * 1 \u0026lt;= n \u0026lt;= 20 * 1 \u0026lt;= k \u0026lt;= n * * */ // @lc code=start import java.util.ArrayList; import java.util.List; class Solution1 { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinations = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; cur = new ArrayList\u0026lt;\u0026gt;(); if( k \u0026lt;= 0 || k \u0026gt; n){ return combinations; } dfs(n, k, 1, cur, combinations); return combinations; } public void dfs(int n, int k, int begin, List\u0026lt;Integer\u0026gt; cur, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinations){ if(cur.size() == k){ combinations.add(new ArrayList\u0026lt;\u0026gt;(cur)); return; } for(int i = begin; i \u0026lt;= n; i++){ cur.add(i); dfs(n, k, i+1, cur, combinations); cur.remove(cur.size() - 1); } } } class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinations = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; cur = new ArrayList\u0026lt;\u0026gt;(); if( k \u0026lt;= 0 || k \u0026gt; n){ return combinations; } dfs(n, k, 1, cur, combinations); return combinations; } public void dfs(int n, int k, int begin, List\u0026lt;Integer\u0026gt; cur, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinations){ if(cur.size() == k){ combinations.add(new ArrayList\u0026lt;\u0026gt;(cur)); return; } //剪枝條件，搜索的begin边界需要满足 剩余的元素需要足够多，也就是 k - cur.size() \u0026lt;= n-i +1，否者進行剪枝， for(int i = begin; i \u0026lt;= n - (k - cur.size()) +1; i++){ cur.add(i); dfs(n, k, i+1, cur, combinations); cur.remove(cur.size() - 1); } } } // @lc code=end ","date":"2024-01-25T00:00:00Z","permalink":"https://kris0325.github.io/p/77.combinations/","title":"77.combinations"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 /* * @lc app=leetcode id=78 lang=java * * [78] Subsets * * https://leetcode.com/problems/subsets/description/ * * algorithms * Medium (76.47%) * Likes: 16199 * Dislikes: 243 * Total Accepted: 1.7M * Total Submissions: 2.2M * Testcase Example: \u0026#39;[1,2,3]\u0026#39; * * Given an integer array nums of unique elements, return all possible subsets * (the power set). * * The solution set must not contain duplicate subsets. Return the solution in * any order. * * * Example 1: * * * Input: nums = [1,2,3] * Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] * * * Example 2: * * * Input: nums = [0] * Output: [[],[0]] * * * * Constraints: * * * 1 \u0026lt;= nums.length \u0026lt;= 10 * -10 \u0026lt;= nums[i] \u0026lt;= 10 * All the numbers of nums are unique. * * * * solution： * 问题拆分成 从n个元素的数组中选者k个元素的素全组合, 再收集所有组合即可 */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 // @lc code=start import java.util.ArrayList; /* 其实可以不需要加终止条件，因为startIndex \u0026gt;= nums.size()，本层for循环本来也结束了。 单层搜索逻辑 求取子集问题，不需要任何剪枝！因为子集就是要遍历整棵树。 */ class Solution { //backtracking: subset子集问题： List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { backtracking(nums, 0); return result; } public void backtracking(int nums[], int startIndex) { result.add(new Arraylist\u0026lt;\u0026gt;(path)); /* 可以不需要加终止条件，因为startIndex \u0026gt;= nums.size()，本层for循环本来也结束了。 单层搜索逻辑 求取子集问题，不需要任何剪枝！因为子集就是要遍历整棵树。 */ for (int i = startIndex; i \u0026lt; nums.length; i++) { path.add(nums[i]); backtracking(nums, i + 1); path.removeLast(); } } } // @lc code=end ```java // @lc code=start class Solution1 { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets = new ArrayList\u0026lt;\u0026gt;(); for(int k = 0; k \u0026lt;= nums.length; k++){ dfs(nums, 0, k, new ArrayList\u0026lt;\u0026gt;(),subsets); } return subsets; } public void dfs(int[] nums, int begin, int k, List\u0026lt;Integer\u0026gt; cur , List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets){ if(k == cur.size()){ subsets.add(new ArrayList\u0026lt;\u0026gt;(cur)); return; } //剪枝优化，由i \u0026lt; n 优化为 // 剩余的元素与下标i(begin)的关系必须满足 k - cur.size() \u0026lt; n -i +1 //下标是从begin是从0开始，所以计算上面\u0026lt;不等式右边需要+1 for(int i = begin; i \u0026lt; nums.length -(k - cur.size() -1); i++){ cur.add(nums[i]); dfs(nums, i+1, k, cur, subsets); cur.remove(cur.size()-1); } } } // @lc code=end ","date":"2024-01-25T00:00:00Z","permalink":"https://kris0325.github.io/p/78.subsets/","title":"78.subsets"},{"content":"回溯算法 什么是回溯法 回溯法也可以叫做回溯搜索法，它是一种搜索的方式。\n在二叉树系列中，我们已经不止一次，提到了回溯，例如二叉树：以为使用了递归，其实还隐藏着回溯 (opens new window)。\n回溯是递归的副产品，只要有递归就会有回溯。\n所以以下讲解中，回溯函数也就是递归函数，指的都是一个函数。\n回溯法的效率 回溯法的性能如何呢，这里要和大家说清楚了，虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法。\n因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。\n那么既然回溯法并不高效为什么还要用它呢？\n因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。\n此时大家应该好奇了，都什么问题，这么牛逼，只能暴力搜索。\n回溯法解决的问题 回溯法，一般可以解决如下几种问题：\n组合问题：N个数里面按一定规则找出k个数的集合\n切割问题：一个字符串按一定规则有几种切割方式\n子集问题：一个N个数的集合里有多少符合条件的子集\n排列问题：N个数按一定规则全排列，有几种排列方式\n棋盘问题：N皇后，解数独等等 相信大家看着这些之后会发现，每个问题，都不简单！\n如何理解回溯法 回溯法解决的问题都可以抽象为树形结构，是的，我指的是所有回溯法的问题都可以抽象为树形结构！\n因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度就构成了树的深度。\n递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。\n这块可能初学者还不太理解，后面的回溯算法解决的所有题目中，我都会强调这一点并画图举相应的例子，现在有一个印象就行。\n回溯法模板 这里给出Carl总结的回溯算法模板。\n在讲二叉树的递归 中我们说了递归三部曲，这里我再给大家列出回溯三部曲。\n回溯函数模板返回值以及参数 在回溯算法中，我的习惯是函数起名字为backtracking，这个起名大家随意。\n回溯算法中函数返回值一般为void。\n再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。\n但后面的回溯题目的讲解中，为了方便大家理解，我在一开始就帮大家把参数确定下来。\n回溯函数伪代码如下：\nvoid backtracking(参数) 回溯函数终止条件 既然是树形结构，那么我们在讲解二叉树的递归 (opens new window)的时候，就知道遍历树形结构一定要有终止条件。\n所以回溯也有要终止条件。\n什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。\n所以回溯函数终止条件伪代码如下：\n1 2 3 4 if (终止条件) { 存放结果; return; } 回溯搜索的遍历过程 在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。\n注意图中，我特意举例集合大小和孩子的数量是相等的！\n回溯函数遍历过程伪代码如下：\n1 2 3 4 5 for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。\nbacktracking这里自己调用自己，实现递归。\n大家可以从图中看出for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。\n分析完过程，回溯算法模板框架如下：\n1 2 3 4 5 6 7 8 9 10 11 12 void backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 适用题型：列出所有可能的选择如：组合，切割，部分子集问题，排列，棋盘 e.g. leetcode 17.电话号码组合\n算法模板：\n1 2 3 4 5 6 7 8 9 10 void backstracking(List\u0026lt;Sting\u0026gt; arg1, Integer arg2...){ if(出口的终止条件){ 收集结果； rerun; } for(集合元素){ 处理节点； 调用递归函数backstracking； 回溯操作； } https://www.youtube.com/watch?v=ev5XJ78Fn84\n","date":"2024-01-25T00:00:00Z","image":"https://kris0325.github.io/p/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/backtracking_hu2e5a54eaf2acbac44f9a9ce7d3337f38_346767_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","title":"回溯算法"},{"content":"和許多九十年代出生的人一樣，香港黃金時代的經典電影與流行歌曲一路伴隨我成長，走過夢幻的童年。 那時的香港正處於一個如夢似幻歲月流金的年代，是一座讓人對未來的充滿希望，令人著迷的城市。 於是想著有朝一日，定要去拜訪看看。\n工作後，去過很多地方，不知何時起漸漸覺得，和我所在的城市上海比，香港應該也只是另一座摩登都市，反而沒有很想去探索的慾望。 每次出門旅行，總是傾向去異國遊玩。\n去年因為上海lockdown，讓我們錯過了整個春天。 被奪走的美好的東西，總想著找回來，那時候就再想，解封後一定要出趟遠門，去呼吸那新鮮自由的空氣！ 等過完春節回上海，一切都還未從lockdown中緩過神來，考慮到當時情況，香港便成了可選的首站城市。\n2023年農曆正月初十，初春，咋暖還寒，帶著一路興奮與期待，我們坐上了上海飛往香港的飛機！\n下榻的飯店讓人想起了布達佩斯大飯店 元宵節在飯店旁隨機的選到的一家好吃的茶餐廳 參觀香港故宮博物院，看到了許多明清時期的展品，藉此一窺那個時代人們的生活。\n博物院的展品 街邊的好吃的雞蛋仔 在博物院的露臺上俯瞰維港 趕在黃昏日落前，爬上太平山頂，追到了最後一抹夕陽的柔光，這時山間吹來陣陣涼風，拂去白日的些許悶熱，一切令人舒適鬆弛。\n太平山頂的日落 圓月升起，海風吹拂著五千年的維港 夜幕降临，俯瞰华灯初上的城市 未完待續\u0026hellip;\n","date":"2024-01-24T00:00:00Z","image":"https://kris0325.github.io/p/hong-kong-memories/1_hudef55410758b11b92016a31532bb1813_84464_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/hong-kong-memories/","title":"Hong Kong Memories"},{"content":"如何用 GitHub Pages + Hugo 搭建个人博客 https://cuttontail.blog/blog/create-a-wesite-using-github-pages-and-hugo/#1-%E6%A6%82%E5%BF%B5%E6%90%AD%E5%BB%BA%E6%80%9D%E8%B7%AF%E5%92%8C%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83\nFor more information about this theme, check the documentation: https://stack.jimmycai.com/\nWant a site like this? Check out hugo-theme-stack-stater\n概念，搭建思路和运行环境 1.1 什么是 GitHub Pages？ 1.2 什么是 Hugo？ 1.3 网站搭建思路 1.4 运行环境 安装 Hugo 创建 GitHub 仓库 3.1 创建博客源仓库 3.2 创建 GitHub Page 仓库 克隆博客源仓库到本地 使用 Hugo 创建网站 安装和配置 Hugo 主题 6.1 选择 Hugo 主题 6.2 安装 Hugo 主题 6.3 配置 Hugo 主题 用 Hugo 创建文章 本地调试和预览 发布内容 Reference 1. 概念，搭建思路和运行环境# 1.1 什么是 GitHub Pages？# GitHub Pages 是一组静态网页集合（Static Web Page），这些静态网页由 GitHub 托管（host）和发布，所以是 GitHub + Pages。\n1.2 什么是 Hugo？# Hugo 是用 Go 语言写的静态网站生成器（Static Site Generator）。可以把 Markdown 文件转化成 HTML 文件。\n1.3 网站搭建思路 创建 2 个 GitHub 仓库 博客源仓库：储存所有 Markdown 源文件（博客内容），和博客中用到的图片等。 GitHub Pages 仓库：储存由 Hugo 从Markdown 文件生成的 HTML 文件。 将在博客源仓库中 Hugo 生成的静态 HTML 文件部署到远端 GitHub Pages 仓库中。\n1.4 运行环境 这篇教程假设你已经： 了解基本的终端命令行知识，如：cd, ls 安装了 Git，并且了解基本的 Git 知识 有一个 GitHub账号 有自己偏好的代码编辑器（我使用的是 VS Code）\n2. 安装 Hugo 这里使用包管理器安装 Hugo，我的操作系统是 Mac OS，所以使用 Homebrew 安装 Hugo。如果你使用的是 Windows 或 Linux，可以根据 Hugo 文档提示的方式安装： Hugo 文档：Install Hugo\nbrew install hugo 查看 Hugo 是否安装成功，显示 Hugo 版本号代表 Hugo 安装成功。\nhugo version\n3. 创建 GitHub 仓库 3.1 创建博客源仓库 命名博客源仓库（whatever you want） 勾选 Public，设置为公开仓库。 勾选添加 README 文件\n3.2 创建 GitHub Page 仓库 命名 GitHub Pages 仓库，这个仓库必须使用特殊的命名格式 \u0026lt;username.github.io\u0026gt;， 是自己的 GitHub 的用户名。 勾选 Public，设置为公开仓库。 勾选添加 README 文件，这会设置 main 分支为仓库的默认主分支，这在后面提交推送博客内容时很重要。\n4. 克隆博客源仓库到本地 打开想要在本地储存项目的文件夹（比如我的项目的文件夹是 project ）\ncd project 克隆博客源仓库到项目文件夹，克隆时使用的 HTTPS 仓库链接在这里查看：\ngit clone https://github.com/miawithcode/cuttontail.git\n5. 使用 Hugo 创建网站 进入刚刚克隆下来的博客源仓库文件夹（比如：我的博客源仓库文件夹名是 cuttontail，则cd cuttontail ），在这个文件夹里用 Hugo 创建一个网站文件夹。\n用 Hugo 创建网站文件夹的命令是 hugo new site 网站名字。(比如，我的命名是 cuttontail-blog)\ncd cuttontail hugo new site cuttontail-blog\n用 Hugo 创建的网站共有 7 个文件夹和 1 个文件，这些文件分别代表：\narchetypes：存放用 hugo 命令新建的 Markdown 文件应用的 front matter 模版 content：存放内容页面，比如「博客」、「读书笔记」等 layouts：存放定义网站的样式，写在layouts文件下的样式会覆盖安装的主题中的 layouts文件同名的样式 static：存放所有静态文件，如图片 data：存放创建站点时 Hugo 使用的其他数据 public：存放 Hugo 生成的静态网页 themes：存放主题文件 config.toml：网站配置文件 6.安装和配置 Hugo 主题 6.1 选择 Hugo 主题# 可以从 Hugo 社区提供的主题中选择一个喜欢的主题应用在自己的网站中。\n6.2 安装 Hugo 主题# 一般在你选择的 Hugo 主题的文档中，都会给出「如何安装这个主题」的命令，比如我选用的 Hugo Bear Blog 的文档中给出：\n打开刚刚用 Hugo 创建的网站文件夹（我的是 cuttontail-blog），在终端粘贴文档中给出的安装命令。\n7. 用 Hugo 创建文章 用 Hugo 创建一篇文章的命令是:\nhugo new xxx.md 用这个命令创建的 Markdown 文件会套用 archetypes 文件夹中的 front matter 模版，在空白处用 Markdown 写入内容。\n其中，draft: true代表这篇文章是一个草稿，Hugo 不会显示草稿，要在主页显示添加的文章，可以设置 draft: false；或者直接删掉这行。\n8. 本地调试和预览# 在发布到网站前可以在本地预览网站或内容的效果，运行命令： hugo server\n也可以在本地编辑 Markdown 文件时，通过 hugo server 来实时预览显示效果。 hugo server 运行成功后，可以在 http://localhost:1313/ 中预览网站\n9. 发布内容 hugo 命令可以将你写的 Markdown 文件生成静态 HTML 网页，生成的 HTML 文件默认存放在 public 文件夹中。\nhugo\n因为hugo 生成的静态 HTML 网页文件默认存放在 public 文件中，所以推送网页内容只需要把 public 中的 HTML 网页文件发布到 GitHub Pages 仓库中。\n将 public 文件夹初始化为 Git 仓库，并设置默认主分支名为 main。这么做的原因是：\nGitHub 创建仓库时生成的默认主分支名是 main 用 git init 初始化 Git 仓库时创建的默认主分支名是 master 将 git init 创建的 master 修改成 main ，再推送给远端仓库 .github.io ，这样才不会报错。 cd public git init -b main\n将 public 文件夹关联远程 GitHub Pages 仓库，使用 GitHub Pages 仓库的 SSH 链接。\n（ ⚠️ 注意：要让 SSH 链接起作用，需要你添加过 SSH Key。如果你没有设置过 SSH Key，请参考 如何在 Mac 上为 GitHub 设置 SSH Key）\nGitHub Pages 仓库的 SSH 链接可以在这里查看：\ngit remote add origin git@github.com:miawithcode/miawithcode.github.io.git\n推送博客源仓库的 public 文件夹中的 HTML 网页文件到 GitHub Pages 仓库 中，在推送仓库内容前要先用 git pull \u0026ndash;rebase origin main 和远端仓库同步，否则会报错。\ngit pull \u0026ndash;rebase origin main git add . git commit -m \u0026ldquo;\u0026hellip;(修改的信息)\u0026rdquo; git push origin main\n转到 GitHub 查看 GitHub Pages 仓库中是否存在刚刚推送的文件，存在则代表推送成功。\n如果你没有设置自定义域名，且把 comfig.toml 文件中的 baseURL 设置为 https://.github.io，就可以在 https://username.github.io 中查看刚刚创建的网站。 ( 👀 我使用的是自定义域名，所以这里用我的自定义域名查看。)\n后续的更新步骤：\n创建你的文章xxx.md 用 hugo server 在本地预览，满意后准备发布。 运行 hugo 命令将 Markdown 文件生成 HTML 文件。 将修改先提交至博客源仓库 git add . git commit -m \u0026ldquo;\u0026hellip;(修改的信息)\u0026rdquo; git push 打开 public 文件 运行： git add . git commit -m \u0026ldquo;\u0026hellip;(修改的信息)\u0026rdquo; git pull \u0026ndash;rebase origin main #可选,如果远端仓库与本地一致，则不需要合并。 git push origin main 如果你使用的是自定义域名，第一次推送成功后，GitHub Pages 仓库会生成 CNAME 文件，所以第二次推送还要再合并一次：git pull \u0026ndash;rebase origin main。后续更新博客就不再需要使用这个命令了。（根据实际情况使用） 发布内容除了手动发布，还能使用 GitHub Action 自动发布。但我认为刚刚搭建好一个网站，立刻就用 GitHub Action 有些 Overwhelming，先学会手动发布，熟练之后再开始使用 GitHub Action 自动发布会比较好。\n10. Reference Creating a Blog with Hugo and Github in 10 minutes Hugo + GitHub Action，搭建你的博客自动发布系统 Hugo - Quick Start\n","date":"2024-01-24T00:00:00Z","image":"https://kris0325.github.io/p/hello-world/fall_hu5477be140e37c38e9e48439fae2f6b6b_11160813_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/hello-world/","title":"如何用 GitHub Pages + Hugo 搭建个人博客"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 /* * @lc app=leetcode id=90 lang=java * * [90] Subsets II * * https://leetcode.com/problems/subsets-ii/description/ * * algorithms * Medium (56.68%) * Likes: 9237 * Dislikes: 265 * Total Accepted: 819.4K * Total Submissions: 1.4M * Testcase Example: \u0026#39;[1,2,2]\u0026#39; * * Given an integer array nums that may contain duplicates, return all possible * subsets (the power set). * * The solution set must not contain duplicate subsets. Return the solution in * any order. * * * Example 1: * Input: nums = [1,2,2] * Output: [[],[1],[1,2],[1,2,2],[2],[2,2]] * Example 2: * Input: nums = [0] * Output: [[],[0]] * * * Constraints: * * * 1 \u0026lt;= nums.length \u0026lt;= 10 * -10 \u0026lt;= nums[i] \u0026lt;= 10 * * * * Solution1 思路：使用回溯算法, 对unique数组的全排列的变种 * 问题拆分成 从n个元素的数组中选者k个元素的素全组合 * , 再收集所有子组合时去重即可 * * \u0026gt; https://leetcode.cn/problems/subsets-ii/solutions/1/90-zi-ji-iiche-di-li-jie-zi-ji-wen-ti-ru-djmf/ * Solution2 思路：这道题目和78.子集区别就是集合里有重复元素了，而且求取的子集要去重。 * 1 注意去重需要先对集合排序 * 2 画出树形图，从图中可以看出，同一树层上重复取2 就要过滤掉， * 同一树枝上就可以重复取2，因为同一树枝上元素的集合才是唯一子集！ */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 // @lc code=start import java.util.ArrayList; import java.util.Arrays; import java.util.List; // Solution1 for循环中遍历中排序，时间复杂度太高 class Solution1 { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsetsWithDup(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets = new ArrayList\u0026lt;\u0026gt;(); for(int k = 0; k\u0026lt;= nums.length; k++){ dfs(nums,0,k,new ArrayList\u0026lt;\u0026gt;(),subsets); } return subsets; } public void dfs(int[] nums, int begin, int k, List\u0026lt;Integer\u0026gt; cur , List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets ){ if(k == cur.size()){ //donnot collect dep subset if(isContainTargeList(subsets, new ArrayList\u0026lt;\u0026gt;(cur))){ return; } subsets.add(new ArrayList\u0026lt;\u0026gt;(cur)); return; } for(int i =begin; i \u0026lt;nums.length - (k - cur.size()-1); i++){ cur.add(nums[i]); dfs(nums, i+1, k, cur, subsets); cur.remove(cur.size()-1); } } public boolean isContainTargeList(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets, List\u0026lt;Integer\u0026gt; targeList ){ //因为是组合，不考虑元素顺序，所有需要遍历subsets,判断是否是否包含与targeList相同的组合 for(int i = 0; i\u0026lt; subsets.size();i++){ Collections.sort(subsets.get(i)); Collections.sort(targeList); if(subsets.get(i).equals(targeList)){ return true; } } return false; } } class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsetsWithDup(int[] nums) { Arrays.sort(nums); dfs(nums,0); return subsets; } public void dfs(int[] nums, int begin){ subsets.add(new ArrayList\u0026lt;\u0026gt;(path)); for(int i = begin; i\u0026lt; nums.length; i++ ){ //树的同一层，相同元素需要去重，直接跳过 if(i \u0026gt; begin \u0026amp;\u0026amp; nums[i] == nums[i-1]){ continue; } path.add(nums[i]); dfs(nums, i+1); path.removeLast(); } } } // @lc code=end ","date":"2024-01-23T00:00:00Z","image":"https://kris0325.github.io/p/90.subsets-ii/90_hu5477be140e37c38e9e48439fae2f6b6b_7746938_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/90.subsets-ii/","title":"90.subsets-ii"},{"content":"Hugo theme Stack supports the creation of interactive image galleries using Markdown. It\u0026rsquo;s powered by PhotoSwipe and its syntax was inspired by Typlog.\nTo use this feature, the image must be in the same directory as the Markdown file, as it uses Hugo\u0026rsquo;s page bundle feature to read the dimensions of the image. External images are not supported.\nSyntax 1 ![Image 1](1.jpg) ![Image 2](2.jpg) Result Photo by mymind and Luke Chesser on Unsplash\n","date":"2023-08-26T00:00:00Z","image":"https://kris0325.github.io/p/image-gallery/2_hubce42636ecacc1a380b462f3110efcec_37455_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/image-gallery/","title":"Image gallery"},{"content":" Photo by Codioful on Unsplash\n","date":"2023-08-25T00:00:00Z","image":"https://kris0325.github.io/p/shortcodes/cover_huec3c3e34981507583e214021ad1b9a4b_12942_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/shortcodes/","title":"Shortcodes"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://kris0325.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://kris0325.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"https://kris0325.github.io/p/math-typesetting/","title":"Math Typesetting"}]