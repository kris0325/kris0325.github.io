<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>subsets on Example Site</title>
        <link>https://example.com/tags/subsets/</link>
        <description>Recent content in subsets on Example Site</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>Example Person</copyright>
        <lastBuildDate>Tue, 23 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://example.com/tags/subsets/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>90.subsets-ii</title>
        <link>https://example.com/p/90.subsets-ii/</link>
        <pubDate>Tue, 23 Jan 2024 00:00:00 +0000</pubDate>
        
        <guid>https://example.com/p/90.subsets-ii/</guid>
        <description>&lt;img src="https://example.com/p/90.subsets-ii/90.jpg" alt="Featured image of post 90.subsets-ii" /&gt;&lt;p&gt;/*&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@lc app=leetcode id=90 lang=java&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;[90] Subsets II&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode.com/problems/subsets-ii/description/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://leetcode.com/problems/subsets-ii/description/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;algorithms&lt;/li&gt;
&lt;li&gt;Medium (56.68%)&lt;/li&gt;
&lt;li&gt;Likes:    9237&lt;/li&gt;
&lt;li&gt;Dislikes: 265&lt;/li&gt;
&lt;li&gt;Total Accepted:    819.4K&lt;/li&gt;
&lt;li&gt;Total Submissions: 1.4M&lt;/li&gt;
&lt;li&gt;Testcase Example:  &amp;lsquo;[1,2,2]&amp;rsquo;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Given an integer array nums that may contain duplicates, return all possible&lt;/li&gt;
&lt;li&gt;subsets (the power set).&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;The solution set must not contain duplicate subsets. Return the solution in&lt;/li&gt;
&lt;li&gt;any order.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Example 1:&lt;/li&gt;
&lt;li&gt;Input: nums = [1,2,2]&lt;/li&gt;
&lt;li&gt;Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]&lt;/li&gt;
&lt;li&gt;Example 2:&lt;/li&gt;
&lt;li&gt;Input: nums = [0]&lt;/li&gt;
&lt;li&gt;Output: [[],[0]]&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Constraints:&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= nums.length &amp;lt;= 10&lt;/li&gt;
&lt;li&gt;-10 &amp;lt;= nums[i] &amp;lt;= 10&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Solution1 思路：使用回溯算法, 对unique数组的全排列的变种&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt; 问题拆分成 从n个元素的数组中选者k个元素的素全组合
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt; , 再收集所有子组合时去重即可
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode.cn/problems/subsets-ii/solutions/1/90-zi-ji-iiche-di-li-jie-zi-ji-wen-ti-ru-djmf/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://leetcode.cn/problems/subsets-ii/solutions/1/90-zi-ji-iiche-di-li-jie-zi-ji-wen-ti-ru-djmf/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;Solution2 思路：这道题目和78.子集区别就是集合里有重复元素了，而且求取的子集要去重。&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;           1 注意去重需要先对集合排序
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;           2 画出树形图，从图中可以看出，同一树层上重复取2 就要过滤掉，
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;            同一树枝上就可以重复取2，因为同一树枝上元素的集合才是唯一子集！
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;*/&lt;/p&gt;
&lt;p&gt;// @lc code=start&lt;/p&gt;
&lt;p&gt;import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
// Solution1 for循环中遍历中排序，时间复杂度太高
class Solution1 {
public List&amp;lt;List&lt;Integer&gt;&amp;gt; subsetsWithDup(int[] nums) {
List&amp;lt;List&lt;Integer&gt;&amp;gt; subsets = new ArrayList&amp;lt;&amp;gt;();
for(int k = 0; k&amp;lt;= nums.length; k++){
dfs(nums,0,k,new ArrayList&amp;lt;&amp;gt;(),subsets);
} &lt;br&gt;
return subsets; &lt;br&gt;
}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void dfs(int[] nums, int begin, int k, List&amp;lt;Integer&amp;gt; cur
, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsets ){
    if(k == cur.size()){
        //donnot collect dep subset
        if(isContainTargeList(subsets, new ArrayList&amp;lt;&amp;gt;(cur))){
            return;
        }
        subsets.add(new ArrayList&amp;lt;&amp;gt;(cur));
        return;
    }
    for(int i =begin; i &amp;lt;nums.length - (k - cur.size()-1); i++){
        cur.add(nums[i]);
        dfs(nums, i+1, k, cur, subsets);
        cur.remove(cur.size()-1);
    }
}

public boolean isContainTargeList(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsets, List&amp;lt;Integer&amp;gt; targeList ){
    //因为是组合，不考虑元素顺序，所有需要遍历subsets,判断是否是否包含与targeList相同的组合
    for(int i = 0; i&amp;lt; subsets.size();i++){
        Collections.sort(subsets.get(i));
        Collections.sort(targeList);
        if(subsets.get(i).equals(targeList)){
            return true;
        }
    }
    return false;
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;class Solution {
List&amp;lt;List&lt;Integer&gt;&amp;gt; subsets = new ArrayList&amp;lt;&amp;gt;();
List&lt;Integer&gt; path = new ArrayList&amp;lt;&amp;gt;();&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsetsWithDup(int[] nums) {
    Arrays.sort(nums);
    dfs(nums,0);
    return subsets;
}

public void dfs(int[] nums, int begin){ 
    subsets.add(new ArrayList&amp;lt;&amp;gt;(path));

    for(int i = begin; i&amp;lt; nums.length; i++ ){
        //树的同一层，相同元素需要去重，直接跳过
        if(i &amp;gt; begin &amp;amp;&amp;amp; nums[i] == nums[i-1]){
            continue;
        }
        path.add(nums[i]);
        dfs(nums, i+1);
        path.removeLast();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;// @lc code=end&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
