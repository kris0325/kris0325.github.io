<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>subsets on thatkrisyang</title>
        <link>https://example.com/tags/subsets/</link>
        <description>Recent content in subsets on thatkrisyang</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>thatkrisyang</copyright>
        <lastBuildDate>Tue, 27 Feb 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://example.com/tags/subsets/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>216.Combination Sum III</title>
        <link>https://example.com/p/216.combination-sum-iii/</link>
        <pubDate>Tue, 27 Feb 2024 00:00:00 +0000</pubDate>
        
        <guid>https://example.com/p/216.combination-sum-iii/</guid>
        <description>&lt;img src="https://example.com/p/216.combination-sum-iii/216.jpg" alt="Featured image of post 216.Combination Sum III" /&gt;&lt;p&gt;/*&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@lc app=leetcode id=216 lang=java&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;[216] Combination Sum III&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode.com/problems/combination-sum-iii/description/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://leetcode.com/problems/combination-sum-iii/description/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;algorithms&lt;/li&gt;
&lt;li&gt;Medium (69.07%)&lt;/li&gt;
&lt;li&gt;Likes:    5799&lt;/li&gt;
&lt;li&gt;Dislikes: 107&lt;/li&gt;
&lt;li&gt;Total Accepted:    485.5K&lt;/li&gt;
&lt;li&gt;Total Submissions: 700.5K&lt;/li&gt;
&lt;li&gt;Testcase Example:  &amp;lsquo;3\n7&amp;rsquo;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Find all valid combinations of k numbers that sum up to n such that the&lt;/li&gt;
&lt;li&gt;following conditions are true:&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Only numbers 1 through 9 are used.&lt;/li&gt;
&lt;li&gt;Each number is used at most once.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Return a list of all possible valid combinations. The list must not contain&lt;/li&gt;
&lt;li&gt;the same combination twice, and the combinations may be returned in any&lt;/li&gt;
&lt;li&gt;order.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Example 1:&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Input: k = 3, n = 7&lt;/li&gt;
&lt;li&gt;Output: [[1,2,4]]&lt;/li&gt;
&lt;li&gt;Explanation:&lt;/li&gt;
&lt;li&gt;1 + 2 + 4 = 7&lt;/li&gt;
&lt;li&gt;There are no other valid combinations.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Example 2:&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Input: k = 3, n = 9&lt;/li&gt;
&lt;li&gt;Output: [[1,2,6],[1,3,5],[2,3,4]]&lt;/li&gt;
&lt;li&gt;Explanation:&lt;/li&gt;
&lt;li&gt;1 + 2 + 6 = 9&lt;/li&gt;
&lt;li&gt;1 + 3 + 5 = 9&lt;/li&gt;
&lt;li&gt;2 + 3 + 4 = 9&lt;/li&gt;
&lt;li&gt;There are no other valid combinations.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Example 3:&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Input: k = 4, n = 1&lt;/li&gt;
&lt;li&gt;Output: []&lt;/li&gt;
&lt;li&gt;Explanation: There are no valid combinations.&lt;/li&gt;
&lt;li&gt;Using 4 different numbers in the range [1,9], the smallest sum we can get is&lt;/li&gt;
&lt;li&gt;1+2+3+4 = 10 and since 10 &amp;gt; 1, there are no valid combination.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Constraints:&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;2 &amp;lt;= k &amp;lt;= 9&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= n &amp;lt;= 60&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;*/&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;思路： 本题就是在[1,2,3,4,5,6,7,8,9]这个集合中找到和为n的k个数的组合。
相对于77. 组合，无非就是多了一个限制，本题是要找到和为n的k个数的组合，而整个集合已经是固定的了[1,&amp;hellip;,9]。
想到这一点了，做过77. 组合之后，本题是简单一些了。
本题k相当于树的深度，9（因为整个集合就是9个数）就是树的宽度。
例如 k = 2，n = 4的话，就是在集合[1,2,3,4,5,6,7,8,9]中求 k（个数） = 2, n（和） = 4的组合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// @lc code=start
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;import java.util.ArrayList;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;import java.util.LinkedList;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;import java.util.ArrayList;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;import java.util.LinkedList;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;class Solution {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    LinkedList&amp;lt;Integer&amp;gt; path = new LinkedList&amp;lt;&amp;gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum3(int k, int n) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        backTrack( n , k,1,0 );
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return result;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    public void backTrack(Integer sumTarget, int k, int begin, int sum ){
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        //剪枝
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if(sum &amp;gt; sumTarget){
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            return;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if(path.size() == k &amp;amp;&amp;amp; sum == sumTarget ){
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            result.add(new ArrayList&amp;lt;&amp;gt;(path));
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            return;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        //剪枝 i &amp;lt;= 9 - (k -path.size()) +1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        for(int i = begin; i &amp;lt;= 9 - (k -path.size()) +1 ; i++){
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            path.add(i);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            sum += i;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            backTrack(sumTarget,k, i+1, sum);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            path.removeLast();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            sum -= i;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// @lc code=end
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
        </item>
        <item>
        <title>回溯算法</title>
        <link>https://example.com/p/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</link>
        <pubDate>Thu, 25 Jan 2024 00:00:00 +0000</pubDate>
        
        <guid>https://example.com/p/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</guid>
        <description>&lt;h1 id=&#34;回溯算法&#34;&gt;回溯算法&lt;/h1&gt;
&lt;h2 id=&#34;适用题型列出所有可能的选择如组合切割部分子集问题排列棋盘&#34;&gt;适用题型：列出所有可能的选择如：组合，切割，部分子集问题，排列，棋盘&lt;/h2&gt;
&lt;p&gt;e.g. leetcode 17.电话号码组合&lt;/p&gt;
&lt;p&gt;算法模板：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;void backstracking(List&amp;lt;Sting&amp;gt; arg1, Integer arg2...){
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         if(出口的终止条件){
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;               收集结果；
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;               rerun;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       for(集合元素){
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;               处理节点；
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              调用递归函数backstracking；
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              回溯操作；
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.youtube.com/watch?v=ev5XJ78Fn84&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.youtube.com/watch?v=ev5XJ78Fn84&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>90.subsets-ii</title>
        <link>https://example.com/p/90.subsets-ii/</link>
        <pubDate>Tue, 23 Jan 2024 00:00:00 +0000</pubDate>
        
        <guid>https://example.com/p/90.subsets-ii/</guid>
        <description>&lt;img src="https://example.com/p/90.subsets-ii/90.jpg" alt="Featured image of post 90.subsets-ii" /&gt;&lt;p&gt;/*&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@lc app=leetcode id=90 lang=java&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;[90] Subsets II&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode.com/problems/subsets-ii/description/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://leetcode.com/problems/subsets-ii/description/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;algorithms&lt;/li&gt;
&lt;li&gt;Medium (56.68%)&lt;/li&gt;
&lt;li&gt;Likes:    9237&lt;/li&gt;
&lt;li&gt;Dislikes: 265&lt;/li&gt;
&lt;li&gt;Total Accepted:    819.4K&lt;/li&gt;
&lt;li&gt;Total Submissions: 1.4M&lt;/li&gt;
&lt;li&gt;Testcase Example:  &amp;lsquo;[1,2,2]&amp;rsquo;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Given an integer array nums that may contain duplicates, return all possible&lt;/li&gt;
&lt;li&gt;subsets (the power set).&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;The solution set must not contain duplicate subsets. Return the solution in&lt;/li&gt;
&lt;li&gt;any order.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Example 1:&lt;/li&gt;
&lt;li&gt;Input: nums = [1,2,2]&lt;/li&gt;
&lt;li&gt;Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]&lt;/li&gt;
&lt;li&gt;Example 2:&lt;/li&gt;
&lt;li&gt;Input: nums = [0]&lt;/li&gt;
&lt;li&gt;Output: [[],[0]]&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Constraints:&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= nums.length &amp;lt;= 10&lt;/li&gt;
&lt;li&gt;-10 &amp;lt;= nums[i] &amp;lt;= 10&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Solution1 思路：使用回溯算法, 对unique数组的全排列的变种&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt; 问题拆分成 从n个元素的数组中选者k个元素的素全组合
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt; , 再收集所有子组合时去重即可
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode.cn/problems/subsets-ii/solutions/1/90-zi-ji-iiche-di-li-jie-zi-ji-wen-ti-ru-djmf/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://leetcode.cn/problems/subsets-ii/solutions/1/90-zi-ji-iiche-di-li-jie-zi-ji-wen-ti-ru-djmf/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;Solution2 思路：这道题目和78.子集区别就是集合里有重复元素了，而且求取的子集要去重。&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;           1 注意去重需要先对集合排序
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;           2 画出树形图，从图中可以看出，同一树层上重复取2 就要过滤掉，
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;            同一树枝上就可以重复取2，因为同一树枝上元素的集合才是唯一子集！
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;*/&lt;/p&gt;
&lt;p&gt;// @lc code=start&lt;/p&gt;
&lt;p&gt;import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
// Solution1 for循环中遍历中排序，时间复杂度太高
class Solution1 {
public List&amp;lt;List&lt;Integer&gt;&amp;gt; subsetsWithDup(int[] nums) {
List&amp;lt;List&lt;Integer&gt;&amp;gt; subsets = new ArrayList&amp;lt;&amp;gt;();
for(int k = 0; k&amp;lt;= nums.length; k++){
dfs(nums,0,k,new ArrayList&amp;lt;&amp;gt;(),subsets);
} &lt;br&gt;
return subsets; &lt;br&gt;
}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void dfs(int[] nums, int begin, int k, List&amp;lt;Integer&amp;gt; cur
, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsets ){
    if(k == cur.size()){
        //donnot collect dep subset
        if(isContainTargeList(subsets, new ArrayList&amp;lt;&amp;gt;(cur))){
            return;
        }
        subsets.add(new ArrayList&amp;lt;&amp;gt;(cur));
        return;
    }
    for(int i =begin; i &amp;lt;nums.length - (k - cur.size()-1); i++){
        cur.add(nums[i]);
        dfs(nums, i+1, k, cur, subsets);
        cur.remove(cur.size()-1);
    }
}

public boolean isContainTargeList(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsets, List&amp;lt;Integer&amp;gt; targeList ){
    //因为是组合，不考虑元素顺序，所有需要遍历subsets,判断是否是否包含与targeList相同的组合
    for(int i = 0; i&amp;lt; subsets.size();i++){
        Collections.sort(subsets.get(i));
        Collections.sort(targeList);
        if(subsets.get(i).equals(targeList)){
            return true;
        }
    }
    return false;
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;class Solution {
List&amp;lt;List&lt;Integer&gt;&amp;gt; subsets = new ArrayList&amp;lt;&amp;gt;();
List&lt;Integer&gt; path = new ArrayList&amp;lt;&amp;gt;();&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsetsWithDup(int[] nums) {
    Arrays.sort(nums);
    dfs(nums,0);
    return subsets;
}

public void dfs(int[] nums, int begin){ 
    subsets.add(new ArrayList&amp;lt;&amp;gt;(path));

    for(int i = begin; i&amp;lt; nums.length; i++ ){
        //树的同一层，相同元素需要去重，直接跳过
        if(i &amp;gt; begin &amp;amp;&amp;amp; nums[i] == nums[i-1]){
            continue;
        }
        path.add(nums[i]);
        dfs(nums, i+1);
        path.removeLast();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;// @lc code=end&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
